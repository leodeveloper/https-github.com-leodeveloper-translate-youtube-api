{
    "source": "HW__or3B9pw",
    "youtubelink": "https://www.youtube.com/watch?v=HW__or3B9pw",
    "t_english": "- [Instructor] What happens when you assign, reassign, or access a variable in a program? Let's trace the execution of a program with variables to find out. When the program starts running, the computer loads the first instruction into its working memory. This instruction is an assignment statement. The left-hand side is the variable name, the equal sign is the assignment operator, and the right-hand side is the value to be stored in that variable. The computer looks for any expressions to simplify on the right-hand side. But in this case, the string is already a single value. When the computer executes an assignment statement, it goes off to its short-term memory and looks for a label with that variable name. Here, it looks for the name gene, but it doesn't find it. That means it doesn't already know a gene. It needs to create one. So the computer allocates a new chunk of memory for this new variable. It tags that chunk of memory with the name gene so it can distinguish it from its other chunks of memory. Then it takes the value on the right-hand side of the assignment operator and copies it over to that location in short-term memory. That way, it doesn't forget it when it clears out its working memory in a second. Okay, well, this instruction is complete. So the computer's going to clear out its working memory, forget all of this stuff here, and move on to the next line. However, anything that it stored in its short-term memory stays behind. Here we have another assignment statement. With this one though, on the right-hand side of the assignment operator, there's an unsimplified expression. Like humans, it's much easier for the computer to remember a single value, like 11, than the long expression four plus five plus two. So the computer makes sure to simplify any expressions on the right-hand side of the assignment operator down to a single value before it memorizes it. Now we have 11. So the computer goes off to its short-term memory, looks for the label num_mutations. Doesn't find it, so creates a new variable, allocates a new chunk of memory, tags it, and copies the value 11 over from working memory. Once that value is stored, this instruction is complete. So the computer clears out working memory and moves to the next line. Now we have a print instruction. The computer looks inside of the parentheses first for any expressions to simplify and finds the variable name gene. Now this is not an assignment. The name gene is not on the left-hand side of an equal sign or assignment operator. That means we are accessing the value stored in gene, not setting it. The computer goes off to its short-term memory, looks for the label gene, finds it, and then follows it to the location in memory that it points to. Then it substitutes the value stored there into the instruction in working memory. For the second part, note that there are quotation marks here. That means that this is just the string gene, not the variable gene. So we're not going off to access anything in short-term memory. We're just concatenating these two strings together. Once we're down to a single value, the computer peeks outside the parentheses, asks what it's supposed to do with that value, sees print, and prints BRCA2gene to the console. Next line, we have a self-referencing assignment statement. The variable we're assigning to on the left-hand side is num_mutations, but we're also accessing the variable num_mutations on the right-hand side. Not a problem, because we always evaluate the right-hand side first. So we access the variable num_mutations, look up what value it currently has stored there, and substitute that in on the right-hand side only. Then we evaluate this expression. Now that we have a single value, we're ready to store. The computer sees that it already has a variable num_mutations, so it's not going to create a new one. Instead, it'll allocate a new chunk of memory, store the value 12 there, and then take that existing num_mutations and move it to point to that new chunk of memory. That old chunk of memory with that old value is now unreachable. So the computer will come in and clear that out at some point to make more room. Then it clears out and picks up the next line. How do you think this assignment works? Though it may look like it, this does not create some special permanent link between the variable gene and the variable num_mutations where they'll forever be the same value now. What it does is go off to its short-term memory, looks for the variable gene, and then moves it to point to the same location as num_mutations. The computer does this as an optimization because it could have allocated a new chunk of memory, store the value 12 there, too, and then have gene point to it. In some cases though, we may be storing really big values. It could take up a lot of space and memory if the computer had to copy over a big value multiple times. So it would rather not if it can avoid it. And now that this old location is unreachable, it goes away. We clear out and we load in the next line. On the right-hand side of the assignment operator, we have an expression. So we need to simplify that first. We're accessing the variable gene 'cause it's on the right-hand side. So we go off to short-term memory, grab that value, substitute it in, and then we just add these integers together. We find the label num_mutations in short-term memory. So we allocate a new chunk of memory, store the value 17 there, and then move num_mutations to point to that new location. Note that this doesn't affect the value of gene. We moved num_mutations to point to a different location, but we didn't move gene. It still points to that old location with the value 12. Because that location is still reachable through the variable gene, it sticks around. This last line is just a print function. So we evaluate the expression inside the parentheses first. We go off, we grab the value stored in num_mutations, we substitute it in, and then we do the same for the variable gene. We add those two integers together to get a single value. And then we peek outside the parentheses and see that we need to print that value to the console. The computer looks for the next line and finds that it's at the end of the program. When the program terminates, short-term memory gets cleared. So all these variables go away. And now the computer has room again to remember new things the next time you run a program.\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n",
    "t_urdu": "- [انسٹرکٹر]\nجب آپ کسی پروگرام میں متغیر کو تفویض، دوبارہ تفویض، یا رسائی حاصل کرتے ہیں تو کیا ہوتا ہے؟ آئیے معلوم کرنے کے لیے متغیرات کے ساتھ ایک پروگرام کے عمل کو ٹریس کریں۔ جب پروگرام چلنا شروع ہوتا ہے، کمپیوٹر پہلی ہدایات کو اپنی ورکنگ میموری میں لوڈ کرتا ہے۔ یہ ہدایت ایک\nتفویض بیان ہے۔ بائیں ہاتھ کی طرف متغیر کا نام ہے، مساوی نشان اسائنمنٹ آپریٹر ہے، اور دائیں طرف وہ\nقدر ہے جسے اس متغیر میں ذخیرہ کیا جانا ہے۔ کمپیوٹر دائیں طرف سے کسی بھی تاثرات کو آسان بنانے کے لیے تلاش کرتا ہے۔ لیکن اس صورت میں، تار\nپہلے سے ہی ایک واحد قدر ہے. جب کمپیوٹر اسائنمنٹ سٹیٹمنٹ پر عمل کرتا ہے، تو\n یہ اپنی قلیل مدتی میموری پر چلا جاتا ہے اور\nاس متغیر نام کے ساتھ ایک لیبل تلاش کرتا ہے۔ یہاں، یہ نام کا\nجین تلاش کرتا ہے، لیکن اسے نہیں ملتا۔ اس کا مطلب ہے کہ یہ پہلے سے کسی جین کو نہیں جانتا۔ اسے ایک بنانے کی ضرورت ہے۔ تو کمپیوٹر اس نئے متغیر کے لیے\nمیموری کا ایک نیا حصہ مختص کرتا ہے۔ یہ میموری کے اس حصے کو\nنام کے جین کے ساتھ ٹیگ کرتا ہے تاکہ یہ اسے\nاس کے میموری کے دوسرے حصوں سے ممتاز کر سکے۔ پھر یہ اسائنمنٹ آپریٹر کے دائیں طرف کی قیمت لیتا ہے \n اور اسے\nمختصر مدتی میموری میں اس مقام پر کاپی کرتا ہے۔ اس طرح، جب یہ اپنی\nورکنگ میموری کو ایک سیکنڈ میں صاف کر دیتا ہے تو یہ اسے نہیں بھولتا۔ ٹھیک ہے، یہ ہدایت مکمل ہے. تو کمپیوٹر\nاپنی ورکنگ میموری کو صاف کرنے جا رہا ہے، ان تمام چیزوں کو یہاں بھول جائے گا، اور اگلی لائن پر چلے جائیں گے۔ تاہم، جو کچھ بھی اس نے\nاپنی قلیل مدتی یادداشت میں محفوظ کیا ہے وہ پیچھے رہ جاتا ہے۔ یہاں ہمارے پاس ایک اور اسائنمنٹ کا بیان ہے۔ اگرچہ اس کے ساتھ، اسائنمنٹ آپریٹر کے دائیں جانب،\n ایک غیر آسان اظہار ہے۔ انسانوں کی طرح،\nکمپیوٹر کے لیے 11 کی طرح ایک واحد قدر کو یاد رکھنا بہت آسان ہے، \nچار جمع پانچ جمع دو کے مقابلے میں۔ لہذا کمپیوٹر اس بات کو یقینی بناتا ہے کہ اسائنمنٹ آپریٹر\n کے دائیں طرف کے کسی بھی تاثرات کو یاد کرنے سے پہلے اسے\n ایک ہی قدر تک آسان بنا دے۔\n اب ہمارے پاس 11 ہے۔ تو کمپیوٹر\nاپنی قلیل مدتی میموری پر چلا جاتا ہے، num_mutations کا لیبل تلاش کرتا ہے۔ یہ نہیں ملتا ہے، لہذا\nایک نیا متغیر بناتا ہے، میموری کا ایک نیا حصہ مختص کرتا ہے، اسے ٹیگ کرتا ہے، اور ورکنگ میموری سے 11 کی قدر کو کاپی کرتا ہے۔\n ایک بار جب وہ قدر ذخیرہ ہو جاتی ہے،\nیہ ہدایت مکمل ہو جاتی ہے۔ لہذا کمپیوٹر ورکنگ میموری کو صاف کرتا ہے اور اگلی لائن پر چلا جاتا ہے۔ اب ہمارے پاس پرنٹ کی ہدایت ہے۔ کمپیوٹر\n کسی بھی تاثرات کو آسان بنانے کے لیے پہلے قوسین کے اندر دیکھتا ہے اور متغیر نام کے جین کو تلاش کرتا ہے۔ اب یہ اسائنمنٹ نہیں ہے۔ نام کا جین\nکسی مساوی نشان یا اسائنمنٹ آپریٹر کے بائیں جانب نہیں ہے۔ اس کا مطلب ہے کہ ہم\nجین میں ذخیرہ شدہ قدر تک رسائی حاصل کر رہے ہیں، اسے ترتیب نہیں دے رہے ہیں۔ کمپیوٹر\nاپنی قلیل مدتی میموری پر جاتا ہے، لیبل جین کو تلاش کرتا ہے، اسے ڈھونڈتا ہے، اور پھر اسے میموری میں اس مقام تک لے جاتا ہے\n جس کی طرف وہ اشارہ کرتا ہے۔ پھر یہ وہاں ذخیرہ شدہ قدر کو ورکنگ میموری میں ہدایات میں بدل دیتا ہے۔ دوسرے حصے کے لیے، نوٹ کریں کہ یہاں اقتباس کے نشانات ہیں۔ اس کا مطلب ہے کہ یہ\nصرف سٹرنگ جین ہے، متغیر جین نہیں۔ لہذا ہم مختصر مدتی میموری میں کسی بھی چیز تک رسائی حاصل کرنے کے لئے نہیں جا رہے ہیں۔ ہم صرف\nان دو تاروں کو ایک ساتھ جوڑ رہے ہیں۔ ایک بار جب ہم ایک ہی قدر پر پہنچ جاتے ہیں، تو کمپیوٹر\nقوسین کے باہر جھانکتا ہے، پوچھتا ہے کہ\nاس قدر کے ساتھ کیا کرنا ہے، پرنٹ دیکھتا ہے، اور کنسول پر BRCA2gene پرنٹ کرتا ہے۔ اگلی سطر، ہمارے پاس ایک خود حوالہ\nتفویض بیان ہے۔ ہم بائیں جانب جس متغیر کو تفویض کر رہے ہیں وہ\n num_mutations ہے، لیکن ہم دائیں جانب متغیر num_mutations تک بھی رسائی حاصل کر رہے ہیں۔  کوئی\n مسئلہ نہیں، کیونکہ ہم ہمیشہ پہلے دائیں طرف کا جائزہ لیتے ہیں۔ لہذا ہم متغیر num_mutations تک رسائی حاصل کرتے ہیں، دیکھیں کہ اس نے\nاس وقت وہاں کیا قیمت ذخیرہ کی ہے، اور اس کو\nصرف دائیں جانب تبدیل کرتے ہیں۔ پھر ہم اس اظہار کا جائزہ لیتے ہیں۔ اب جب کہ ہمارے پاس ایک ہی\nقدر ہے، ہم ذخیرہ کرنے کے لیے تیار ہیں۔ کمپیوٹر دیکھتا ہے کہ اس میں پہلے سے ہی ایک متغیر num_mutations موجود ہے، اس لیے یہ نیا نہیں بنائے گا۔  اس کے بجائے، یہ\nمیموری کا ایک نیا حصہ مختص کرے گا، قیمت 12 کو وہاں ذخیرہ کرے گا، اور پھر اس موجودہ num_mutations کو لے کر اسے\nمیموری کے اس نئے حصے کی طرف اشارہ کرنے کے لیے منتقل کرے گا۔  اس پرانی قدر کے ساتھ یادداشت کا وہ پرانا حصہ\n اب ناقابل رسائی ہے۔ تو کمپیوٹر اندر آ جائے گا اور اسے صاف کر دے گا کسی\nوقت مزید جگہ بنانے کے لیے۔ پھر یہ صاف ہو جاتا ہے اور\nاگلی لائن اٹھا لیتا ہے۔ آپ کے خیال میں یہ اسائنمنٹ کیسے کام کرتی ہے؟ اگرچہ یہ ایسا لگتا ہے، یہ\n متغیر جین اور\nمتغیر num_mutations کے درمیان کوئی خاص مستقل ربط پیدا نہیں کرتا ہے جہاں وہ ہمیشہ کے لیے\nایک ہی قدر رہیں گے۔  یہ جو کرتا ہے وہ\nاس کی قلیل مدتی یادداشت پر جاتا ہے، متغیر جین کو تلاش کرتا ہے، اور پھر اسے اسی مقام کی طرف لے جاتا ہے جہاں\n num_mutations ہوتا ہے۔ کمپیوٹر یہ ایک اصلاح کے طور پر کرتا ہے کیونکہ اس نے\nمیموری کا ایک نیا حصہ مختص کیا ہو سکتا تھا، قیمت 12 کو وہاں بھی ذخیرہ کیا ہو، اور پھر اس کی طرف جین پوائنٹ رکھ سکے۔ اگرچہ کچھ معاملات میں، ہم\nواقعی بڑی قدروں کو ذخیرہ کر رہے ہیں۔  اگر کمپیوٹر کو ایک بڑی قیمت پر متعدد بار کاپی کرنا پڑے تو یہ بہت زیادہ جگہ اور میموری لے سکتا ہے۔ \n لہذا یہ اس سے بچنے کے قابل نہیں ہے. اور اب جب کہ یہ پرانا مقام\nناقابل رسائی ہے، یہ چلا جاتا ہے۔ ہم صاف کرتے ہیں اور اگلی لائن میں لوڈ کرتے ہیں۔  اسائنمنٹ آپریٹر کے دائیں جانب،\n ہمارے پاس ایک اظہار ہے۔ تو ہمیں پہلے اسے آسان بنانے کی ضرورت ہے۔ ہم متغیر جین تک رسائی حاصل کر رہے ہیں کیونکہ یہ دائیں طرف ہے۔ تو ہم قلیل مدتی میموری کی طرف جاتے ہیں، اس قدر کو حاصل کرتے ہیں، اسے تبدیل کرتے ہیں، اور پھر ہم صرف\nان عدد کو ایک ساتھ شامل کرتے ہیں۔ ہمیں\nقلیل مدتی میموری میں num_mutations کا لیبل ملتا ہے۔ لہذا ہم میموری کا ایک نیا حصہ مختص کرتے ہیں، قیمت 17 کو وہاں ذخیرہ کرتے ہیں، اور پھر num_mutations کو\nاس نئے مقام کی طرف اشارہ کرنے کے لیے منتقل کرتے ہیں۔ نوٹ کریں کہ یہ\nجین کی قدر کو متاثر نہیں کرتا ہے۔ ہم نے num_mutations کو\nایک مختلف مقام کی طرف اشارہ کرنے کے لیے منتقل کیا، لیکن ہم نے جین کو منتقل نہیں کیا۔ یہ اب بھی\n12 کی قدر کے ساتھ اس پرانے مقام کی طرف اشارہ کرتا ہے۔ کیونکہ وہ مقام متغیر جین کے ذریعے اب بھی قابل رسائی ہے، اس لیے \nیہ چپک جاتا ہے۔ یہ آخری لائن صرف ایک پرنٹ فنکشن ہے۔ لہذا ہم پہلے قوسین کے اندر اظہار کا جائزہ لیتے ہیں۔\n ہم چلے جاتے ہیں، ہم\nnum_mutations میں ذخیرہ شدہ قدر کو پکڑتے ہیں، ہم اسے اس میں بدل دیتے ہیں، اور پھر ہم\nمتغیر جین کے لیے بھی ایسا ہی کرتے ہیں۔ ہم ایک واحد قدر حاصل کرنے کے لیے ان دو عدد عدد کو\nایک ساتھ جوڑتے ہیں۔ اور پھر ہم قوسین کے باہر جھانکتے ہیں اور دیکھتے ہیں کہ ہمیں\nاس قدر کو کنسول پر پرنٹ کرنے کی ضرورت ہے۔ کمپیوٹر اگلی لائن تلاش کرتا ہے اور اسے پتہ چلتا ہے کہ یہ\nپروگرام کے آخر میں ہے۔ جب پروگرام ختم ہو جاتا ہے تو،\nقلیل مدتی میموری صاف ہو جاتی ہے۔ تو یہ تمام متغیرات چلے جاتے ہیں۔ اور اب\n اگلی بار جب آپ کوئی پروگرام چلاتے ہیں تو کمپیوٹر کے پاس نئی چیزیں یاد رکھنے کی گنجائش ہے۔",
    "t_spanish": "- [Instructor] ¿Qué sucede\ncuando asignas, reasignas o accedes a una variable en un programa? Rastreemos la ejecución de un programa con variables para averiguarlo. Cuando el programa comienza a ejecutarse, la computadora carga la primera instrucción en su memoria de trabajo. Esta instrucción es una\ndeclaración de asignación. El lado izquierdo es el nombre de la variable, el signo igual es el operador de asignación y el lado derecho\nes el valor que se almacenará en esa variable. La computadora busca expresiones para simplificar en el lado derecho. Pero en este caso, la cadena\nya tiene un valor único. Cuando la computadora ejecuta\nuna declaración de asignación, va a su memoria a corto plazo y busca una etiqueta\ncon ese nombre de variable. Aquí busca el nombre del\ngen, pero no lo encuentra. Eso significa que aún no conoce ningún gen. Necesita crear uno. Entonces la computadora asigna\nuna nueva porción de memoria para esta nueva variable. Etiqueta ese fragmento de\nmemoria con el nombre gen para poder distinguirlo de\notros fragmentos de memoria. Luego toma el valor en el lado derecho\ndel operador de asignación y lo copia en esa\nubicación en la memoria a corto plazo.  De esa forma, no lo olvidará cuando borre su\nmemoria de trabajo en un segundo. Bien, bueno, esta instrucción está completa. Entonces la computadora\nborrará su memoria de trabajo, olvidará todo esto y pasará a la siguiente línea. Sin embargo, todo lo que\nalmacenó en su memoria a corto plazo se queda atrás. Aquí tenemos otra declaración de asignación.  Sin embargo, en este caso, en el lado derecho\ndel operador de asignación, hay una expresión no simplificada. Al igual que los humanos, es mucho\nmás fácil para la computadora recordar un solo valor, como 11, que la expresión larga\ncuatro más cinco más dos. Entonces, la computadora se asegura\nde simplificar cualquier expresión en el lado derecho\ndel operador de asignación a un solo valor\nantes de memorizarlo. Ahora tenemos 11. Entonces la computadora va\na su memoria a corto plazo y busca la etiqueta num_mutations. No lo encuentra, por lo que\ncrea una nueva variable, asigna una nueva porción de memoria, la etiqueta y copia el valor 11\nde la memoria de trabajo. Una vez que se almacena ese valor,\nesta instrucción está completa. Entonces la computadora borra la memoria de trabajo y pasa a la siguiente línea. Ahora tenemos una instrucción de impresión. La computadora primero busca dentro\ndel paréntesis cualquier expresión que desee simplificar y encuentra el nombre de la variable gen. Ahora bien, esto no es una tarea. El nombre del gen no está en el\nlado izquierdo de un signo igual o de un operador de asignación. Eso significa que estamos accediendo\nal valor almacenado en el gen, no estableciéndolo. La computadora va a\nsu memoria a corto plazo, busca el gen etiquetado, lo encuentra y luego lo sigue hasta\nla ubicación de la memoria a la que apunta. Luego sustituye el valor almacenado allí en la instrucción de la memoria de trabajo. Para la segunda parte, tenga en cuenta que aquí hay comillas. Eso significa que este es\nsólo el gen de cadena, no el gen variable. Así que no vamos a acceder a nada en la memoria a corto plazo. Simplemente estamos concatenando\nestas dos cadenas. Una vez que llegamos a un valor único, la computadora mira\nfuera del paréntesis, pregunta qué se supone que debe hacer\ncon ese valor, ve la impresión e imprime BRCA2gene en la consola.  En la siguiente línea, tenemos una\ndeclaración de asignación autorreferenciada. La variable que asignamos\nen el lado izquierdo es num_mutations, pero también accedemos a\nla variable num_mutations en el lado derecho. No hay problema, porque siempre evaluamos primero el lado derecho. Entonces accedemos a la variable num_mutations, buscamos qué valor\ntiene actualmente almacenado allí y lo sustituimos\nsolo en el lado derecho. Luego evaluamos esta expresión. Ahora que tenemos un\nvalor único, estamos listos para almacenar. La computadora ve que ya tiene una variable num_mutations, por lo que no creará una nueva. En su lugar, asignará\nuna nueva porción de memoria, almacenará el valor 12 allí y luego tomará ese num_mutations existente y lo moverá para que apunte a\nesa nueva porción de memoria. Ese viejo fragmento de memoria\ncon ese antiguo valor ahora es inalcanzable. Entonces la computadora entrará y lo limpiará en algún\nmomento para hacer más espacio. Luego se aclara y\ncontinúa con la siguiente línea.  ¿ Cómo crees que funciona esta tarea? Aunque pueda parecerlo, esto no crea ningún\nvínculo permanente especial entre la variable gen y\nla variable num_mutations donde\nahora siempre tendrán el mismo valor. Lo que hace es ir\na su memoria a corto plazo, busca el gen variable y luego lo mueve para que\napunte a la misma ubicación que num_mutations. La computadora hace esto como una optimización porque podría haber asignado\nuna nueva porción de memoria, almacenar el valor 12 allí también y luego hacer que el gen lo apunte.  Sin embargo, en algunos casos, es posible que\nestemos almacenando valores realmente grandes. Podría ocupar mucho espacio y memoria si la computadora tuviera que copiar\nun valor grande varias veces. Así que preferiría no hacerlo si pudiera evitarlo. Y ahora que esta antigua ubicación\nes inalcanzable, desaparece. Limpiamos y cargamos en la siguiente línea. En el lado derecho del\noperador de asignación tenemos una expresión. Así que primero debemos simplificar eso. Estamos accediendo al gen variable porque está en el lado derecho. Entonces vamos a la memoria a corto plazo, tomamos ese valor, lo sustituimos y luego simplemente sumamos\nestos números enteros. Encontramos la etiqueta num_mutations\nen la memoria a corto plazo. Entonces asignamos una nueva porción de memoria, almacenamos el valor 17 allí y luego movemos num_mutations\npara que apunte a esa nueva ubicación. Tenga en cuenta que esto no\nafecta el valor del gen. Movimos num_mutations para\nseñalar una ubicación diferente, pero no movimos gen. Todavía apunta a esa antigua\nubicación con el valor 12. Debido a que todavía se puede acceder a esa ubicación a través del\ngen variable, se queda. Esta última línea es solo una función de impresión. Así que primero evaluamos la expresión\ndentro del paréntesis. Salimos, tomamos el valor\nalmacenado en num_mutations, lo sustituimos y luego hacemos lo mismo\ncon la variable gen. Sumamos esos dos números enteros\npara obtener un valor único. Y luego miramos fuera del paréntesis y vemos que necesitamos imprimir\nese valor en la consola. La computadora busca la siguiente línea y descubre que está al\nfinal del programa. Cuando el programa finaliza,\nla memoria a corto plazo se borra. Entonces todas estas variables desaparecen. Y ahora la computadora vuelve a tener espacio\npara recordar cosas nuevas la próxima vez que ejecute un programa.",
    "t_arabic": "- [المدرس] ماذا يحدث\nعند تعيين متغير في البرنامج أو إعادة تعيينه أو الوصول إليه؟ دعونا نتتبع تنفيذ البرنامج باستخدام المتغيرات لمعرفة ذلك. عندما يبدأ تشغيل البرنامج، يقوم الكمبيوتر بتحميل التعليمات الأولى في ذاكرته العاملة. هذه التعليمات هي\nبيان المهمة. الجانب الأيسر هو اسم المتغير، وعلامة المساواة هي عامل التعيين، والجانب الأيمن\nهو القيمة التي سيتم تخزينها في هذا المتغير. يبحث الكمبيوتر عن أي تعبيرات لتبسيطها على الجانب الأيمن. ولكن في هذه الحالة، السلسلة\nهي بالفعل قيمة واحدة. عندما ينفذ الكمبيوتر\nعبارة مهمة، فإنه ينتقل إلى ذاكرته قصيرة المدى ويبحث عن تسمية\nبهذا الاسم المتغير. وهنا يبحث عن اسم\nالجين فلا يجده. وهذا يعني أنه لا يعرف الجين بالفعل. يحتاج إلى إنشاء واحد. لذلك يخصص الكمبيوتر\nجزءًا جديدًا من الذاكرة لهذا المتغير الجديد. ويقوم بوضع علامة على هذا الجزء من\nالذاكرة باسم الجين حتى يتمكن من تمييزه عن\nأجزاء الذاكرة الأخرى. ثم يأخذ القيمة الموجودة على الجانب الأيمن من\nعامل التعيين وينسخها إلى ذلك\nالموقع في الذاكرة قصيرة المدى. وبهذه الطريقة، فإنه لا ينساها عندما يقوم بمسح\nذاكرته العاملة في ثانية واحدة. حسنًا، حسنًا، هذه التعليمات كاملة. لذلك سيقوم الكمبيوتر\nبمسح ذاكرته العاملة، وينسى كل هذه الأشياء هنا، وينتقل إلى السطر التالي. ومع ذلك، فإن أي شيء\nيخزنه في ذاكرته قصيرة المدى يبقى في الخلف. هنا لدينا بيان مهمة آخر. مع هذا، على الجانب الأيمن من\nعامل الإسناد، يوجد تعبير غير مبسط. مثل البشر، من\nالأسهل على الكمبيوتر أن يتذكر قيمة واحدة، مثل 11، بدلاً من التعبير الطويل\nأربعة زائد خمسة زائد اثنين. لذلك يتأكد الكمبيوتر من\nتبسيط أي تعبيرات على الجانب الأيمن من\nعامل التعيين إلى قيمة واحدة\nقبل أن يحفظها. الآن لدينا 11. لذا ينتقل الكمبيوتر\nإلى ذاكرته قصيرة المدى، ويبحث عن الملصق num_mutations. لم يعثر عليه، لذا\nقم بإنشاء متغير جديد، وتخصيص جزء جديد من الذاكرة، ووضع علامات عليه، ونسخ القيمة 11\nمن الذاكرة العاملة. بمجرد تخزين هذه القيمة،\nتكتمل هذه التعليمات. لذلك يقوم الكمبيوتر بمسح الذاكرة العاملة والانتقال إلى السطر التالي. الآن لدينا تعليمات الطباعة. يبحث الكمبيوتر داخل\nالأقواس أولاً عن أي تعبيرات لتبسيطها ويجد جين اسم المتغير. الآن هذه ليست مهمة. اسم الجين ليس على\nالجانب الأيسر من علامة المساواة أو عامل التخصيص. وهذا يعني أننا نصل إلى\nالقيمة المخزنة في الجين، وليس تحديدها. ينتقل الكمبيوتر إلى\nذاكرته قصيرة المدى، ويبحث عن جينة التسمية، ويجدها، ثم يتبعها إلى\nالموقع الذي يشير إليه في الذاكرة. ثم يقوم باستبدال القيمة المخزنة هناك في التعليمات الموجودة في الذاكرة العاملة. بالنسبة للجزء الثاني، لاحظ أن هناك علامات اقتباس هنا. وهذا يعني أن هذا\nمجرد جين السلسلة، وليس الجين المتغير. لذلك نحن لن نذهب للوصول إلى أي شيء في الذاكرة قصيرة المدى. نحن فقط نقوم بربط\nهاتين السلسلتين معًا. بمجرد وصولنا إلى قيمة واحدة، يلقي الكمبيوتر نظرة خاطفة\nخارج الأقواس، ويسأل عما يفترض أن يفعله\nبهذه القيمة، ويرى الطباعة، ويطبع جين BRCA2 على وحدة التحكم. السطر التالي، لدينا\nبيان مهمة مرجعي ذاتي. المتغير الذي قمنا بتعيينه\nعلى الجانب الأيسر هو num_mutations، لكننا أيضًا نصل إلى\nالمتغير num_mutations على الجانب الأيمن. ليست مشكلة، لأننا دائمًا نحسب قيمة الطرف الأيمن أولًا. لذا، يمكننا الوصول إلى المتغير num_mutations، والبحث عن القيمة\nالمخزنة هناك حاليًا، واستبدالها على\nالجانب الأيمن فقط. ثم نقيم هذا التعبير. الآن بعد أن أصبح لدينا\nقيمة واحدة، نحن جاهزون للتخزين. يرى الكمبيوتر أن لديه بالفعل متغير num_mutations، لذلك لن يقوم بإنشاء متغير جديد. بدلاً من ذلك، ستخصص\nقطعة جديدة من الذاكرة، وتخزن القيمة 12 هناك، ثم تأخذ تلك الأرقام الموجودة وتنقلها للإشارة إلى\nتلك القطعة الجديدة من الذاكرة.  لم يعد من الممكن الآن الوصول إلى تلك القطعة القديمة من الذاكرة التي\nتحمل تلك القيمة القديمة . لذلك سيأتي الكمبيوتر ويزيل ذلك في\nمرحلة ما لتوفير مساحة أكبر. ثم يتم مسحه\nوالتقاط السطر التالي. كيف تعتقد أن هذه المهمة تعمل؟ على الرغم من أن الأمر قد يبدو كذلك، إلا أن هذا لا يخلق\nرابطًا خاصًا دائمًا بين الجين المتغير والمتغير\nnum_mutations حيث سيظلان\nبنفس القيمة إلى الأبد الآن. ما يفعله هو الانتقال\nإلى ذاكرته قصيرة المدى، والبحث عن الجين المتغير، ثم تحريكه\nللإشارة إلى نفس موقع num_mutations. يقوم الكمبيوتر بذلك كتحسين لأنه كان من الممكن تخصيص\nجزء جديد من الذاكرة، وتخزين القيمة 12 هناك أيضًا، ومن ثم توجيه الجينات إليها. ومع ذلك، في بعض الحالات، قد نقوم\nبتخزين قيم كبيرة حقًا. يمكن أن يشغل مساحة كبيرة وذاكرة كبيرة إذا اضطر الكمبيوتر إلى نسخ\nقيمة كبيرة عدة مرات. لذا فهو لا يفضل ذلك إذا كان بإمكانه تجنبه. والآن بعد أن أصبح هذا الموقع القديم\nغير قابل للوصول، فإنه يختفي. نقوم بمسحها وتحميلها في السطر التالي. على الجانب الأيمن من\nعامل الإسناد، لدينا تعبير. لذلك علينا تبسيط ذلك أولًا. نحن نصل إلى الجين المتغير لأنه على الجانب الأيمن. لذلك ننتقل إلى الذاكرة قصيرة المدى، ونحصل على هذه القيمة، ونعوض بها، ثم نجمع\nهذه الأعداد الصحيحة معًا. نجد التسمية num_mutations\nفي الذاكرة قصيرة المدى. لذلك، نقوم بتخصيص جزء جديد من الذاكرة، وتخزين القيمة 17 هناك، ثم ننقل num_mutations\nللإشارة إلى ذلك الموقع الجديد. لاحظ أن هذا لا\nيؤثر على قيمة الجين. لقد قمنا بنقل num_mutations للإشارة\nإلى موقع مختلف، لكننا لم ننقل الجين.  ولا يزال يشير إلى ذلك\nالموقع القديم بالقيمة 12. ولأن هذا الموقع لا يزال من الممكن الوصول إليه من خلال\nالجين المتغير، فإنه يظل موجودًا. هذا السطر الأخير هو مجرد وظيفة طباعة. لذا، علينا إيجاد قيمة التعبير الموجود\nداخل القوسين أولًا. ننطلق، ونحصل على القيمة\nالمخزنة في num_mutations، ونستبدلها بها، ثم نفعل الشيء نفسه\nبالنسبة للجين المتغير. نجمع هذين العددين\nمعًا لنحصل على قيمة واحدة. ثم نلقي نظرة خاطفة خارج الأقواس ونرى أننا بحاجة إلى طباعة\nهذه القيمة إلى وحدة التحكم. يبحث الكمبيوتر عن السطر التالي ويجد أنه موجود في\nنهاية البرنامج. عند انتهاء البرنامج،\nيتم مسح الذاكرة قصيرة المدى. لذلك تختفي كل هذه المتغيرات. والآن أصبح لدى الكمبيوتر مساحة\nمرة أخرى لتذكر أشياء جديدة في المرة التالية التي تقوم فيها بتشغيل البرنامج.",
    "t_italian": "- [Istruttore] Cosa succede\nquando assegni, riassegni o accedi a una variabile in un programma? Tracciamo l'esecuzione di un programma con variabili per scoprirlo. Quando il programma inizia a funzionare, il computer carica la prima istruzione nella sua memoria di lavoro. Questa istruzione è una\ndichiarazione di assegnazione. Il lato sinistro è il nome della variabile, il segno uguale è l'operatore di assegnazione e il lato destro\nè il valore da memorizzare in quella variabile. Il computer cerca eventuali espressioni da semplificare sul lato destro. Ma in questo caso la stringa\nha già un valore singolo. Quando il computer esegue\nun'istruzione di assegnazione, va nella memoria a breve termine e cerca un'etichetta\ncon quel nome di variabile. Qui cerca il nome del\ngene, ma non lo trova. Ciò significa che non conosce già un gene.  È necessario crearne uno. Quindi il computer alloca\nuna nuova porzione di memoria per questa nuova variabile. Etichetta quel pezzo di\nmemoria con il nome gene in modo da poterlo distinguere dagli\naltri pezzi di memoria. Quindi prende il valore sul lato destro\ndell'operatore di assegnazione e lo copia in quella\nposizione nella memoria a breve termine. In questo modo non lo dimenticherà quando cancellerà la sua\nmemoria di lavoro in un secondo. Ok, bene, queste istruzioni sono complete. Quindi il computer\ncancellerà la sua memoria di lavoro, dimenticherà tutte queste cose qui e passerà alla riga successiva. Tuttavia, tutto ciò che ha\nimmagazzinato nella sua memoria a breve termine rimane indietro. Qui abbiamo un'altra dichiarazione di assegnazione. Con questo però, sul lato destro\ndell'operatore di assegnazione, c'è un'espressione non semplificata. Come per gli esseri umani, è molto\npiù facile per il computer ricordare un singolo valore, come 11, rispetto alla lunga espressione\nquattro più cinque più due. Quindi il computer si assicura\ndi semplificare qualsiasi espressione sul lato destro\ndell'operatore di assegnazione fino a un singolo valore\nprima di memorizzarlo. Ora ne abbiamo 11. Quindi il computer va\nnella sua memoria a breve termine e cerca l'etichetta num_mutations. Non lo trova, quindi\ncrea una nuova variabile, alloca una nuova porzione di memoria, la tagga e copia il valore 11\ndalla memoria di lavoro. Una volta memorizzato il valore,\nl'istruzione è completa. Quindi il computer cancella la memoria di lavoro e passa alla riga successiva. Ora abbiamo un'istruzione di stampa. Il computer cerca\nprima le espressioni da semplificare all'interno delle parentesi e trova il nome della variabile gene. Ora, questo non è un incarico. Il gene del nome non si trova a\nsinistra di un segno di uguale o di un operatore di assegnazione. Ciò significa che stiamo accedendo\nal valore memorizzato nel gene, non impostandolo. Il computer va nella\nsua memoria a breve termine, cerca il gene dell'etichetta, lo trova e poi lo segue\nnella posizione della memoria a cui punta. Quindi sostituisce il valore memorizzato nell'istruzione nella memoria di lavoro. Per la seconda parte, nota che qui ci sono virgolette. Ciò significa che questo è\nsolo il gene della stringa, non il gene variabile. Quindi non andremo ad accedere a nulla nella memoria a breve termine. Stiamo semplicemente concatenando\nqueste due stringhe insieme. Una volta che siamo arrivati ​​a un singolo valore, il computer sbircia\nfuori dalle parentesi, chiede cosa dovrebbe fare\ncon quel valore, vede print e stampa BRCA2gene sulla console.  Nella riga successiva abbiamo una\ndichiarazione di assegnazione autoreferenziale. La variabile a cui stiamo assegnando\nsul lato sinistro è num_mutations, ma stiamo accedendo anche\nalla variabile num_mutations sul lato destro. Nessun problema, perché valutiamo sempre prima il lato destro. Quindi accediamo alla variabile num_mutations, cerchiamo quale valore è\nattualmente memorizzato lì e lo sostituiamo\nsolo sul lato destro. Quindi valutiamo questa espressione. Ora che abbiamo un singolo\nvalore, siamo pronti per archiviare. Il computer vede che ha già una variabile num_mutations, quindi non ne creerà una nuova. Invece, allocherà\nun nuovo pezzo di memoria, memorizzerà lì il valore 12, quindi prenderà le num_mutations esistenti e lo sposterà in modo che punti a\nquel nuovo pezzo di memoria. Quel vecchio pezzo di memoria\ncon quel vecchio valore ora è irraggiungibile. Quindi il computer entrerà e lo cancellerà ad un certo\npunto per fare più spazio. Quindi si cancella e\nriprende la riga successiva. Come pensi che funzioni questo incarico? Anche se può sembrare, questo non crea uno\nspeciale collegamento permanente tra la variabile gene e\nla variabile num_mutations dove ora avranno per sempre\nlo stesso valore. Ciò che fa è andare\nnella sua memoria a breve termine, cercare il gene variabile e poi spostarlo in modo che\npunti alla stessa posizione di num_mutations. Il computer esegue questa operazione come ottimizzazione perché avrebbe potuto allocare\nun nuovo pezzo di memoria, memorizzare lì anche il valore 12 e quindi far sì che il gene lo punti. In alcuni casi, però, potremmo\nmemorizzare valori davvero grandi. Potrebbe occupare molto spazio e memoria se il computer dovesse copiare\npiù volte un valore grande. Quindi preferirebbe di no se potesse evitarlo. E ora che questa vecchia sede\nè irraggiungibile, se ne va. Svuotiamo e carichiamo la riga successiva. Sul lato destro\ndell'operatore di assegnazione abbiamo un'espressione. Quindi dobbiamo prima semplificarlo. Stiamo accedendo al gene variabile perché è sul lato destro. Quindi passiamo alla memoria a breve termine, prendiamo quel valore, lo sostituiamo e poi sommiamo semplicemente\nquesti numeri interi. Troviamo l'etichetta num_mutations\nnella memoria a breve termine. Quindi allochiamo una nuova porzione di memoria, memorizziamo lì il valore 17 e quindi spostiamo num_mutations\nin modo che punti a quella nuova posizione. Tieni presente che ciò non\ninfluisce sul valore del gene. Abbiamo spostato num_mutations in modo che\npunti a una posizione diversa, ma non abbiamo spostato gene. Indica ancora quella vecchia\nposizione con il valore 12. Poiché quella posizione è ancora raggiungibile tramite il\ngene variabile, rimane lì. Quest'ultima riga è solo una funzione di stampa. Quindi valutiamo prima l'espressione\ntra parentesi. Usciamo, prendiamo il valore\nmemorizzato in num_mutations, lo sostituiamo e poi facciamo lo stesso\nper la variabile gene. Sommiamo questi due numeri interi\ninsieme per ottenere un unico valore. E poi sbirchiamo fuori dalle parentesi e vediamo che dobbiamo stampare\nquel valore sulla console. Il computer cerca la riga successiva e scopre che è alla\nfine del programma. Quando il programma termina,\nla memoria a breve termine viene cancellata. Quindi tutte queste variabili scompaiono. E ora il computer ha\ndi nuovo spazio per ricordare cose nuove la prossima volta che esegui un programma."
}