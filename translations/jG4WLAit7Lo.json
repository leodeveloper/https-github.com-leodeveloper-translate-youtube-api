{
    "source": "jG4WLAit7Lo",
    "youtubelink": "https://www.youtube.com/watch?v=jG4WLAit7Lo",
    "t_english": "- [Instructor] Let's design a program that imports functionality from another file. When programming teams collaborate on projects, they're often writing code across multiple files. They package their work into functions and then share them for other team members to use. This is just another form of a module. Here, my teammate wrote a module for simulating a robot's movement. We can open up the file and take a look at the code, but we may not always have the background knowledge or time to understand the details of how it works. The good news is, that doesn't matter. The only thing I need to understand is the documentation of how to use it. If you notice up here, we've been writing our code in a file called main.py. The .py is the file extension for Python code, just like jpeg is for images. Then by convention in Python, we name the file with our main logic, main. In the Khan Academy IDE, when we press the run button, it runs the code in main.py. However, we can add other files or modules to our program, then import them into main.py and use their functions there. So if we go back to our main.py file, we can import the robot module and then call one of these functions. Okay, so let's start with the first function in the robot module, which is called reverse. It takes one input or argument, the direction, and from the doc string here, I see that it rotates the robot 180 degrees and returns its new direction. It also says the direction can either be left or right. So if I go back to main.py, I can call this function using the module name, robot.reverse. It's argument can be the string left or right. So let's say left for now, and then we know it returns the new direction. So I wanna store that value in a variable. Let's run it and see what it does. Nice. So this function is returning right, because it's reversing left. And then if I swap that and I try and reverse right, it returns left. Okay, not that interesting by itself. Let's see what this draw function does. It takes three inputs, the position, direction, and grid size, and it says it displays the robot's position and direction on the grid. Note that it doesn't say that it returned something, so it might just display and not return an output value. Back to main.py, let's call robot.draw. And we wanna give it a position, I don't know, let's say three, and then let's pass in the direction we got back from reverse. And it needs a grid size, which I guess needs to be bigger than the position. So let's say 10. Okay, nice. It looks like it's printing a little representation of the robot, and we can see that the arrow is pointing left because the robot is facing left. Let's draw the robot before we reversed it too. The position and grid size will be the same, but the direction will be right, so let's actually store that in the variable up here. And actually let's store the position and grid size in a variable as well, so we're not repeating three, three, 10, 10. Note that I'm not making any changes to the robot.py file. I'm just using this module. All of my code is going in main.py. Let's try one more function, move forward. We see that it takes a position, direction, and grid size, and it returns the robot's new position. So back to main.py, we call robot.moveforward and we pass in the robot position, the direction, and the size. And since it returns the new position, we're going to store the result of that function call in the robot position variable. And so we can see what happens. Let's call draw afterward. Now that we've experimented, we've got a good sense for how the robot module works. So let's try building this into a more interesting program. Maybe we want the robot to randomly decide whether it moves forward or reverses at any point. So I could generate a random number, and depending on the result, decide which function to call. That means I'm gonna need the random module. By convention, usually we alphabetize our imports, so I'm gonna put random first. And because there are two possible outcomes, I'll generate a random number between one and two. If I get a one, I'll have the robot move forward, and if I get a two, I'll have it reverse. Now I wanna generate three random numbers, because I want the robot to take three random actions. I don't want it to perform the same one random action three times. So I need to have three separate randint function calls. In fact, I'll just copy this whole block of code, because I want all of this functionality to repeat. Now, if I run the program a few times, I can see that the robot's moving randomly. One last thing. Maybe let's have the robot start at a random position each time too. The robot's gotta start on the grid. So the start should be one, and the stop should be the grid size. And now when I run the program, the robot's starting at a random position each time. Pretty cool how quickly we were able to get a complex program like that up and running. That's the power of using modules. We can build off a functionality other people have already written to expand the possibilities of our programs. \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n",
    "t_urdu": "- [انسٹرکٹر] آئیے ایک پروگرام ڈیزائن کریں جو\nکسی دوسری فائل سے فعالیت درآمد کرے۔ جب پروگرامنگ ٹیمیں\nپروجیکٹس پر تعاون کرتی ہیں، تو وہ اکثر\nمتعدد فائلوں پر کوڈ لکھتی ہیں۔ وہ اپنے کام کو فنکشنز میں پیک کرتے ہیں اور پھر\nٹیم کے دیگر اراکین کے استعمال کے لیے ان کا اشتراک کرتے ہیں۔ یہ ماڈیول کی صرف ایک اور شکل ہے۔ یہاں، میرے ساتھی نے روبوٹ کی نقل و حرکت کی نقل کرنے کے لیے ایک ماڈیول لکھا۔ ہم فائل کو کھول سکتے ہیں اور\nکوڈ پر ایک نظر ڈال سکتے ہیں، لیکن یہ کیسے کام کرتا ہے اس کی تفصیلات کو سمجھنے کے لیے ہمارے پاس ہمیشہ\nپس منظر کا علم یا وقت نہیں ہو سکتا۔\n اچھی خبر یہ ہے کہ اس سے کوئی فرق نہیں پڑتا۔ صرف ایک چیز جس کو مجھے سمجھنے کی ضرورت ہے وہ ہے اسے استعمال کرنے کا طریقہ۔ اگر آپ نے یہاں دیکھا تو ہم اپنا کوڈ\nmain.py نامی فائل میں لکھ رہے ہیں۔ .py\nPython کوڈ کے لیے فائل ایکسٹینشن ہے، جس طرح jpeg تصاویر کے لیے ہے۔ پھر ازگر میں کنونشن کے ذریعے، ہم فائل کو اپنی بنیادی منطق کے ساتھ نام دیتے ہیں۔\n خان اکیڈمی IDE میں،\nجب ہم رن بٹن دباتے ہیں، تو یہ کوڈ کو main.py میں چلاتا ہے۔ تاہم، ہم\nاپنے پروگرام میں دیگر فائلیں یا ماڈیولز شامل کر سکتے ہیں، پھر انہیں main.py میں درآمد کر سکتے ہیں\nاور وہاں ان کے افعال استعمال کر سکتے ہیں۔ لہذا اگر ہم اپنی main.py فائل پر واپس جائیں تو ہم روبوٹ ماڈیول درآمد کر سکتے ہیں اور پھر ان میں سے کسی ایک فنکشن کو کال کر سکتے ہیں۔ ٹھیک ہے، تو آئیے روبوٹ ماڈیول کے پہلے فنکشن کے ساتھ شروع کرتے ہیں\n، جسے ریورس کہا جاتا ہے۔ یہ ایک ان پٹ یا\nدلیل لیتا ہے، سمت، اور یہاں ڈاک کے تار سے، میں دیکھ رہا ہوں کہ یہ\nروبوٹ کو 180 ڈگری گھماتا ہے اور اپنی نئی سمت لوٹاتا ہے۔ یہ بھی کہتا ہے کہ سمت\nیا تو بائیں یا دائیں ہوسکتی ہے۔ لہذا اگر میں main.py پر واپس جاتا ہوں، تو میں اس فنکشن کو ماڈیول کا نام، robot.reverse استعمال کر کے کال کر سکتا ہوں۔ اس کی دلیل\nسٹرنگ بائیں یا دائیں ہو سکتی ہے۔ تو آئیے کہتے ہیں کہ ابھی کے لیے چھوڑ دیا ہے، اور پھر ہم جانتے ہیں کہ یہ\nنئی سمت لوٹاتا ہے۔ تو میں اس قدر کو متغیر میں محفوظ کرنا چاہتا ہوں۔ آئیے اسے چلائیں اور دیکھیں کہ یہ کیا کرتا ہے۔ اچھا تو یہ فنکشن دائیں واپس آ رہا ہے، کیونکہ یہ بائیں طرف پلٹ رہا ہے۔ اور پھر اگر میں اسے تبدیل کرتا ہوں اور\nمیں کوشش کرتا ہوں اور دائیں طرف پلٹتا ہوں، تو یہ بائیں طرف لوٹ آتا ہے۔ ٹھیک ہے، بذات خود اتنا دلچسپ نہیں۔ آئیے دیکھتے ہیں کہ یہ ڈرا فنکشن کیا کرتا ہے۔ یہ تین ان پٹ لیتا ہے،\nپوزیشن، سمت، اور گرڈ کا سائز، اور یہ کہتا ہے کہ یہ گرڈ پر\nروبوٹ کی پوزیشن اور سمت دکھاتا ہے۔ نوٹ کریں کہ یہ یہ نہیں کہتا ہے\nکہ اس نے کچھ واپس کیا ہے، لہذا یہ صرف ظاہر کر سکتا ہے اور\nآؤٹ پٹ ویلیو واپس نہیں کرتا ہے۔ main.py پر واپس جائیں، آئیے robot.draw کو کال کریں۔ اور ہم اسے ایک پوزیشن دینا چاہتے ہیں\n، مجھے نہیں معلوم، آئیے تین کہتے ہیں، اور پھر\nآئیے اس سمت سے گزرتے ہیں جو ہم ریورس سے واپس آئے تھے۔ اور اسے ایک گرڈ سائز کی ضرورت ہے، جس کا مجھے اندازہ ہے کہ\nپوزیشن سے بڑا ہونا ضروری ہے۔ تو آئیے کہتے ہیں 10۔ ٹھیک ہے، اچھا۔  ایسا لگتا ہے کہ یہ روبوٹ کی\nتھوڑی سی نمائندگی پرنٹ کر رہا ہے، اور ہم دیکھ سکتے ہیں\nکہ تیر بائیں طرف اشارہ کر رہا ہے کیونکہ روبوٹ کا سامنا بائیں طرف ہے۔ آئیے روبوٹ کو کھینچتے ہیں اس سے\nپہلے کہ ہم اسے بھی الٹ دیں۔ پوزیشن اور گرڈ کا\nسائز یکساں ہوگا، لیکن سمت درست ہوگی، تو آئیے اصل میں اسے\nیہاں متغیر میں اسٹور کرتے ہیں۔ اور اصل میں\nپوزیشن اور گرڈ کے سائز کو بھی متغیر میں اسٹور کرتے ہیں، اس لیے ہم\nتین، تین، 10، 10 کو نہیں دہرا رہے ہیں۔ نوٹ کریں کہ میں\nrobot.py فائل میں کوئی تبدیلی نہیں کر رہا ہوں۔ میں صرف یہ ماڈیول استعمال کر رہا ہوں۔ میرا تمام کوڈ main.py میں جا رہا ہے۔ آئیے ایک اور فنکشن آزمائیں، آگے بڑھیں۔ ہم دیکھتے ہیں کہ یہ ایک پوزیشن،\nسمت، اور گرڈ کا سائز لیتا ہے، اور یہ روبوٹ کی نئی پوزیشن کو لوٹاتا ہے۔ تو واپس main.py پر، ہم\nrobot.moveforward کہتے ہیں اور ہم روبوٹ کی پوزیشن، سمت اور سائز میں گزرتے ہیں۔ اور چونکہ یہ نئی پوزیشن واپس کرتا ہے، ہم\nاس فنکشن کال کے نتیجے کو روبوٹ پوزیشن متغیر میں محفوظ کرنے جا رہے ہیں۔ اور اس طرح ہم دیکھ سکتے ہیں کہ کیا ہوتا ہے۔ آئیے بعد میں ڈرا کو کال کریں۔ اب جب کہ ہم نے تجربہ کیا ہے، ہمیں روبوٹ ماڈیول کے کام کرنے کے بارے میں اچھی طرح سمجھ آئی ہے۔\n تو آئیے اسے\nمزید دلچسپ پروگرام بنانے کی کوشش کریں۔ شاید ہم چاہتے ہیں کہ روبوٹ تصادفی طور پر فیصلہ کرے کہ آیا یہ\nکسی بھی وقت آگے بڑھتا ہے یا الٹ جاتا ہے۔ لہذا میں ایک بے ترتیب نمبر بنا سکتا ہوں، اور نتیجہ پر منحصر ہے،\nفیصلہ کرتا ہوں کہ کس فنکشن کو کال کرنا ہے۔ اس کا مطلب ہے کہ مجھے\nبے ترتیب ماڈیول کی ضرورت ہوگی۔ کنونشن کے مطابق، عام طور پر ہم\nاپنی درآمدات کو حروف تہجی میں ترتیب دیتے ہیں، لہذا میں بے ترتیب کو پہلے رکھوں گا۔ اور چونکہ\nدو ممکنہ نتائج ہیں، میں\nایک اور دو کے درمیان ایک بے ترتیب نمبر بناؤں گا۔ اگر مجھے ایک مل جاتا ہے، تو میں\nروبوٹ کو آگے بڑھاؤں گا، اور اگر مجھے دو ملے، تو میں اسے ریورس کر دوں گا۔ اب میں تین بے ترتیب نمبر بنانا چاہتا ہوں، کیونکہ میں چاہتا ہوں کہ روبوٹ\nتین بے ترتیب حرکتیں کرے۔ میں نہیں چاہتا کہ یہ ایک ہی \nبے ترتیب کارروائی تین بار کرے۔ لہذا مجھے تین\nالگ الگ رینڈنٹ فنکشن کالز کرنے کی ضرورت ہے۔ اصل میں، میں صرف\nکوڈ کے اس پورے بلاک کو کاپی کروں گا، کیونکہ میں چاہتا ہوں کہ یہ تمام\nفعالیت دہرائی جائے۔ اب، اگر میں پروگرام کو چند بار چلاتا ہوں، تو میں دیکھ سکتا ہوں کہ\nروبوٹ بے ترتیب حرکت کر رہا ہے۔ ایک اخری چیز۔ شاید آئیے ہر بار بھی روبوٹ کو\nبے ترتیب پوزیشن سے شروع کریں۔ روبوٹ کو گرڈ پر شروع کرنا ہوگا۔ لہذا آغاز ایک ہونا چاہئے، اور سٹاپ گرڈ سائز ہونا چاہئے. اور اب جب میں پروگرام چلاتا ہوں تو روبوٹ\nہر بار بے ترتیب پوزیشن سے شروع ہوتا ہے۔ بہت اچھا ہے کہ ہم کتنی جلدی اس طرح کے پیچیدہ پروگرام کو\nچلانے اور چلانے میں کامیاب ہو گئے۔ یہ ماڈیول استعمال کرنے کی طاقت ہے۔ ہم ایک ایسی فعالیت تیار کر سکتے ہیں جو\nدوسرے لوگوں نے پہلے ہی\n ہمارے پروگراموں کے امکانات کو بڑھانے کے لیے لکھا ہے۔",
    "t_spanish": "- [Instructor] Diseñemos un programa que importe funcionalidad\nde otro archivo. Cuando los equipos de programación\ncolaboran en proyectos, a menudo escriben código\nen varios archivos. Empaquetan su trabajo en funciones y luego las comparten para que las\nutilicen otros miembros del equipo. Esta es solo otra forma de módulo. Aquí, mi compañero de equipo escribió un módulo para simular el movimiento de un robot. Podemos abrir el archivo y\nechar un vistazo al código, pero es posible que no siempre tengamos\nlos conocimientos previos o el tiempo para comprender los\ndetalles de cómo funciona. La buena noticia es que eso no importa. Lo único que necesito entender es la documentación sobre cómo usarlo. Si te fijas aquí, hemos estado escribiendo nuestro código\nen un archivo llamado main.py. El .py es la\nextensión de archivo para el código Python, al igual que jpeg lo es para las imágenes. Luego, por convención en Python, nombramos el archivo con\nnuestra lógica principal, main. En el IDE de Khan Academy,\ncuando presionamos el botón ejecutar, se ejecuta el código en main.py. Sin embargo, podemos agregar otros archivos\no módulos a nuestro programa, luego importarlos a main.py\ny usar sus funciones allí. Entonces, si volvemos a nuestro archivo main.py, podemos importar el módulo del robot y luego llamar a una de estas funciones. Bien, comencemos con la primera función\nen el módulo del robot, que se llama inversa. Toma una entrada o\nargumento, la dirección, y de la cadena de documentación aquí, veo que gira\nel robot 180 grados y devuelve su nueva dirección. También dice que la dirección\npuede ser izquierda o derecha. Entonces, si vuelvo a main.py, puedo llamar a esta función usando el nombre del módulo, robot.reverse. Su argumento puede ser la\ncadena izquierda o derecha. Entonces digamos que se fue por ahora y luego sabremos que\nregresa en la nueva dirección. Entonces quiero almacenar ese valor en una variable. Ejecutémoslo y veamos qué hace. Lindo. Entonces esta función regresa hacia la derecha, porque invierte hacia la izquierda. Y luego, si cambio eso e\nintento invertir la dirección hacia la derecha, regresa hacia la izquierda. Bien, no es tan interesante por sí solo. Veamos qué hace esta función de dibujo. Toma tres entradas,\nla posición, la dirección y el tamaño de la cuadrícula, y dice que\nmuestra la posición y dirección del robot en la cuadrícula. Tenga en cuenta que no dice\nque devolvió algo, por lo que es posible que simplemente muestre y\nno devuelva un valor de salida. Volviendo a main.py, llamemos a robot.draw. Y queremos darle una\nposición, no sé, digamos tres, y luego\npasemos en la dirección en la que regresamos desde atrás. Y necesita un tamaño de cuadrícula, que supongo que debe ser\nmayor que la posición. Entonces digamos 10. Está bien, bien. Parece que está imprimiendo\nuna pequeña representación del robot y podemos ver\nque la flecha apunta hacia la izquierda porque el robot está mirando hacia la izquierda. Dibujemos el robot\nantes de invertirlo también. La posición y el\ntamaño de la cuadrícula serán los mismos, pero la dirección será la correcta, así que almacenémoslo\nen la variable aquí arriba. Y, de hecho, almacenemos también\nla posición y el tamaño de la cuadrícula en una variable, para no repetir\ntres, tres, 10, 10. Tenga en cuenta que no haré ningún\ncambio en el archivo robot.py. Sólo estoy usando este módulo. Todo mi código va a main.py. Probemos una función más, sigamos adelante. Vemos que toma una posición,\ndirección y tamaño de cuadrícula, y devuelve la nueva posición del robot. Entonces, volviendo a main.py,\nllamamos robot.moveforward y pasamos la posición, la dirección y el tamaño del robot. Y como devuelve la nueva posición, almacenaremos el\nresultado de esa llamada a la función en la variable de posición del robot. Y así podemos ver qué pasa. Llamemos al empate después. Ahora que hemos experimentado, tenemos una buena idea de\ncómo funciona el módulo del robot. Así que intentemos convertir esto en\nun programa más interesante. Tal vez queramos que el robot decida aleatoriamente si avanza\no retrocede en algún momento. Entonces podría generar un número aleatorio y, según el resultado,\ndecidir a qué función llamar. Eso significa que\nnecesitaré el módulo aleatorio. Por convención, normalmente ordenamos\nalfabéticamente nuestras importaciones, así que pondré primero el azar. Y como hay\ndos resultados posibles, generaré un\nnúmero aleatorio entre uno y dos. Si obtengo un uno, haré que\nel robot avance, y si obtengo un dos, lo haré al revés. Ahora quiero generar tres números aleatorios, porque quiero que el robot\nrealice tres acciones aleatorias. No quiero que realice la misma\nacción aleatoria tres veces. Entonces necesito tener tres\nllamadas a funciones randint separadas. De hecho, simplemente copiaré\ntodo este bloque de código porque quiero que se repita toda esta\nfuncionalidad. Ahora, si ejecuto el programa varias veces, puedo ver que el\nrobot se mueve aleatoriamente. Una última cosa. Quizás también hagamos que el robot\ncomience en una posición aleatoria cada vez. El robot debe empezar en la red. Entonces el inicio debe ser uno y la parada debe ser el tamaño de la cuadrícula. Y ahora, cuando ejecuto el programa, el robot comienza en una\nposición aleatoria cada vez.  Es genial lo rápido que pudimos poner en funcionamiento un programa complejo\ncomo ese. Ese es el poder de usar módulos. Podemos aprovechar una\nfuncionalidad que otras personas ya han escrito para\nampliar las posibilidades de nuestros programas.",
    "t_arabic": "- [المدرس] لنصمم برنامجًا يستورد الوظائف\nمن ملف آخر. عندما تتعاون فرق البرمجة\nفي المشاريع، فإنها غالبًا ما تكتب التعليمات البرمجية\nعبر ملفات متعددة. يقومون بتجميع عملهم في وظائف ثم يشاركونها\nليستخدمها أعضاء الفريق الآخرون. هذا مجرد شكل آخر من أشكال الوحدة. هنا، كتب زميلي في الفريق وحدة لمحاكاة حركة الروبوت. يمكننا فتح الملف\nوإلقاء نظرة على الكود، ولكن قد لا يكون لدينا دائمًا\nالمعرفة الأساسية أو الوقت لفهم\nتفاصيل كيفية عمله. والخبر السار هو أن هذا لا يهم. الشيء الوحيد الذي أحتاج إلى فهمه هو توثيق كيفية استخدامه. إذا لاحظت هنا، أننا قمنا بكتابة الكود الخاص بنا\nفي ملف يسمى main.py. إن .py هو\nامتداد الملف لرمز Python، تمامًا كما هو الحال مع jpeg للصور. ثم حسب العرف في بايثون، نقوم بتسمية الملف\nبالمنطق الرئيسي لدينا، main. في بيئة التطوير المتكاملة لأكاديمية خان،\nعندما نضغط على زر التشغيل، يتم تشغيل التعليمات البرمجية في main.py. ومع ذلك، يمكننا إضافة ملفات\nأو وحدات أخرى إلى برنامجنا، ثم استيرادها إلى main.py\nواستخدام وظائفها هناك. لذا، إذا عدنا إلى ملف main.py، فيمكننا استيراد وحدة الروبوت ثم استدعاء إحدى هذه الوظائف. حسنًا، لنبدأ بالوظيفة الأولى\nفي وحدة الروبوت، والتي تسمى العكس. يتطلب الأمر إدخالاً أو\nوسيطة واحدة، الاتجاه، ومن سلسلة المستند هنا، أرى أنه يدور\nالروبوت 180 درجة ويعيد اتجاهه الجديد. وتقول أيضًا أن الاتجاه\nيمكن أن يكون يسارًا أو يمينًا. لذلك، إذا عدت إلى main.py، فيمكنني استدعاء هذه الوظيفة باستخدام اسم الوحدة، robot.reverse. يمكن أن تكون الوسيطة عبارة عن\nسلسلة يسارًا أو يمينًا. فلنفترض أننا غادرنا الآن، وبعد ذلك نعلم أنه\nيعيد الاتجاه الجديد. لذلك أريد تخزين هذه القيمة في متغير. دعونا تشغيله ونرى ماذا يفعل. لطيف - جيد. إذن هذه الدالة تعود لليمين، لأنها ترجع لليسار. وبعد ذلك، إذا قمت بتبديل ذلك\nوحاولت الرجوع إلى اليمين، فإنه يعود إلى اليسار. حسنًا، ليس هذا مثيرًا للاهتمام في حد ذاته. دعونا نرى ما تفعله وظيفة السحب هذه. يأخذ ثلاثة مدخلات،\nالموقع، الاتجاه، وحجم الشبكة، ويقول إنه\nيعرض موضع الروبوت واتجاهه على الشبكة. لاحظ أنه لا يشير\nإلى أنه أعاد شيئًا ما، لذلك قد يعرض فقط\nقيمة الإخراج ولا يُرجعها. نعود إلى main.py، لنستدعي robot.draw. ونريد أن نعطيها\nموضعًا، لا أعرف، دعنا نقول ثلاثة، ثم\nدعونا نمر في الاتجاه الذي عدنا فيه من الخلف. ويحتاج إلى حجم الشبكة، والذي أعتقد أنه يجب أن يكون\nأكبر من الموضع. فلنقل 10. حسنًا، جميل. يبدو أنها تطبع\nتمثيلاً صغيرًا للروبوت، ويمكننا أن نرى\nأن السهم يشير إلى اليسار لأن الروبوت يتجه نحو اليسار. لنرسم الروبوت\nقبل أن نعكسه أيضًا.  سيكون الموضع وحجم الشبكة\nمتماثلين، لكن الاتجاه سيكون صحيحًا، لذلك دعونا نخزن ذلك\nفي المتغير هنا. وفي الواقع، دعونا نخزن\nالموضع وحجم الشبكة في متغير أيضًا، حتى لا نكرر\nثلاثة، ثلاثة، 10، 10. لاحظ أنني لا أقوم بإجراء أي\nتغييرات على ملف robot.py. أنا فقط أستخدم هذه الوحدة. كل الكود الخاص بي موجود في main.py. دعونا نجرب وظيفة أخرى، والمضي قدما. نرى أنه يأخذ موضعًا\nواتجاهًا وحجم الشبكة، ويعيد الموقع الجديد للروبوت. لذا، وبالعودة إلى main.py، فإننا\nنسمي robot.moveforward ونمرر موضع الروبوت، والاتجاه، والحجم. وبما أنه يُرجع الموضع الجديد، فسنقوم بتخزين\nنتيجة استدعاء هذه الوظيفة في متغير موضع الروبوت.  وهكذا يمكننا أن نرى ما سيحدث. دعونا نسمي الرسم بعد ذلك. الآن بعد أن انتهينا من التجربة، أصبح لدينا فكرة جيدة عن\nكيفية عمل وحدة الروبوت. لذلك دعونا نحاول بناء هذا في\nبرنامج أكثر إثارة للاهتمام. ربما نريد من الروبوت أن يقرر بشكل عشوائي ما إذا كان يتحرك للأمام\nأو للخلف في أي لحظة. لذا يمكنني إنشاء رقم عشوائي، وبناءً على النتيجة،\nتحديد الوظيفة التي يجب الاتصال بها. هذا يعني أنني\nسأحتاج إلى الوحدة العشوائية. وفقًا للاتفاقية، عادةً ما نقوم\nبترتيب وارداتنا أبجديًا، لذا سأضع العشوائية أولاً. ولأن هناك\nنتيجتين محتملتين، سأقوم بتوليد\nرقم عشوائي بين واحد واثنين. إذا حصلت على واحد، سأجعل\nالروبوت يتحرك للأمام، وإذا حصلت على اثنين، سأجعله يتحرك للخلف. الآن أريد توليد ثلاثة أرقام عشوائية، لأنني أريد أن\nيقوم الروبوت بثلاثة إجراءات عشوائية. لا أريد أن يقوم بنفس\nالإجراء العشوائي ثلاث مرات. لذلك أحتاج إلى ثلاث\nاستدعاءات دالة randint منفصلة. في الواقع، سأقوم فقط بنسخ\nهذه المجموعة الكاملة من التعليمات البرمجية، لأنني أريد تكرار كل هذه\nالوظائف. الآن، إذا قمت بتشغيل البرنامج عدة مرات، أستطيع أن أرى أن\nالروبوت يتحرك بشكل عشوائي. شيء أخير. ربما لنجعل الروبوت\nيبدأ في موضع عشوائي في كل مرة أيضًا. يجب أن يبدأ الروبوت على الشبكة. لذا يجب أن تكون البداية واحدة، ويجب أن تكون نقطة التوقف بحجم الشبكة. والآن عندما أقوم بتشغيل البرنامج، يبدأ الروبوت في\nموضع عشوائي في كل مرة.  من الرائع جدًا مدى السرعة التي تمكنا بها من تشغيل برنامج معقد\nكهذا وتشغيله. هذه هي قوة استخدام الوحدات. يمكننا بناء\nوظيفة كتبها أشخاص آخرون بالفعل\nلتوسيع إمكانيات برامجنا.",
    "t_italian": "- [Istruttore] Progettiamo un programma che importi funzionalità\nda un altro file. Quando i team di programmazione\ncollaborano ai progetti, spesso scrivono codice\nsu più file. Comprimono il loro lavoro in funzioni e poi lo condividono affinché\naltri membri del team possano utilizzarlo. Questa è solo un'altra forma di modulo. Qui, il mio compagno di squadra ha scritto un modulo per simulare il movimento di un robot. Possiamo aprire il file e\ndare un'occhiata al codice, ma potremmo non avere sempre\nle conoscenze di base o il tempo per comprendere i\ndettagli di come funziona. La buona notizia è che non importa. L'unica cosa che devo capire è la documentazione su come usarlo. Se noti qui, abbiamo scritto il nostro codice\nin un file chiamato main.py. .py è l'\nestensione del file per il codice Python, proprio come jpeg lo è per le immagini. Quindi, per convenzione in Python, chiamiamo il file con la\nnostra logica principale, main. Nell'IDE Khan Academy,\nquando premiamo il pulsante Esegui, viene eseguito il codice in main.py. Possiamo però aggiungere altri file\no moduli al nostro programma, quindi importarli in main.py\ne utilizzarne le funzioni. Quindi, se torniamo al nostro file main.py, possiamo importare il modulo robot e quindi chiamare una di queste funzioni. Ok, allora cominciamo con la prima funzione\nnel modulo robot, che si chiama inversione. Richiede un input o\nargomento, la direzione, e dalla stringa doc qui, vedo che ruota\nil robot di 180 gradi e restituisce la sua nuova direzione. Dice anche che la direzione\npuò essere sinistra o destra. Quindi, se torno a main.py, posso chiamare questa funzione utilizzando il nome del modulo, robot.reverse.  L' argomento può essere la\nstringa sinistra o destra. Quindi diciamo a sinistra per ora, e poi sappiamo che\nritorna la nuova direzione. Quindi voglio memorizzare quel valore in una variabile. Eseguiamolo e vediamo cosa fa.  Carino . Quindi questa funzione torna a destra perché gira a sinistra. E poi se lo scambio e\nprovo a invertire la direzione a destra, ritorna a sinistra. Ok, non è così interessante di per sé. Vediamo cosa fa questa funzione di disegno. Richiede tre input,\nposizione, direzione e dimensione della griglia, e dice di\nvisualizzare la posizione e la direzione del robot sulla griglia. Tieni presente che non dice\nche ha restituito qualcosa, quindi potrebbe semplicemente visualizzare e\nnon restituire un valore di output. Torniamo a main.py, chiamiamo robot.draw. E vogliamo dargli una\nposizione, non so, diciamo tre, e poi\npassiamo nella direzione in cui siamo tornati dalla retromarcia. E ha bisogno di una dimensione della griglia, che immagino debba essere più\ngrande della posizione. Quindi diciamo 10. Okay, carino. Sembra che stia stampando\nuna piccola rappresentazione del robot e possiamo vedere\nche la freccia punta a sinistra perché il robot è rivolto a sinistra. Disegniamo il robot\nprima di invertirlo. La posizione e la dimensione della griglia\nsaranno le stesse, ma la direzione sarà giusta, quindi memorizziamola\nnella variabile qui sopra. E in realtà memorizziamo anche\nla posizione e la dimensione della griglia in una variabile, quindi non stiamo ripetendo\ntre, tre, 10, 10. Nota che non sto apportando alcuna\nmodifica al file robot.py. Sto solo usando questo modulo. Tutto il mio codice va in main.py. Proviamo un'altra funzione, andiamo avanti. Vediamo che prende una posizione, una\ndirezione e una dimensione della griglia e restituisce la nuova posizione del robot. Quindi torniamo a main.py,\nchiamiamo robot.moveforward e passiamo la posizione del robot, la direzione e la dimensione. E poiché restituisce la nuova posizione, memorizzeremo il\nrisultato di quella chiamata di funzione nella variabile di posizione del robot. E così possiamo vedere cosa succede. Chiameremo il sorteggio dopo. Ora che abbiamo sperimentato, abbiamo una buona idea di\ncome funziona il modulo robot. Quindi proviamo a trasformarlo in\nun programma più interessante. Forse vogliamo che il robot decida in modo casuale se avanzare\no invertire la rotta in qualsiasi momento. Quindi potrei generare un numero casuale e, in base al risultato,\ndecidere quale funzione chiamare. Ciò significa che mi\nservirà il modulo casuale. Per convenzione, di solito mettiamo\nin ordine alfabetico le nostre importazioni, quindi metterò prima il casuale. E poiché ci sono\ndue possibili risultati, genererò un\nnumero casuale compreso tra uno e due. Se ottengo uno, farò\navanzare il robot, e se ottengo due, lo farò invertire. Ora voglio generare tre numeri casuali, perché voglio che il robot\nesegua tre azioni casuali. Non voglio che esegua la stessa\nazione casuale tre volte. Quindi ho bisogno di tre\nchiamate di funzione randint separate. In effetti, copierò semplicemente\nl'intero blocco di codice, perché voglio che tutte queste\nfunzionalità si ripetano. Ora, se eseguo il programma alcune volte, posso vedere che il\nrobot si muove in modo casuale. Un'ultima cosa. Magari facciamo partire anche il robot ogni volta\nda una posizione casuale . Il robot deve partire sulla griglia. Quindi l'inizio dovrebbe essere uno e la fine dovrebbe essere la dimensione della griglia. E ora quando eseguo il programma, il robot parte\nogni volta da una posizione casuale.  È davvero interessante la rapidità con cui siamo riusciti a mettere in funzione un programma complesso\ncome quello. Questo è il potere dell'utilizzo dei moduli. Possiamo sviluppare\nfunzionalità che altre persone hanno già scritto per\nespandere le possibilità dei nostri programmi."
}