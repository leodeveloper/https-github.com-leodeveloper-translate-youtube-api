{
    "source": "KsiWTrZQFXg",
    "youtubelink": "https://www.youtube.com/watch?v=KsiWTrZQFXg",
    "t_english": "- [Instructor] What if you want your program to repeat a block of code? You could copy and paste those lines of code. But what if you wanted to repeat a hundred times or a thousand times, or maybe you don't even know upfront how many times you needed to repeat. To solve this, we can use a while loop. A while loop tells the computer to keep executing a block of code as long as a certain condition evaluates to true. We've used Boolean conditions before with conditionals. In a basic if statement, the computer evaluates the condition once, and if it evaluates to true, it executes any code indented inside of it, and then it moves on to execute the rest of the program. With a while loop, the computer evaluates the condition and if it evaluates to true, the computer executes any lines of code indented inside of it. However, now that we're at what we call the bottom of the loop, the computer will go back to the condition and check it again. If it's still evaluates to true, the computer will execute the lines of code indented inside the loop again and so on and so on and so on, until when the computer checks the condition, it finds that it evaluates to false. Only then does the loop terminate for good and the computer moves on to execute the rest of the program. In Python the syntax for a while loop is just the keyword while followed by a Boolean condition and then a colon. Any lens of code we want to repeat inside the while loop, we indent one tab over. We call this the loop body. Because we want the loop to terminate eventually, we don't want it to repeat forever, we'll want the loop condition to evaluate to false at some point. Typically, that means our loop condition will include a loop variable, which is a variable that gets updated inside the loop body. On each trip through the loop, what we call an iteration, the value of the variable will change, which means that when we go to check the loop condition again, there's a chance it might evaluate to false this time. Let's take a look at our coin flip experiment. Here we generate a random number between one and two, and if that number is one, we print heads, and if it's two, we print tails. Now what if I want to repeat that experiment to see how often I get tails? I can wrap my experiment in a while loop. So the first thing I'm gonna wanna do is figure out what my loop condition should be. Let's say I wanna repeat this experiment five times. So my condition might be something like num_flips less than five. Then any lines of code I want to repeat need to be indented one level in. Well, on each iteration I wanna generate a new random number to simulate a coin flip. And then I still want to check if it's one or two and print heads or tails. So I'm going to tab all of these lines of code over. If I run this program now I get a name error. Because the variable num_flips hasn't been defined. We never assigned it a value. With while loops, we always wanna make sure we initialize our loop variable before the loop. Here we probably want to initialize num_flips to zero because we haven't done any coin flips yet at this point, we have zero flips. Now that our name error is fixed, it looks like the computer's printing heads, tails, tails, heads, heads forever. This is what we call an infinite loop. Our loop never terminates because our loop condition never evaluates to false. If you ever see your program hanging like this, you wanna press the stop button to recover and terminate the program. Otherwise, it'll keep running forever until the computer runs outta memory. So why is it infinite looping? Well, we never update the value of the loop variable inside the loop body. So num_flips always contains the value zero, which means every time we go back to the top and check the loop condition we're checking is zero less than five, which will always be true. What we actually want is to increment num_flips by one every time we flip a coin. So we're essentially counting up the number of flips. So before the first iteration, num_flips will be zero. Then before the second iteration will be one, two, three, four until the check becomes five, less than five, which evaluates to false and the loop terminates. By convention, we update the loop variable at the very bottom of the loop so that it changes right before we go back to check the loop condition. Then we can increase our number of repetitions just by modifying this stop value in the loop condition, say to a hundred or a thousand. So when you're writing while loops, make sure you check for all three key components that you initialize your loop variable before the loop, that you check your loop variable in the loop condition, and that you update the loop variable at the bottom of the loop body.\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n",
    "t_urdu": "- [انسٹرکٹر] اگر\nآپ چاہتے ہیں کہ آپ کا پروگرام کوڈ کے ایک بلاک کو دہرائے؟ آپ کوڈ کی ان لائنوں کو کاپی اور پیسٹ کرسکتے ہیں۔\n لیکن کیا ہوگا اگر آپ\nسو بار یا ہزار بار دہرانا چاہتے ہیں، یا ہوسکتا ہے کہ آپ کو یہ بھی معلوم نہ ہو کہ آپ کو کتنی بار دہرانے کی ضرورت ہے۔ اس کو حل کرنے کے لیے، ہم ایک while loop استعمال کر سکتے ہیں۔ A while loop کمپیوٹر سے کہتا ہے کہ کوڈ کے\nبلاک کو اس وقت تک عمل میں لاتا رہے جب تک کہ کوئی خاص\nحالت درست ہونے کا اندازہ نہ ہو۔ ہم نے کنڈیشنلز کے ساتھ پہلے بولین حالات استعمال کیے ہیں۔ ایک بنیادی if بیان میں، کمپیوٹر ایک بار حالت کا جائزہ لیتا ہے، اور اگر اس کا درست اندازہ ہوتا ہے، تو\nیہ اس کے اندر موجود کسی بھی کوڈ پر عمل درآمد کرتا ہے، اور پھر یہ باقی پروگرام کو انجام دینے کے لیے آگے بڑھتا ہے۔ تھوڑی دیر کے لوپ کے ساتھ، کمپیوٹر\nکنڈیشن کا جائزہ لیتا ہے اور اگر اس کا درست اندازہ ہوتا ہے، تو\nکمپیوٹر اس کے اندر موجود کوڈ کی کسی بھی لائن کو انجام دیتا ہے۔ تاہم، اب جب کہ ہم اس پر ہیں جسے\nہم لوپ کے نیچے کہتے ہیں، کمپیوٹر\nواپس کنڈیشن پر جائے گا اور اسے دوبارہ چیک کرے گا۔ اگر یہ اب بھی درست پر تشخیص کرتا ہے، تو کمپیوٹر لوپ کے اندر\nانڈینٹ کردہ کوڈ کی لائنوں کو دوبارہ انجام دے گا اور اسی طرح اور اسی طرح اور اسی طرح، جب تک کہ\nکمپیوٹر کنڈیشن کو چیک کرتا ہے، اسے پتہ چلتا ہے کہ اس کا اندازہ غلط ہے۔ تب ہی لوپ اچھے کے لیے ختم ہو جاتا ہے اور کمپیوٹر باقی پروگرام کو انجام دینے کے لیے آگے بڑھتا ہے۔ Python میں نحو برائے a while loop صرف\nکلیدی لفظ ہے جبکہ اس کے بعد بولین کنڈیشن اور پھر بڑی آنت ہوتی ہے۔ کوڈ کے کسی بھی لینس کو ہم\nجب لوپ کے اندر دہرانا چاہتے ہیں، ہم ایک ٹیب کو انڈینٹ کرتے ہیں۔ ہم اسے لوپ باڈی کہتے ہیں۔ کیونکہ ہم چاہتے ہیں کہ لوپ\nآخرکار ختم ہو جائے، ہم نہیں چاہتے کہ اسے ہمیشہ کے لیے دہرایا جائے، ہم چاہیں گے کہ لوپ کی حالت کا اندازہ کسی وقت غلط ہو جائے۔ عام طور پر، اس کا مطلب ہے کہ ہماری لوپ\nکنڈیشن میں ایک لوپ ویری ایبل شامل ہوگا، جو کہ ایک\nمتغیر ہے جو لوپ باڈی کے اندر اپ ڈیٹ ہوجاتا ہے۔ لوپ کے ذریعے ہر ٹرپ پر، جسے ہم تکرار کہتے ہیں، متغیر کی قدر\nبدل جائے گی، جس کا مطلب ہے کہ جب ہم\nلوپ کی حالت کو دوبارہ چیک کرنے جائیں گے، تو \nاس بار اس کا اندازہ غلط ہونے کا امکان ہے۔ آئیے اپنے سکے پلٹنے کے تجربے پر ایک نظر ڈالیں۔\n یہاں ہم\nایک اور دو کے درمیان ایک بے ترتیب نمبر تیار کرتے ہیں، اور اگر وہ نمبر ایک ہے، تو ہم ہیڈ پرنٹ کرتے ہیں، اور اگر یہ دو ہے، تو ہم دم پرنٹ کرتے ہیں۔ اب کیا ہوگا اگر میں اس تجربے کو دہرانا چاہوں کہ\n مجھے کتنی بار دم ملے؟ میں اپنے تجربے کو تھوڑی دیر کے لوپ میں لپیٹ سکتا ہوں۔ تو پہلی چیز جو میں کرنا\nچاہتا ہوں یہ معلوم کرنا ہے کہ میری لوپ کی حالت کیا ہونی چاہیے۔ چلیں کہ میں\nاس تجربے کو پانچ بار دہرانا چاہتا ہوں۔ تو میری حالت\nکچھ ایسی ہو سکتی ہے جیسے num_flips پانچ سے کم۔ پھر کوڈ کی کوئی بھی لائن جس کو\nمیں دہرانا چاہتا ہوں اسے ایک لیول میں انڈینٹ کرنے کی ضرورت ہے۔ ٹھیک ہے، ہر تکرار پر میں\nایک نیا رینڈم نمبر بنانا چاہتا ہوں تاکہ سکے کو پلٹایا جا سکے۔ اور پھر میں اب بھی یہ دیکھنا چاہتا ہوں کہ آیا یہ ایک ہے یا دو اور پرنٹ ہیڈز یا ٹیل۔ تو میں کوڈ کی ان تمام لائنوں کو ٹیب کرنے جا رہا ہوں۔\n اگر میں اب یہ پروگرام چلاتا ہوں تو\nمجھے نام کی خرابی ملتی ہے۔ کیونکہ متغیر\nnum_flips کی وضاحت نہیں کی گئی ہے۔ ہم نے اسے کبھی بھی کوئی قدر تفویض نہیں کی۔ جبکہ لوپس کے ساتھ، ہم\nہمیشہ یہ یقینی بنانا چاہتے ہیں کہ ہم لوپ سے پہلے اپنے لوپ متغیر کو شروع کریں۔\n یہاں ہم شاید num_flips کو صفر پر شروع کرنا چاہتے ہیں کیونکہ ہم نے ابھی تک کوئی سکہ پلٹایا نہیں ہے، ہمارے پاس صفر فلپس ہیں۔ اب جب کہ ہمارے نام کی غلطی ٹھیک ہو گئی ہے، ایسا لگتا ہے کہ کمپیوٹر کے\nپرنٹنگ ہیڈز، ٹیل، ٹیل، ہیڈز، ہیڈز ہمیشہ کے لیے ہیں۔ اسے ہم لامحدود لوپ کہتے ہیں۔ ہمارا لوپ کبھی ختم نہیں ہوتا ہے کیونکہ ہماری لوپ کی حالت\nکبھی بھی غلط کی تشخیص نہیں کرتی ہے۔ اگر آپ کبھی اپنے\nپروگرام کو اس طرح لٹکتے ہوئے دیکھتے ہیں، تو آپ پروگرام کو بحال کرنے اور ختم کرنے کے لیے اسٹاپ بٹن کو دبانا چاہتے ہیں۔ بصورت دیگر، یہ ہمیشہ کے لیے چلتا رہے گا جب تک کہ کمپیوٹر کی میموری ختم نہ ہو جائے۔ تو یہ لامحدود لوپنگ کیوں ہے؟ ٹھیک ہے، ہم کبھی بھی لوپ باڈی کے اندر\nلوپ متغیر کی قدر کو اپ ڈیٹ نہیں کرتے ہیں۔ لہذا num_flips میں ہمیشہ\nصفر کی قدر ہوتی ہے، جس کا مطلب ہے کہ جب بھی\nہم سب سے اوپر جاتے ہیں اور لوپ کی حالت کو چیک کرتے ہیں جو\nہم چیک کر رہے ہیں وہ صفر پانچ سے کم ہے، جو ہمیشہ درست رہے گا۔ ہم اصل میں یہ چاہتے ہیں کہ\n جب بھی ہم ایک سکے کو پلٹائیں تو num_flips کو ایک سے بڑھانا ہے۔ لہذا ہم بنیادی طور پر\nفلپس کی تعداد گن رہے ہیں۔ تو پہلی تکرار سے پہلے،\nnum_flips صفر ہو جائے گا۔ پھر دوسری تکرار سے پہلے\nایک، دو، تین، چار ہو جائے گا جب تک کہ چیک\nپانچ، پانچ سے کم نہ ہو جائے، جس کا اندازہ غلط ہو جائے اور لوپ ختم ہو جائے۔ کنونشن کے مطابق، ہم لوپ کے بالکل نیچے لوپ متغیر کو اپ ڈیٹ کرتے ہیں تاکہ لوپ کی حالت کو چیک کرنے کے لیے واپس جانے سے پہلے ہی یہ بدل جائے۔\n پھر ہم\nصرف اس سٹاپ ویلیو کو\nلوپ کنڈیشن میں تبدیل کر کے اپنی تکرار کی تعداد بڑھا سکتے ہیں، سو یا ہزار تک۔ لہذا جب آپ لوپ کے دوران لکھ رہے ہیں، تو\nیقینی بنائیں کہ آپ ان تینوں کلیدی اجزاء کو چیک کرتے ہیں جو آپ لوپ سے پہلے اپنے لوپ متغیر کو شروع کرتے ہیں، کہ آپ\nاپنے لوپ متغیر کو لوپ کی حالت میں چیک کرتے ہیں، اور\nیہ کہ آپ لوپ متغیر کو اپ ڈیٹ کرتے ہیں لوپ جسم.",
    "t_spanish": "- [Instructor] ¿Qué pasa si\nquieres que tu programa repita un bloque de código? Podrías copiar y pegar\nesas líneas de código. Pero, ¿qué pasaría si quisieras\nrepetir cien o mil veces, o tal vez ni siquiera supieras de antemano cuántas veces necesitas repetir? Para solucionar esto, podemos usar un bucle while. Un bucle while le dice a la computadora\nque siga ejecutando un bloque de código mientras una determinada\ncondición se evalúe como verdadera. Hemos usado condiciones booleanas antes con condicionales. En una declaración if básica, la computadora evalúa la condición una vez, y si se evalúa como verdadera,\nejecuta cualquier código sangrado dentro de ella y luego continúa ejecutando el resto del programa. Con un bucle while, la computadora\nevalúa la condición y, si es verdadera,\nejecuta cualquier línea de código sangrada dentro de ella. Sin embargo, ahora que estamos\nen lo que llamamos el final del ciclo, la computadora\nvolverá a la condición y la verificará nuevamente. Si aún se evalúa como verdadero, la computadora ejecutará\nlas líneas de código sangradas dentro del bucle nuevamente y así sucesivamente, hasta que cuando la\ncomputadora verifica la condición, descubre que la evaluación es falsa. Sólo entonces el ciclo termina definitivamente y la computadora continúa ejecutando el resto del programa. En Python, la sintaxis de un bucle while es solo\nla palabra clave while seguida de una condición booleana y luego dos puntos. Cualquier lente de código que queramos\nrepetir dentro del bucle while, le aplicamos sangría en una pestaña.  A esto lo llamamos cuerpo del bucle.  Como queremos que el ciclo\ntermine eventualmente, no queremos que se repita para siempre, queremos que la condición del ciclo se evalúe como falsa en algún momento. Normalmente, eso significa que nuestra\ncondición de bucle incluirá una variable de bucle, que es una\nvariable que se actualiza dentro del cuerpo del bucle. En cada viaje a través del bucle, lo que llamamos una iteración, el valor de la variable\ncambiará, lo que significa que cuando vayamos a verificar\nla condición del bucle nuevamente, existe la posibilidad de que\nesta vez se evalúe como falsa. Echemos un vistazo a nuestro\nexperimento al lanzamiento de una moneda. Aquí generamos un\nnúmero aleatorio entre uno y dos, y si ese número es uno, imprimimos caras, y si son dos, imprimimos cruces. Ahora, ¿qué pasa si quiero repetir\nese experimento para ver con qué frecuencia obtengo cruz? Puedo envolver mi experimento en un bucle while. Entonces, lo primero que\nquiero hacer es determinar cuál debería ser la condición de mi bucle. Digamos que quiero repetir\neste experimento cinco veces. Entonces mi condición podría ser\nalgo así como num_flips menor que cinco. Luego, cualquier línea de código que\nquiera repetir debe tener una sangría de un nivel. Bueno, en cada iteración quiero\ngenerar un nuevo número aleatorio para simular el lanzamiento de una moneda. Y luego todavía quiero comprobar si es uno o dos e imprimir cara o cruz. Así que voy a tabular todas\nestas líneas de código. Si ejecuto este programa\nahora aparece un error de nombre. Porque la variable\nnum_flips no ha sido definida. Nunca le asignamos un valor. Con los bucles while,\nsiempre queremos asegurarnos de inicializar nuestra\nvariable de bucle antes del bucle. Aquí probablemente queramos inicializar num_flips a cero porque aún no hemos lanzado ningún lanzamiento de moneda en este momento, tenemos cero lanzamientos. Ahora que nuestro error de nombre está solucionado, parece que la computadora\nimprime cabezas, colas, colas, caras, caras para siempre. Esto es lo que llamamos un bucle infinito. Nuestro bucle nunca termina porque nuestra condición de bucle\nnunca se evalúa como falsa. Si alguna vez ve que su\nprograma se cuelga así, deberá presionar el botón de detener para recuperar y finalizar el programa. De lo contrario, seguirá funcionando para siempre hasta que la computadora se quede sin memoria. Entonces, ¿por qué es un bucle infinito? Bueno, nunca actualizamos el\nvalor de la variable del bucle dentro del cuerpo del bucle. Entonces num_flips siempre\ncontiene el valor cero, lo que significa que cada vez que\nvolvemos a la parte superior y verificamos que la condición del bucle que\nestamos verificando sea cero menor que cinco, lo cual siempre será cierto. Lo que realmente queremos es\nincrementar num_flips en uno cada vez que lanzamos una moneda. Básicamente, estamos\ncontando el número de lanzamientos. Entonces, antes de la primera iteración,\nnum_flips será cero. Luego, antes de la segunda iteración\nserá uno, dos, tres, cuatro hasta que la verificación se convierta en\ncinco, menos de cinco, lo que se evalúa como falso y el ciclo termina. Por convención, actualizamos la variable del bucle en la parte inferior del bucle para que cambie justo antes de regresar para\nverificar la condición del bucle. Luego podemos aumentar nuestro\nnúmero de repeticiones simplemente modificando este valor de parada\nen la condición del bucle, digamos a cien o mil. Entonces, cuando escriba\nbucles while, asegúrese de verificar los tres componentes clave: inicializar su variable de bucle antes del bucle,\nverificar su variable de bucle en la condición del bucle y\nactualizar la variable de bucle en la parte inferior de  el cuerpo del bucle.",
    "t_arabic": "- [المدرس] ماذا لو\nكنت تريد أن يقوم برنامجك بتكرار مجموعة من التعليمات البرمجية؟ يمكنك نسخ ولصق\nهذه الأسطر من التعليمات البرمجية. ولكن ماذا لو أردت\nالتكرار مائة مرة أو ألف مرة، أو ربما لا تعرف مقدمًا عدد المرات التي تحتاج إلى التكرار. لحل هذه المشكلة، يمكننا استخدام حلقة while. تخبر حلقة while الكمبيوتر\nبمواصلة تنفيذ مجموعة من التعليمات البرمجية طالما تم\nتقييم شرط معين على أنه صحيح.  لقد استخدمنا الشروط المنطقية من قبل مع الشروط الشرطية. في عبارة if الأساسية، يقوم الكمبيوتر بتقييم الحالة مرة واحدة، وإذا تم تقييمها على أنها صحيحة،\nفإنه ينفذ أي تعليمات برمجية تم وضع مسافة بادئة بداخلها، ثم ينتقل لتنفيذ بقية البرنامج. باستخدام حلقة while، يقوم الكمبيوتر\nبتقييم الحالة وإذا تم تقييمها على أنها صحيحة، فسيقوم\nالكمبيوتر بتنفيذ أي أسطر من التعليمات البرمجية تم وضع مسافة بادئة بداخلها. ومع ذلك، الآن بعد أن وصلنا\nإلى ما نسميه الجزء السفلي من الحلقة،\nسيعود الكمبيوتر إلى الحالة ويتحقق منها مرة أخرى. إذا كان لا يزال يتم تقييمه على أنه صحيح، فسيقوم الكمبيوتر بتنفيذ\nسطور التعليمات البرمجية التي تم وضع مسافة بادئة لها داخل الحلقة مرة أخرى، وهكذا، وما إلى ذلك، حتى عندما\nيتحقق الكمبيوتر من الحالة، يجد أنه تم تقييمه على خطأ. عندها فقط تنتهي الحلقة إلى الأبد وينتقل الكمبيوتر لتنفيذ بقية البرنامج. في لغة Python، يكون بناء جملة حلقة while هو مجرد\nالكلمة الأساسية متبوعة بشرط منطقي ثم نقطتين. أي عدسة تعليمات برمجية نريد\nتكرارها داخل حلقة while، نضع مسافة بادئة فوق علامة تبويب واحدة. نحن نسمي هذا الجسم الحلقة. لأننا نريد أن\nتنتهي الحلقة في النهاية، ولا نريد أن تتكرر إلى الأبد، بل نريد أن يتم تقييم حالة الحلقة إلى خطأ في مرحلة ما. عادة، هذا يعني أن حالة الحلقة لدينا\nستتضمن متغير حلقة، وهو\nمتغير يتم تحديثه داخل نص الحلقة. في كل رحلة خلال الحلقة، ما نسميه التكرار، ستتغير قيمة المتغير،\nمما يعني أنه عندما نذهب للتحقق من\nحالة الحلقة مرة أخرى، هناك احتمال أن يتم\nتقييمها على أنها خطأ هذه المرة. دعونا نلقي نظرة على\nتجربة قلب العملة. هنا نقوم بتوليد\nرقم عشوائي بين واحد واثنين، وإذا كان هذا الرقم واحدًا، فإننا نطبع الرؤوس، وإذا كان اثنان، نطبع الذيل. الآن ماذا لو أردت تكرار\nهذه التجربة لمعرفة عدد المرات التي أحصل فيها على ذيول؟ يمكنني أن أختتم تجربتي في حلقة زمنية. لذا فإن أول شيء\nسأريد فعله هو معرفة ما يجب أن تكون عليه حالة الحلقة الخاصة بي. لنفترض أنني أريد تكرار\nهذه التجربة خمس مرات. لذلك قد تكون حالتي\nمثل num_flips أقل من خمسة. بعد ذلك، يجب وضع مسافة بادئة على مستوى واحد في أي أسطر من التعليمات البرمجية التي\nأرغب في تكرارها . حسنًا، في كل تكرار، أريد\nإنشاء رقم عشوائي جديد لمحاكاة رمي العملة المعدنية. وبعد ذلك ما زلت أرغب في التحقق مما إذا كان واحدًا أو اثنين ورؤوس الطباعة أو الذيول. لذلك سأقوم بتبويب كل\nهذه الأسطر من التعليمات البرمجية. إذا قمت بتشغيل هذا البرنامج\nالآن أحصل على خطأ في الاسم. لأنه\nلم يتم تعريف المتغير num_flips. لم نخصص لها قيمة أبدًا. مع حلقات while،\nنريد دائمًا التأكد من أننا قمنا بتهيئة\nمتغير الحلقة قبل الحلقة. ربما نرغب هنا في تهيئة num_flips إلى الصفر لأننا لم نقم بأي رمي للعملات المعدنية بعد، وفي هذه المرحلة، لدينا صفر قلابات. الآن بعد أن تم إصلاح خطأ الاسم الخاص بنا، يبدو أن\nرؤوس الطباعة للكمبيوتر، ذيول، ذيول، رؤوس، رؤوس إلى الأبد. وهذا ما نسميه حلقة لا نهاية لها. لا تنتهي حلقتنا أبدًا لأن حالة الحلقة الخاصة بنا\nلا يتم تقييمها أبدًا على أنها خطأ. إذا رأيت\nبرنامجك معلقًا بهذا الشكل، فأنت تريد الضغط على زر الإيقاف لاستعادة البرنامج وإنهائه. وإلا، فإنه سيستمر في العمل إلى الأبد حتى تنفد ذاكرة الكمبيوتر. فلماذا هو حلقات لا نهاية لها؟ حسنًا، نحن لا نقوم أبدًا بتحديث\nقيمة متغير الحلقة داخل نص الحلقة. لذا فإن num_flips\nيحتوي دائمًا على القيمة صفر، مما يعني أنه في كل مرة\nنعود فيها إلى الأعلى ونتحقق من أن حالة الحلقة التي\nنتحقق منها هي صفر أقل من خمسة، والذي سيكون صحيحًا دائمًا. ما نريده بالفعل هو\nزيادة num_flips بمقدار واحد في كل مرة نقوم فيها بقلب العملة المعدنية. لذلك نحن نحسب بشكل أساسي\nعدد التقلبات. لذلك، قبل التكرار الأول،\nستكون قيمة num_flips صفرًا. ثم قبل التكرار الثاني\nسيكون واحدًا، اثنان، ثلاثة، أربعة حتى يصبح الشيك\nخمسة، أقل من خمسة، والذي يتم تقييمه على أنه خطأ وتنتهي الحلقة. وفقًا للاتفاقية، نقوم بتحديث متغير الحلقة في أسفل الحلقة بحيث يتغير مباشرة قبل أن نعود\nللتحقق من حالة الحلقة.  ومن ثم يمكننا زيادة\nعدد التكرارات لدينا فقط عن طريق تعديل قيمة التوقف هذه\nفي حالة الحلقة، مثلاً إلى مائة أو ألف. لذلك عندما تكتب أثناء\nالحلقات، تأكد من التحقق من المكونات الرئيسية الثلاثة التي قمت بتهيئة متغير الحلقة الخاصة بك قبل الحلقة، ومن\nالتحقق من متغير الحلقة في حالة الحلقة،\nومن تحديث متغير الحلقة في أسفل  الجسم الحلقة.",
    "t_italian": "- [Istruttore] Cosa succede se\nvuoi che il tuo programma ripeta un blocco di codice? Potresti copiare e incollare\nquelle righe di codice. Ma cosa succederebbe se volessi\nripetere cento o mille volte, o forse non sapessi nemmeno in anticipo quante volte avresti bisogno di ripetere? Per risolvere questo problema possiamo utilizzare un ciclo while. Un ciclo while dice al computer\ndi continuare a eseguire un blocco di codice finché una determinata\ncondizione risulta vera. Abbiamo già utilizzato condizioni booleane con i condizionali. In un'istruzione if di base, il computer valuta la condizione una volta e, se risulta vera,\nesegue qualsiasi codice rientrato al suo interno, quindi passa all'esecuzione del resto del programma. Con un ciclo while, il computer\nvaluta la condizione e, se risulta vera,\nesegue tutte le righe di codice rientrate al suo interno. Tuttavia, ora che siamo\nin quella che chiamiamo la fine del ciclo, il computer\ntornerà alla condizione e la controllerà di nuovo. Se il valore risulta ancora vero, il computer eseguirà nuovamente\nle righe di codice rientrate all'interno del ciclo e così via e così via e così via, fino a quando il\ncomputer controlla la condizione, scopre che il valore è falso. Solo allora il ciclo termina definitivamente e il computer passa all'esecuzione del resto del programma. In Python la sintassi del ciclo while è semplicemente\nla parola chiave while seguita da una condizione booleana e poi da due punti. Qualsiasi lente di codice che vogliamo\nripetere all'interno del ciclo while, rientriamo di una scheda.  Lo chiamiamo corpo del loop. Poiché vogliamo che il ciclo\ntermini prima o poi, non vogliamo che si ripeta per sempre, vorremo che la condizione del ciclo diventi falsa ad un certo punto. In genere, ciò significa che la nostra\ncondizione del ciclo includerà una variabile del ciclo , che è una\nvariabile che viene aggiornata all'interno del corpo del ciclo. Ad ogni viaggio attraverso il ciclo, ciò che chiamiamo iterazione, il valore della variabile\ncambierà, il che significa che quando andiamo a controllare\ndi nuovo la condizione del ciclo, c'è la possibilità che\nquesta volta possa risultare falsa. Diamo un'occhiata al nostro\nesperimento del lancio della moneta. Qui generiamo un\nnumero casuale compreso tra uno e due e, se quel numero è uno, stampiamo testine e, se è due, stampiamo code.  E se volessi ripetere\nl'esperimento per vedere quanto spesso ottengo croce? Posso racchiudere il mio esperimento in un ciclo while. Quindi la prima cosa che\nvoglio fare è capire quale dovrebbe essere la condizione del mio loop. Diciamo che voglio ripetere\nquesto esperimento cinque volte. Quindi la mia condizione potrebbe essere\nqualcosa come num_flips inferiore a cinque. Quindi tutte le righe di codice che\nvoglio ripetere devono essere rientrate di un livello. Bene, ad ogni iterazione voglio\ngenerare un nuovo numero casuale per simulare il lancio di una moneta. E poi voglio ancora controllare se sono uno o due e stampare teste o code. Quindi inserirò tutte\nqueste righe di codice. Se eseguo questo programma\nora ottengo un errore nel nome. Perché la variabile\nnum_flips non è stata definita. Non gli abbiamo mai assegnato un valore. Con i cicli while,\nvogliamo sempre assicurarci di inizializzare la nostra\nvariabile di ciclo prima del ciclo. Qui probabilmente vogliamo inizializzare num_flips a zero perché non abbiamo ancora fatto nessun lancio di moneta a questo punto, abbiamo zero lanci. Ora che l'errore del nostro nome è stato corretto, sembra che le\ntestine di stampa del computer, code, code, teste, teste per sempre. Questo è ciò che chiamiamo un ciclo infinito. Il nostro ciclo non termina mai perché la nostra condizione del ciclo\nnon risulta mai falsa. Se mai vedi il tuo\nprogramma bloccarsi in questo modo, vuoi premere il pulsante di arresto per ripristinare e terminare il programma. Altrimenti, continuerà a funzionare per sempre finché il computer non esaurirà la memoria. Allora perché è un loop infinito? Bene, non aggiorniamo mai il\nvalore della variabile del ciclo all'interno del corpo del ciclo. Quindi num_flips\ncontiene sempre il valore zero, il che significa che ogni volta che\ntorniamo all'inizio e controlliamo la condizione del ciclo che\nstiamo controllando è zero inferiore a cinque, il che sarà sempre vero. Ciò che in realtà vogliamo è\nincrementare num_flips di uno ogni volta che lanciamo una moneta. Quindi stiamo essenzialmente\ncontando il numero di lanci. Quindi prima della prima iterazione,\nnum_flips sarà zero. Quindi prima della seconda iterazione\nsarà uno, due, tre, quattro finché il controllo non diventa\ncinque, meno di cinque, che restituisce falso e il ciclo termina. Per convenzione, aggiorniamo la variabile del ciclo alla fine del ciclo in modo che cambi subito prima di tornare a\ncontrollare la condizione del ciclo. Quindi possiamo aumentare il\nnumero di ripetizioni semplicemente modificando questo valore di arresto\nnella condizione del ciclo, diciamo a cento o mille. Quindi, quando scrivi\ncicli while, assicurati di controllare tutti e tre i componenti chiave di inizializzare la variabile del ciclo prima del ciclo, di\ncontrollare la variabile del ciclo nella condizione del ciclo e di\naggiornare la variabile del ciclo nella parte inferiore di  il corpo del circuito."
}