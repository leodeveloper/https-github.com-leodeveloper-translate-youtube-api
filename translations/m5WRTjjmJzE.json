{
    "source": "m5WRTjjmJzE",
    "youtubelink": "https://www.youtube.com/watch?v=m5WRTjjmJzE",
    "t_english": "- -instructor] Let's design a program with chain conditionals. We wanna build a program that calculates an object's weight on different planets. We have the formula for this already. Weight equals mass times gravity. So if we know an object's weight on earth, we can divide by earth's gravity to get the mass. And then once we have the mass, we can just multiply by the gravitational force of whatever planet we're interested in. Our starter code here calculates an object's weight on Mars. We take the gravitational force on Mars, which is 3.7 meters per second squared. Then we ask for the weight of the object on earth and then we plug those two numbers into our formula to get the weight on Mars. I am thinking I wanna round this number though, so it's a bit easier for the user to look at. There's definitely a built-in function for this. Okay, looks like it's just called round and it takes two arguments. The number to be rounded and the number of decimal places to round to. That's looking a lot cleaner. Now I wanna make this work for other planets too, not just Mars. So we're gonna want an input function call that asks the user to enter a planet name. We'll assign that to the variable planet and then we'll use a conditional to assign the value of gravity. Let's start with the Mars case that we already had. Before I start my conditional, I wanna make sure to initialize my variable gravity to a default value. Let's say zero here probably makes sense. We'll want our condition to be planet equals equals the string Mars. If this evaluates to true, then we wanna set gravity to 3.7, which is the gravitational force on Mars. So we end it, that assignment statement inside that if branch. There are a lot of planets. So let's just start with a few of them. We'll do Mars Mercury, Venus, and Jupiter. Mercury's gravitational force is also 3.7. So we can just use the or operator to turn this into a compound condition that checks that the planet is Mars or Mercury. Next, we wanna check that the planet equals Venus. This is related to the previous condition and it's mutually exclusive with it. The planet can't both be Mars and Venus, so it makes sense to use an elif branch here. If the planet equals equals Venus, then we wanna set gravity to Venus's gravitational force. Then we have the Jupiter case, which is another branch. Now let's test that conditional. If I enter Mars, it's giving the same weight that I had before, so that must be correct and Mercury should give the same answer. And then Venus' gravitational force is bigger, so its weight should be bigger. And then Jupiter should be even bigger still. Ooh, wait, that's a zero. Maybe that means gravity still has this default value zero. When we do the calculation and maybe this branch isn't actually executing. Let me test that hypothesis by adding some temporary debugging print statements. I'll add one inside this Jupiter elif branch so I can see if this branch is actually getting executed. And then maybe I'll print down here what the value of gravity is right before I calculate the weight. Interesting. So it is hitting that branch 'cause it's executing this print statement and it says that the value of gravity is zero. That's bizarre because if it's executing this branch, it should be executing this assignment statement, which means gravity should be 23.1. Oh wait, I see the bug. I use the equality operator, not the assignment operator. So this is checking if gravity equals equals 23.1 instead of assigning 23.1 to gravity. Okay. But I need to go in and clean up those debugging print statements 'cause I don't want my users to see them. What do we wanna happen if the user enter something that's not a planet at all or is a typo, or is a planet we just don't support yet? This case is a catchall. It's any string that's not Mars, Mercury, Venus or Jupiter, which could be any of infinite possibilities. So we can't really express that with a separate condition. We need an else branch. Let's just give the user an informative error message and tell them that we don't recognize that planet name. So we make sure to indent this print statement inside the else branch. Let's test that else case. It prints unrecognized planet, but then it prints, it would weigh zero kilograms on potato. If the user enters in unrecognized planet, I don't wanna print out what it would weigh 'cause it doesn't make sense. Actually, thinking about it, I don't need to do any of these calculations at all. I don't even need to ask them what the weight on earth is because I'm not gonna do anything with it. So if I wanna skip all these lines of code, I'm gonna need another conditional. I don't wanna chain it with the existing conditional because it's not mutually exclusive with all those cases. It should run if the planet is Mars, Mercury, Venus, or Jupiter. So we use an if to start a new conditional and then I wanna indent all of these lines of code inside it. What should my condition be though? How do I know if I was in the else case before? Well, if none of these three branches executed, then the value of gravity would still be zero. So I can have this condition be if gravity is not equal to zero, but I can actually use a shortcut here because zero cast to a Boolean is false and any other float cast to a Boolean is true. So I can just shorten this condition to if gravity, which checks that gravity has some value that's not zero. Now, if I enter some unrecognized planet name, it just gives me that error message and then skips all of the calculations. Ooh, break time. I'm gonna add a quick comment here so I remember where to pick up later. I'll note down the gravitational forces of the remaining planets in case you wanna give it a try. \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n",
    "t_urdu": "- -انسٹرکٹر] آئیے چین کنڈیشنلز کے ساتھ ایک پروگرام ڈیزائن کریں۔ ہم ایک ایسا پروگرام بنانا چاہتے ہیں جو مختلف سیاروں پر کسی چیز کے وزن کا حساب لگائے۔\n اس کا فارمولا ہمارے پاس پہلے ہی موجود ہے۔ وزن ماس اوقات کشش ثقل کے برابر ہے۔ لہذا اگر ہم زمین پر کسی چیز کا وزن جانتے ہیں، تو ہم کمیت حاصل کرنے کے لیے زمین کی کشش ثقل سے تقسیم کر سکتے ہیں۔\n اور پھر ایک بار جب ہمارے پاس\nکمیت ہو جائے تو ہم جس بھی سیارے میں دلچسپی رکھتے ہیں اس کی کشش ثقل کی قوت سے ضرب کر سکتے ہیں۔ یہاں ہمارا اسٹارٹر کوڈ\nمریخ پر کسی چیز کے وزن کا حساب لگاتا ہے۔ ہم مریخ پر کشش ثقل کی قوت لیتے ہیں، جو کہ 3.7 میٹر فی سیکنڈ مربع ہے۔ پھر ہم\nزمین پر موجود شے کا وزن پوچھتے ہیں اور پھر ہم مریخ پر وزن حاصل کرنے کے لیے ان دو\nنمبروں کو اپنے فارمولے میں شامل کرتے ہیں۔ میں سوچ رہا ہوں کہ میں\nاس نمبر کو گول کرنا چاہتا ہوں، لہذا صارف کے لیے اسے دیکھنا قدرے آسان ہے۔\n \nاس کے لیے یقینی طور پر ایک بلٹ ان فنکشن موجود ہے۔ ٹھیک ہے، ایسا لگتا ہے کہ اسے ابھی راؤنڈ کہا جاتا ہے اور اس میں دو دلیلیں لگتی ہیں۔ گول کی جانے والی تعداد اور اعشاریہ جگہوں کی تعداد جس کو گول کرنا ہے۔ یہ بہت صاف نظر آرہا ہے۔ اب میں یہ کام صرف مریخ ہی نہیں\nدوسرے سیاروں کے لیے بھی کرنا چاہتا ہوں۔ لہذا ہم ایک ان پٹ فنکشن کال چاہتے ہیں جو صارف سے سیارے کا نام درج کرنے کو کہے۔ ہم اسے متغیر سیارے کو تفویض کریں گے اور پھر ہم کشش ثقل کی قدر تفویض کرنے کے لیے ایک مشروط استعمال کریں گے۔ آئیے مریخ کے معاملے سے شروع کریں\nجو ہمارے پاس پہلے ہی تھا۔ اس سے پہلے کہ میں اپنا\nمشروط شروع کروں، میں یہ یقینی بنانا چاہتا ہوں کہ اپنی متغیر\nکشش ثقل کو ڈیفالٹ ویلیو میں شروع کر دوں۔ آئیے کہتے ہیں کہ یہاں صفر شاید معنی رکھتا ہے۔ ہم چاہیں گے کہ ہماری حالت سیارے کے مساوی ہو\nمریخ کے تار کے برابر ہو۔ اگر یہ درست ثابت ہوتا ہے، تو\nہم کشش ثقل کو 3.7 پر سیٹ کرنا چاہتے ہیں، جو مریخ پر کشش ثقل کی قوت ہے۔ تو ہم اسے ختم کرتے ہیں، اس\nتفویض کا بیان کہ اگر برانچ کے اندر۔ سیارے بہت ہیں۔ تو آئیے صرف ان میں سے چند کے ساتھ شروع کرتے ہیں۔ ہم مریخ مرکری، وینس اور مشتری کریں گے۔ عطارد کی کشش ثقل بھی 3.7 ہے۔ لہذا ہم اسے ایک مرکب حالت میں تبدیل کرنے کے لیے یا آپریٹر کا استعمال کر سکتے ہیں\nجو یہ جانچتا ہے کہ سیارہ مریخ ہے یا مرکری۔ اگلا، ہم یہ دیکھنا چاہتے ہیں کہ\nسیارہ زہرہ کے برابر ہے۔ یہ پچھلی حالت سے متعلق ہے اور یہ اس کے ساتھ باہمی طور پر مخصوص ہے۔ سیارہ مریخ اور زہرہ دونوں نہیں ہو سکتے، اس لیے\nیہاں ایلیف برانچ استعمال کرنا سمجھ میں آتا ہے۔ اگر سیارہ\nزہرہ کے برابر ہے، تو ہم زہرہ کی کشش ثقل کو کشش ثقل کو مقرر کرنا چاہتے ہیں۔ پھر ہمارے پاس مشتری کا\nمعاملہ ہے، جو ایک اور شاخ ہے۔ اب اس مشروط کی جانچ کرتے ہیں۔ اگر میں مریخ میں داخل ہوتا ہوں تو یہ\nوہی وزن دے رہا ہے جو میں پہلے تھا، لہذا یہ درست ہونا چاہیے اور عطارد کو وہی جواب دینا چاہیے۔ اور پھر زہرہ کی کشش ثقل\nبڑی ہے، اس لیے اس کا وزن بھی بڑا ہونا چاہیے۔ اور پھر مشتری کو اس سے بھی\nبڑا ہونا چاہیے۔ اوہ، انتظار کرو، یہ ایک صفر ہے۔ ہوسکتا ہے کہ اس کا مطلب یہ ہے کہ کشش ثقل کی\nیہ ڈیفالٹ ویلیو صفر ہے۔ جب ہم حساب کرتے ہیں اور شاید یہ برانچ\nاصل میں عمل نہیں کر رہی ہے۔ مجھے کچھ عارضی ڈیبگنگ پرنٹ اسٹیٹمنٹس شامل کرکے اس مفروضے کی جانچ کرنے دیں۔ میں\nاس مشتری ایلیف برانچ کے اندر ایک کا اضافہ کروں گا تاکہ میں دیکھ سکوں کہ آیا یہ برانچ\nواقعتاً کام کر رہی ہے۔ اور پھر شاید میں یہاں پرنٹ کروں گا کہ میں وزن کا حساب لگانے سے\n پہلے کشش ثقل کی قدر صحیح ہے۔\n دلچسپ تو یہ اس برانچ کو مار رہا ہے 'کیونکہ یہ اس پرنٹ اسٹیٹمنٹ کو انجام دے رہا ہے اور یہ کہتا ہے کہ\nکشش ثقل کی قدر صفر ہے۔ یہ عجیب ہے کیونکہ اگر\nیہ اس برانچ کو انجام دے رہا ہے، تو اسے\nاس تفویض بیان پر عمل کرنا چاہئے، جس کا مطلب ہے کہ کشش ثقل 23.1 ہونی چاہئے۔ اوہ انتظار کرو، میں بگ دیکھ رہا ہوں۔ میں مساوات آپریٹر استعمال کرتا ہوں،\nاسائنمنٹ آپریٹر نہیں۔ تو یہ جانچ رہا ہے کہ آیا کشش ثقل 23.1 کو\n تفویض کرنے کے بجائے 23.1 کے برابر ہے یا نہیں۔ ٹھیک ہے۔ لیکن مجھے اندر جانے اور\nان ڈیبگنگ پرنٹ اسٹیٹمنٹس کو صاف کرنے کی ضرورت ہے کیونکہ میں نہیں چاہتا کہ میرے صارفین انہیں دیکھیں۔ اگر\nصارف کوئی ایسی چیز داخل کرتا ہے جو بالکل سیارہ نہیں ہے یا ٹائپنگ کی غلطی ہے، یا ایسا سیارہ ہے جسے ہم ابھی تک سپورٹ نہیں کرتے ہیں تو ہم کیا چاہتے ہیں؟ یہ کیس کیچال ہے۔ یہ کوئی بھی تار ہے جو\nمریخ، عطارد، زہرہ یا مشتری نہیں ہے، جو کہ\nلامحدود امکانات میں سے کوئی بھی ہو سکتا ہے۔ لہذا ہم واقعی\nاس کا اظہار ایک الگ شرط کے ساتھ نہیں کر سکتے۔ ہمیں ایک اور شاخ کی ضرورت ہے۔ آئیے صارف کو صرف ایک\nمعلوماتی غلطی کا پیغام دیں اور انہیں بتائیں کہ ہم\nاس سیارے کے نام کو نہیں پہچانتے ہیں۔ لہذا ہم\nاس پرنٹ اسٹیٹمنٹ کو دوسری برانچ کے اندر انڈینٹ کرنا یقینی بناتے ہیں۔ آئیے اس دوسرے معاملے کی جانچ کریں۔ یہ غیر تسلیم شدہ سیارے کو پرنٹ کرتا ہے، لیکن پھر یہ پرنٹ کرتا ہے، اس کا\nوزن آلو پر صفر کلو گرام ہوگا۔ اگر صارف غیر تسلیم شدہ سیارے میں داخل ہوتا ہے، تو میں پرنٹ نہیں کرنا چاہتا کہ\nاس کا وزن کیا ہوگا کیونکہ اس کا کوئی مطلب نہیں ہے۔ دراصل، اس کے بارے میں سوچتے ہوئے، مجھے ان میں سے کوئی بھی حساب کرنے کی ضرورت نہیں ہے۔\n مجھے ان سے یہ پوچھنے کی بھی ضرورت نہیں ہے کہ\nزمین پر وزن کیا ہے کیونکہ میں اس کے ساتھ کچھ نہیں کرنے والا ہوں۔ لہذا اگر میں کوڈ کی ان تمام لائنوں کو چھوڑنا چاہتا ہوں تو\n مجھے ایک اور مشروط ضرورت ہوگی۔ میں اسے موجودہ مشروط کے ساتھ جوڑنا نہیں چاہتا\n کیونکہ یہ ان\nتمام معاملات کے ساتھ باہمی طور پر خصوصی نہیں ہے۔ اگر سیارہ مریخ، عطارد، زہرہ یا مشتری ہو تو اسے چلنا چاہیے۔ لہذا ہم ایک نئے مشروط کو شروع کرنے کے لئے if کا استعمال کرتے ہیں اور پھر میں اس کے اندر کوڈ کی ان تمام لائنوں کو انڈینٹ کرنا چاہتا ہوں۔ حالانکہ میری حالت کیا ہونی چاہیے؟ میں کیسے جان سکتا ہوں کہ آیا میں\nپہلے کسی اور معاملے میں تھا؟ ٹھیک ہے، اگر ان\nتینوں شاخوں میں سے کوئی بھی کام نہیں کرتا ہے، تو پھر بھی کشش ثقل کی قدر\nصفر ہوگی۔ تو میری یہ حالت ہو سکتی ہے\nاگر کشش ثقل صفر کے برابر نہ ہو، لیکن میں اصل میں\nیہاں ایک شارٹ کٹ استعمال کر سکتا ہوں کیونکہ بولین کے لیے صفر کاسٹ غلط ہے اور بولین میں کوئی اور فلوٹ کاسٹ\nدرست ہے۔ تو میں اس\nشرط کو صرف اگر کشش ثقل تک مختصر کر سکتا ہوں، جو یہ جانچتا ہے کہ کشش ثقل کی\nکچھ قدر ہے جو صفر نہیں ہے۔ اب، اگر میں کچھ\nغیر تسلیم شدہ سیارے کا نام درج کرتا ہوں، تو یہ مجھے صرف غلطی کا پیغام دیتا ہے اور پھر تمام حسابات کو چھوڑ دیتا ہے۔ اوہ، وقفے کا وقت۔ میں یہاں ایک فوری تبصرہ شامل کرنے والا ہوں تاکہ مجھے یاد رہے کہ بعد میں کہاں سے پک اپ کرنا ہے۔  اگر آپ اسے آزمانا چاہتے ہیں تو میں باقی سیاروں کی کشش ثقل کی قوتوں کو نوٹ کروں گا۔ \n",
    "t_spanish": "- -instructor] Diseñemos un programa con condicionales en cadena. Queremos crear un programa que calcule el peso de un objeto\nen diferentes planetas. Ya tenemos la fórmula para esto.  El peso es igual a la masa multiplicada por la gravedad. Entonces, si conocemos el peso de un objeto en la Tierra, podemos dividirlo por la gravedad de la Tierra\npara obtener la masa. Y luego, una vez que tenemos la\nmasa, podemos simplemente multiplicarla por la fuerza gravitacional de cualquier planeta que nos interese. Nuestro código inicial aquí calcula el\npeso de un objeto en Marte. Tomamos la fuerza gravitacional en Marte, que es de 3,7 metros por segundo al cuadrado. Luego preguntamos por el peso\ndel objeto en la Tierra y luego ingresamos esos dos\nnúmeros en nuestra fórmula para obtener el peso en Marte. \nSin embargo, estoy pensando en redondear este número, para que sea un poco más fácil de\nver para el usuario. Definitivamente hay una\nfunción incorporada para esto. Bien, parece que simplemente se llama redondo y requiere dos argumentos. El número que se va a redondear y el número de decimales a los que se va a redondear. Eso se ve mucho más limpio. Ahora quiero que esto funcione\ntambién para otros planetas, no sólo para Marte. Entonces vamos a querer una llamada de función de entrada que le pida al usuario que ingrese el nombre de un planeta. Lo asignaremos a la variable planeta y luego usaremos un condicional para asignar el valor de la gravedad. Empecemos con el\ncaso de Marte que ya teníamos. Antes de comenzar con mi\ncondicional, quiero asegurarme de inicializar mi\ngravedad variable a un valor predeterminado. Digamos que cero aquí probablemente tenga sentido. Querremos que nuestra condición sea planeta\nigual a la cuerda Marte. Si esto se considera verdadero, entonces\nqueremos establecer la gravedad en 3,7, que es la fuerza gravitacional en Marte. Así que terminamos con esa\ndeclaración de asignación dentro de esa rama if. Hay muchos planetas. Así que comencemos con algunos de ellos. Haremos Marte, Mercurio, Venus y Júpiter.  La fuerza gravitacional de Mercurio también es 3,7. Entonces podemos usar el operador o para convertir esto en una\ncondición compuesta que verifique que el planeta es Marte o Mercurio. A continuación, queremos comprobar que\nel planeta es igual a Venus. Esto está relacionado con la condición anterior y es mutuamente excluyente con ella. El planeta no puede ser Marte y Venus al mismo tiempo, por lo que tiene sentido\nusar una rama elif aquí. Si el planeta es igual a\nVenus, entonces queremos establecer la gravedad como la fuerza gravitacional de Venus. Luego tenemos el\ncaso de Júpiter, que es otra rama. Ahora probemos ese condicional. Si entro a Marte, está dando\nel mismo peso que tenía antes, entonces eso debe ser correcto y Mercurio debería dar la misma respuesta. Y entonces la fuerza gravitacional de Venus\nes mayor, por lo que su peso debería ser mayor. Y entonces Júpiter debería\nser aún más grande. Oh, espera, eso es un cero. Quizás eso signifique que la gravedad todavía\ntiene este valor predeterminado de cero. Cuando hacemos el cálculo y tal vez esta rama en\nrealidad no se esté ejecutando. Permítanme probar esa hipótesis agregando algunas declaraciones de impresión de depuración temporales. Agregaré uno dentro de\nesta rama elif de Júpiter para poder ver si esta rama\nrealmente se está ejecutando. Y luego tal vez imprima\naquí cuál es el valor de la gravedad justo antes de\ncalcular el peso. Interesante. Entonces está golpeando esa rama porque está ejecutando esta declaración impresa y dice que el\nvalor de la gravedad es cero. Eso es extraño porque si está\nejecutando esta rama, debería ejecutar\nesta declaración de asignación, lo que significa que la gravedad debería ser 23,1. Oh, espera, veo el error. Utilizo el operador de igualdad,\nno el operador de asignación. Entonces esto es verificar si la gravedad es\nigual a 23,1 en lugar de asignar 23,1 a la gravedad. Bueno. Pero necesito entrar y\nlimpiar esas declaraciones impresas de depuración porque no quiero que mis usuarios las vean.  ¿ Qué queremos que suceda si\nel usuario ingresa algo que no es un planeta en absoluto o es un error tipográfico, o es un planeta que simplemente no admitimos todavía? Este caso es un cajón de sastre. Es cualquier cuerda que\nno sea Marte, Mercurio, Venus o Júpiter, que podría tener\ninfinitas posibilidades. Entonces realmente no podemos expresar\neso con una condición separada. Necesitamos otra rama. Simplemente demos al usuario un\nmensaje de error informativo y le digamos que no\nreconocemos el nombre de ese planeta. Así que nos aseguramos de sangrar\nesta declaración impresa dentro de la rama else. Probemos ese otro caso. Imprime un planeta no reconocido, pero luego imprime,\npesaría cero kilogramos en una papa. Si el usuario ingresa a un planeta no reconocido, no quiero\nimprimir lo que pesaría porque no tiene sentido. En realidad, pensándolo bien, no necesito hacer ninguno de\nestos cálculos en absoluto. Ni siquiera necesito preguntarles\ncuál es el peso en la Tierra porque no voy a hacer nada con él. Entonces, si quiero saltarme todas\nestas líneas de código, necesitaré otro condicional. No quiero encadenarlo con\nel condicional existente porque no es mutuamente\nexcluyente con todos esos casos. Debería funcionar si el planeta es Marte, Mercurio, Venus o Júpiter. Entonces usamos if para comenzar un nuevo condicional y luego quiero sangrar todas estas líneas de código dentro de él.  ¿ Cuál debería ser mi condición?  ¿ Cómo sé si\nantes estaba en el caso else? Bueno, si ninguna de estas\ntres ramas se ejecutara, entonces el valor de la gravedad\nseguiría siendo cero. Entonces puedo tener esta condición\nsi la gravedad no es igual a cero, pero en realidad puedo\nusar un atajo aquí porque la conversión de cero a un booleano es falsa y cualquier otra conversión flotante\na un booleano es verdadera. Entonces puedo acortar esta\ncondición a si la gravedad, que verifica que la gravedad tenga\nalgún valor que no sea cero. Ahora, si ingreso algún\nnombre de planeta no reconocido, simplemente me da ese mensaje de error y luego omite todos los cálculos. Oh, hora de descanso. Voy a agregar un comentario rápido aquí para recordar dónde continuar más tarde. Anotaré las fuerzas gravitacionales de los planetas restantes en\ncaso de que quieras intentarlo.",
    "t_arabic": "- -instructor] لنصمم برنامجًا بسلسلة شرطية. نريد بناء برنامج يقوم بحساب\nوزن الجسم على الكواكب المختلفة. لدينا الصيغة لهذا بالفعل. الوزن يساوي الكتلة في الجاذبية. لذا، إذا عرفنا وزن جسم ما على الأرض، فيمكننا القسمة على\nجاذبية الأرض للحصول على الكتلة. وبمجرد أن نحصل على\nالكتلة، يمكننا ضربها في قوة الجاذبية لأي كوكب نهتم به. رمز البداية الخاص بنا هنا يحسب\nوزن الجسم على المريخ. نحن نأخذ قوة الجاذبية على المريخ، وهي 3.7 متر في الثانية المربعة. ثم نسأل عن وزن\nالجسم الموجود على الأرض ثم نعوض بهذين\nالرقمين في الصيغة للحصول على الوزن على المريخ. أعتقد أنني أريد\nتقريب هذا الرقم، لذلك يكون من الأسهل\nعلى المستخدم النظر إليه. هناك بالتأكيد\nوظيفة مدمجة لهذا الغرض. حسنًا، يبدو أنه تم استدعاؤه للتو ويتطلب وسيطتين. الرقم الذي سيتم تقريبه وعدد المنازل العشرية التي سيتم التقريب إليها. هذا يبدو أكثر نظافة. الآن أريد أن أجعل هذا يعمل\nعلى الكواكب الأخرى أيضًا، وليس المريخ فقط. لذلك، سنحتاج إلى استدعاء دالة إدخال تطلب من المستخدم إدخال اسم كوكب. سنخصص ذلك للكوكب المتغير ثم سنستخدم شرطًا لتعيين قيمة الجاذبية. لنبدأ بقضية المريخ\nالتي كانت لدينا بالفعل. قبل أن أبدأ\nشرطي، أريد التأكد من تهيئة\nالجاذبية المتغيرة إلى قيمة افتراضية. لنفترض أن الصفر هنا ربما يكون منطقيًا. نريد أن تكون حالتنا هي كوكب\nيساوي سلسلة المريخ. إذا كان هذا صحيحًا،\nفإننا نريد ضبط الجاذبية على 3.7، وهي قوة الجاذبية على المريخ. لذلك ننهي الأمر،\nبيان المهمة داخل فرع if. هناك الكثير من الكواكب. لذلك دعونا نبدأ مع عدد قليل منهم. سنفعل المريخ وعطارد والزهرة والمشتري. تبلغ قوة جاذبية عطارد أيضًا 3.7. لذلك يمكننا فقط استخدام العامل أو لتحويل هذا إلى\nحالة مركبة تتحقق من أن الكوكب هو المريخ أو عطارد. بعد ذلك، نريد التحقق من أن\nالكوكب يساوي كوكب الزهرة. وهذا متعلق بالشرط السابق ومتعارض معه. لا يمكن أن يكون الكوكب هو المريخ والزهرة معًا، لذا فمن المنطقي\nاستخدام فرع إليف هنا. إذا كان الكوكب يساوي\nكوكب الزهرة، فإننا نريد أن نضبط الجاذبية على قوة جاذبية كوكب الزهرة. ثم لدينا\nحالة المشتري، وهي فرع آخر. الآن دعونا نختبر هذا الشرط. إذا دخلت المريخ، فسيعطي\nنفس الوزن الذي كان لدي من قبل، لذا يجب أن يكون هذا صحيحًا ويجب على عطارد أن يعطي نفس الإجابة. ومن ثم فإن قوة جاذبية كوكب الزهرة\nأكبر، لذا يجب أن يكون وزنه أكبر. وبعد ذلك يجب أن يكون كوكب المشتري\nأكبر. أوه، انتظر، هذا صفر. ربما هذا يعني أن الجاذبية لا تزال\nلديها هذه القيمة الافتراضية صفر. عندما نقوم بالحساب وربما\nلا يتم تنفيذ هذا الفرع بالفعل. اسمحوا لي أن أختبر هذه الفرضية عن طريق إضافة بعض عبارات الطباعة المؤقتة لتصحيح الأخطاء. سأضيف واحدًا داخل\nفرع Jupiter elif حتى أتمكن من معرفة ما إذا كان هذا الفرع قد تم\nتنفيذه بالفعل. ومن ثم ربما سأكتب\nهنا قيمة الجاذبية الصحيحة قبل أن\nأحسب الوزن. مثير للاهتمام. لذا فهو يضرب ذلك الفرع لأنه ينفذ بيان الطباعة هذا ويقول أن\nقيمة الجاذبية هي صفر. هذا غريب لأنه إذا\nكان ينفذ هذا الفرع، فيجب أن ينفذ\nبيان المهمة هذا، مما يعني أن الجاذبية يجب أن تكون 23.1. أوه انتظر، أرى الخلل. أستخدم عامل المساواة،\nوليس عامل التخصيص. إذن هذا هو التحقق مما إذا كانت الجاذبية\nتساوي 23.1 بدلاً من تخصيص 23.1 للجاذبية. تمام. لكني أحتاج إلى الدخول وتنظيف\n بيانات الطباعة لتصحيح الأخطاء لأنني لا أريد أن يراها المستخدمون. ماذا نريد أن يحدث إذا\nأدخل المستخدم شيئًا ليس كوكبًا على الإطلاق أو أنه خطأ مطبعي، أو أنه كوكب لا ندعمه بعد؟ هذه الحالة هي قضية شاملة. إنه أي وتر\nليس المريخ أو عطارد أو الزهرة أو المشتري، والذي يمكن أن يكون\nأيًا من الاحتمالات اللانهائية. لذلك لا يمكننا حقًا التعبير عن\nذلك بشرط منفصل. نحن بحاجة إلى فرع آخر. دعنا نعطي المستخدم\nرسالة خطأ إعلامية ونخبره أننا لا\nنتعرف على اسم الكوكب هذا. لذلك نتأكد من وضع مسافة بادئة\nلبيان الطباعة داخل الفرع else. دعونا نختبر تلك الحالة الأخرى. إنها تطبع كوكبًا غير معروف، ولكن بعد ذلك تطبع، سيكون\nوزن البطاطس صفرًا. إذا دخل المستخدم إلى كوكب غير معروف، فلا أريد طباعة\nما سيزنه لأنه غير منطقي. في الواقع، عند التفكير في الأمر، لا أحتاج إلى إجراء أي من\nهذه الحسابات على الإطلاق. لا أحتاج حتى أن أسألهم\nما هو الوزن على الأرض لأنني لن أفعل أي شيء به. لذا، إذا أردت تخطي كل\nهذه الأسطر من التعليمات البرمجية، فسوف أحتاج إلى شرط شرطي آخر. لا أريد أن أقوم بربطها مع\nالشرط الحالي لأنه لا\nيتعارض مع كل تلك الحالات. يجب تشغيله إذا كان الكوكب هو المريخ أو عطارد أو الزهرة أو المشتري. لذلك نستخدم if لبدء شرط شرطي جديد ثم أريد وضع مسافة بادئة لكل هذه الأسطر من التعليمات البرمجية بداخله. ماذا يجب أن تكون حالتي بالرغم من ذلك؟ كيف أعرف إذا كنت\nفي حالة أخرى من قبل؟ حسنًا، إذا لم يتم تنفيذ أي من هذه\nالفروع الثلاثة، فستظل قيمة الجاذبية\nصفرًا. لذلك يمكن أن يكون هذا الشرط\nإذا كانت الجاذبية لا تساوي الصفر، ولكن يمكنني في الواقع\nاستخدام الاختصار هنا لأن تحويل الصفر إلى قيمة منطقية هو خطأ وأي تعويم آخر يتم تحويله\nإلى قيمة منطقية يكون صحيحًا. لذا يمكنني اختصار هذا\nالشرط إلى الجاذبية، والتي تتحقق من أن الجاذبية لها\nقيمة ليست صفرًا. الآن، إذا قمت بإدخال\nاسم كوكب غير معروف، فإنه يعطيني رسالة الخطأ هذه ثم يتخطى جميع الحسابات. أوه، وقت الاستراحة. سأضيف تعليقًا سريعًا هنا حتى أتذكر المكان الذي سألتقطه لاحقًا. سأقوم بتدوين قوى الجاذبية للكواكب المتبقية في\nحال أردت تجربتها.",
    "t_italian": "- -istruttore] Progettiamo un programma con condizionali a catena. Vogliamo costruire un programma che calcoli il peso di un oggetto\nsu diversi pianeti. Abbiamo già la formula per questo.  Il peso è uguale alla massa per la gravità. Quindi, se conosciamo il peso di un oggetto sulla Terra, possiamo dividerlo per la\ngravità terrestre per ottenere la massa. E poi, una volta ottenuta la\nmassa, possiamo semplicemente moltiplicarla per la forza gravitazionale di qualunque pianeta ci interessi. Il nostro codice iniziale qui calcola il\npeso di un oggetto su Marte. Prendiamo la forza gravitazionale su Marte, che è di 3,7 metri al secondo quadrato. Poi chiediamo il peso\ndell'oggetto sulla Terra e poi inseriamo questi due\nnumeri nella nostra formula per ottenere il peso su Marte. Penso\nperò di voler arrotondare questo numero, quindi è un po' più facile\nda guardare per l'utente. C'è sicuramente una\nfunzione integrata per questo. Ok, sembra che si sia appena chiamato round e ci vogliono due argomenti. Il numero da arrotondare e il numero di cifre decimali a cui arrotondare. Sembra molto più pulito. Ora voglio che funzioni\nanche per altri pianeti, non solo per Marte. Quindi vorremo una chiamata alla funzione di input che chieda all'utente di inserire il nome di un pianeta. Lo assegneremo alla variabile pianeta e poi useremo un condizionale per assegnare il valore della gravità. Cominciamo con il\ncaso Marte che abbiamo già avuto. Prima di iniziare il\ncondizionale, voglio assicurarmi di inizializzare la\ngravità variabile su un valore predefinito. Diciamo che zero qui probabilmente ha senso. Vorremo che la nostra condizione fosse pianeta uguale\nuguale alla stringa Marte. Se questo risulta vero, allora\nvogliamo impostare la gravità su 3,7, che è la forza gravitazionale su Marte. Quindi terminiamo,\nquell'istruzione di assegnazione all'interno di quel ramo if. Ci sono molti pianeti. Cominciamo quindi con alcuni di essi. Faremo Marte Mercurio, Venere e Giove. Anche la forza gravitazionale di Mercurio è 3,7. Quindi possiamo semplicemente usare l'operatore o per trasformarlo in una\ncondizione composta che verifica che il pianeta sia Marte o Mercurio. Successivamente, vogliamo verificare che\nil pianeta sia uguale a Venere. Questo è legato alla condizione precedente e si esclude a vicenda. Il pianeta non può essere sia Marte che Venere, quindi ha senso\nutilizzare un ramo elif qui. Se il pianeta è uguale a\nVenere, allora vogliamo impostare la gravità sulla forza gravitazionale di Venere. Poi abbiamo il\ncaso di Giove, che è un altro ramo. Ora testiamo il condizionale. Se entro su Marte, mi verrà dato\nlo stesso peso che avevo prima, quindi deve essere corretto e Mercurio dovrebbe dare la stessa risposta. E poi la forza gravitazionale di Venere\nè maggiore, quindi il suo peso dovrebbe essere maggiore. E poi Giove dovrebbe\nessere ancora più grande. Ooh, aspetta, è uno zero. Forse questo significa che la gravità\nha ancora questo valore predefinito pari a zero. Quando eseguiamo il calcolo e forse questo ramo\nnon è effettivamente in esecuzione. Vorrei testare questa ipotesi aggiungendo alcune istruzioni print di debug temporanee.  Ne aggiungerò uno all'interno di\nquesto ramo elif di Giove così posso vedere se questo ramo\nviene effettivamente eseguito. E poi forse stamperò\nqui qual è il valore della gravità prima di\ncalcolare il peso. Interessante. Quindi sta colpendo quel ramo perché sta eseguendo questa istruzione print e dice che il\nvalore della gravità è zero. È strano perché se\nsta eseguendo questo ramo, dovrebbe eseguire\nquesta istruzione di assegnazione, il che significa che la gravità dovrebbe essere 23,1. Oh aspetta, vedo il bug. Utilizzo l'operatore di uguaglianza,\nnon l'operatore di assegnazione. Quindi questo controlla se la gravità è\nuguale a 23,1 invece di assegnare 23,1 alla gravità.  Va bene. Ma devo entrare e\nripulire quelle istruzioni print di debug perché non voglio che i miei utenti le vedano. Cosa vogliamo che accada se\nl'utente inserisce qualcosa che non è affatto un pianeta o è un errore di battitura o è un pianeta che semplicemente non supportiamo ancora? Questo caso è un tuttofare. È una stringa qualsiasi che\nnon sia Marte, Mercurio, Venere o Giove, il che potrebbe rappresentare\nuna qualsiasi delle infinite possibilità. Quindi non possiamo davvero esprimerlo\ncon una condizione separata. Abbiamo bisogno di un altro ramo. Diamo semplicemente all'utente un\nmessaggio di errore informativo e diciamogli che non\nriconosciamo il nome di quel pianeta. Quindi ci assicuriamo di rientrare\nquesta istruzione print all'interno del ramo else. Proviamo quest'altro caso. Stampa un pianeta non riconosciuto, ma poi stampa,\npeserebbe zero chilogrammi su una patata. Se l'utente entra in un pianeta non riconosciuto, non voglio stampare\nquanto peserebbe perché non ha senso. In realtà, a pensarci bene, non ho bisogno di fare nessuno di\nquesti calcoli. Non ho nemmeno bisogno di chiedere loro\nqual è il peso sulla terra perché non ci farò niente. Quindi se voglio saltare tutte\nqueste righe di codice, mi servirà un altro condizionale.  Non voglio concatenarlo con\nil condizionale esistente perché non si\nesclude a vicenda con tutti questi casi. Dovrebbe funzionare se il pianeta è Marte, Mercurio, Venere o Giove. Quindi usiamo un if per iniziare un nuovo condizionale e poi voglio far rientrare tutte queste righe di codice al suo interno. Ma quale dovrebbe essere la mia condizione? Come faccio a sapere se\nprima ero nell'altro caso? Ebbene, se nessuno di questi\ntre rami venisse eseguito, il valore della gravità\nsarebbe ancora zero. Quindi posso avere questa condizione\nse la gravità non è uguale a zero, ma in realtà posso\nusare una scorciatoia qui perché zero cast su un booleano è falso e qualsiasi altro float cast\nsu un booleano è vero. Quindi posso semplicemente abbreviare questa\ncondizione in \"se gravità\", che verifica che la gravità abbia\nun valore diverso da zero. Ora, se inserisco il\nnome di un pianeta non riconosciuto, mi viene visualizzato semplicemente quel messaggio di errore e quindi salta tutti i calcoli. Ooh, pausa. Aggiungerò un breve commento qui così mi ricordo dove riprendere più tardi. Annoterò le forze gravitazionali dei restanti pianeti nel\ncaso tu voglia provarci."
}