{
    "source": "rJCRGiEidZ4",
    "youtubelink": "https://www.youtube.com/watch?v=rJCRGiEidZ4",
    "t_english": "- [Instructor] Imagine you're playing a word game where you need to guess only three-letter words. What strategy might you use to solve for all the words in this game? One approach might be to just guess all of the letters in alphabetical order, so you start by guessing A, then you guess B, then you guess C, and so on until you get the full word. We think we can be a bit more clever than that, so what if instead, we guess the letters in order of how frequently they occur in the English language? Both of these processes will get to the correct solution eventually, but neither is particularly clever or efficient. These solutions do the same exact thing every single time. They don't take new information into account to inform what they do next. For example, that there is an E and it's the last letter of the word. To do this, we need a new type of control flow called selection. We've seen control flow in our programs that uses sequence, where one step comes after the other. Selection allows our control flow to branch. We ask a yes or no question, and then based on the answer to that question, we select which branch to continue down, skipping the other branch entirely. With our word game, we might still start with a step that guesses the letter E, but then we might pause here to consider the information we have available and then decide what to do next based off of it. We'll use a control flow diagram to model all the different paths that are available. Here we ask, is there an E? If the answer is no, we wanna keep trying to find the vowel, so we'll guess A. If the answer is yes, then the best letter to guess depends on whether that E is the first, second or third letter of the word. So we make another selection. If the answer to our question, is E the last letter of the word, is yes, then we're likely to have an O-E or an I-E ending, since those are pretty common. So our next step in this process on this branch will be to guess I. We can continue on in this way until we have a complete process. It's a lot more complex than our first two processes, but we can easily see how this process is more likely to get the correct word in fewer guesses. Now for the terminology, all these things I've just been calling processes, in computer science, these are called algorithms. An algorithm is just a repeatable process to accomplish a task. Like we saw, algorithms are programming language-independent. We express them in English or any other natural language you may speak. As programmers, we wanna think about how we're going to go about solving a problem before we start writing code. So we often spend the majority of our time designing, evaluating and iterating on our algorithms. Only at the very end do we work on translating our algorithm into code. In programming, there are always many solutions to a problem. To evaluate which algorithm is best for a specific use case, we look at three characteristics. Correctness, does the algorithm accomplish the task? Efficiency, how long does it take to accomplish the task? And readability, how complex is the process and how hard is it for somebody to understand? There's often not an objective best solution. It's all in how you evaluate the trade-offs. If I design a search algorithm, and when someone searches for study music, I return playlists of like really intense German bass, then the correctness of my algorithm is probably a bit off. If someone searches for a really generic word like \"the,\" and I have 100 million songs in my database, it might take a really long time for me to find all of the songs that have the word \"the\" in them, which makes my algorithm not super efficient. In this case, I might choose to sacrifice some of the correctness in order to get efficiency. So instead of looking for all of the songs that have the word \"the,\" I might choose the 20 most common and say that's good enough. If I design a route-finding algorithm, and maybe technically the quickest way to get from point A to point B is to take a route with like 20 different turns and change my mind on which way to go, depending on if the stoplight is green or red, well, it's certainly efficient and it's correct, it reaches the destination, but it's not so readable. Try giving those directions to your friend and see if they can figure it out. Maybe there's also an option here to take a back road with no turns and a slightly lower speed limit. That's a lot more readable. So if the efficiency trade off is minimal, like this takes 10 minutes and the other way takes eight minutes, then maybe this is the better route. As we design our own algorithms with sequence and selection, we should always keep these trade-offs in mind. Which brings us to our next step, translating our algorithms with selection into code.\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n",
    "t_urdu": "- [انسٹرکٹر] تصور کریں کہ\nآپ ایک لفظی کھیل کھیل رہے ہیں جہاں آپ کو\nصرف تین حرفی الفاظ کا اندازہ لگانے کی ضرورت ہے۔  اس گیم کے تمام الفاظ کو حل کرنے کے لیے آپ کونسی حکمت عملی استعمال کر سکتے ہیں ؟ ایک نقطہ نظر\nصرف حروف تہجی کی ترتیب میں تمام حروف کا اندازہ لگانا ہو سکتا ہے، لہذا آپ A کا اندازہ لگا کر شروع کریں\n، پھر آپ B کا اندازہ لگائیں، پھر آپ C کا اندازہ لگائیں، اور اسی طرح\nجب تک آپ کو پورا لفظ نہ مل جائے۔ ہمیں لگتا ہے کہ ہم\nاس سے کچھ زیادہ ہوشیار ہوسکتے ہیں، تو کیا ہوگا اگر اس کے بجائے، ہم اس ترتیب سے انگلش زبان میں حروف کا اندازہ لگائیں کہ وہ کتنی بار آتے ہیں ؟ یہ دونوں عمل آخر کار درست حل تک پہنچ جائیں گے،\n لیکن کوئی بھی خاص طور پر\nہوشیار یا موثر نہیں ہے۔ یہ حل\nہر بار ایک ہی عین مطابق کام کرتے ہیں۔ وہ یہ بتانے کے لیے نئی\nمعلومات کو مدنظر نہیں رکھتے کہ وہ آگے کیا کرتے ہیں۔ مثال کے طور پر، کہ ایک E ہے اور یہ لفظ کا آخری حرف ہے۔ ایسا کرنے کے لیے، ہمیں ایک نئی قسم کے کنٹرول فلو کی ضرورت ہے جسے سلیکشن کہتے ہیں۔ ہم نے اپنے پروگراموں میں کنٹرول کا بہاؤ دیکھا ہے\nجو ترتیب کا استعمال کرتا ہے، جہاں ایک قدم دوسرے کے بعد آتا ہے۔ انتخاب برانچ میں ہمارے کنٹرول کے بہاؤ کی اجازت دیتا ہے۔\n ہم ہاں یا نہیں میں سوال پوچھتے ہیں، اور پھر\nاس سوال کے جواب کی بنیاد پر، ہم دوسری برانچ کو مکمل طور پر چھوڑتے ہوئے، کونسی برانچ کو نیچے جاری رکھنا ہے اس کا انتخاب کرتے ہیں۔ ہمارے لفظی کھیل کے ساتھ، ہم\nاب بھی ایک ایسے قدم کے ساتھ شروع کر سکتے ہیں جو حرف E کا اندازہ لگاتا ہے، لیکن پھر ہم اپنے پاس دستیاب معلومات پر غور کرنے کے لیے یہاں توقف کر سکتے ہیں \n اور پھر فیصلہ کر سکتے ہیں کہ\nاس کی بنیاد پر آگے کیا کرنا ہے۔ ہم دستیاب تمام مختلف راستوں کو ماڈل بنانے کے لیے ایک کنٹرول فلو ڈایاگرام استعمال کریں گے۔ \n یہاں ہم پوچھتے ہیں، کیا کوئی E ہے؟ اگر جواب نفی میں ہے، تو ہم\nسر کو تلاش کرنے کی کوشش کرتے رہنا چاہتے ہیں، لہذا ہم A کا اندازہ لگائیں گے۔ اگر جواب ہاں میں ہے، تو\nاندازہ لگانے کے لیے بہترین حرف اس بات پر منحصر ہے کہ آیا\nE لفظ کا پہلا، دوسرا یا تیسرا حرف ہے۔  . تو ہم ایک اور انتخاب کرتے ہیں۔ اگر ہمارے سوال کا جواب، E لفظ کا آخری حرف ہے، ہاں ہے، تو ہمارے پاس\nO-E یا I-E کا اختتام ہونے کا امکان ہے، کیونکہ یہ بہت عام ہیں۔ لہذا اس برانچ پر اس عمل میں ہمارا اگلا مرحلہ\n I کا اندازہ لگانا ہوگا۔ ہم اس طرح جاری رکھ سکتے ہیں جب تک کہ ہمارے پاس مکمل عمل نہ ہو۔ یہ ہمارے پہلے دو عملوں کے مقابلے میں بہت زیادہ پیچیدہ ہے،\n لیکن ہم آسانی سے دیکھ سکتے ہیں کہ اس عمل سے \nکم اندازوں میں صحیح لفظ حاصل کرنے کا زیادہ امکان کیسے ہے۔ اب ٹرمینالوجی کے لیے، ان تمام چیزوں کو جو میں صرف\nپروسیسز کہہ رہا ہوں، کمپیوٹر سائنس میں، ان کو\nالگورتھم کہتے ہیں۔ ایک الگورتھم کسی کام کو پورا کرنے کے لیے صرف ایک قابل تکرار عمل ہے۔ جیسا کہ ہم نے دیکھا، الگورتھم پروگرامنگ زبان سے آزاد ہیں۔ ہم ان کا اظہار انگریزی یا کسی دوسری قدرتی\nزبان میں کرتے ہیں جو آپ بول سکتے ہیں۔ پروگرامرز کے طور پر، ہم یہ سوچنا چاہتے ہیں کہ کوڈ لکھنا شروع کرنے سے پہلے ہم کسی\nمسئلے کو حل کرنے کے بارے میں کس طرح جا رہے ہیں۔ اس لیے ہم اکثر اپنا زیادہ تر\nوقت اپنے الگورتھم کو ڈیزائن کرنے، جانچنے اور اعادہ کرنے میں صرف کرتے ہیں۔\n صرف آخر میں ہم اپنے الگورتھم کو کوڈ میں ترجمہ کرنے پر کام کرتے ہیں۔ پروگرامنگ میں،\nہمیشہ ایک مسئلہ کے بہت سے حل ہیں .  یہ جانچنے کے لیے کہ کون سا الگورتھم\nمخصوص استعمال کے معاملے کے لیے بہترین ہے، ہم تین خصوصیات کو دیکھتے ہیں۔ درستگی، کیا\nالگورتھم کام کو پورا کرتا ہے؟ کارکردگی،\nکام کو پورا کرنے میں کتنا وقت لگتا ہے؟ اور پڑھنے کی اہلیت، یہ\nعمل کتنا پیچیدہ ہے اور کسی کے لیے سمجھنا کتنا مشکل ہے\n؟ اکثر کوئی\nمعقول بہترین حل نہیں ہوتا ہے۔ یہ سب کچھ اس بات پر ہے کہ آپ کس طرح\nٹریڈ آف کا جائزہ لیتے ہیں۔ اگر میں تلاش کا الگورتھم ڈیزائن کرتا ہوں، اور جب کوئی مطالعہ موسیقی کے لیے تلاش کرتا ہے، تو میں واقعی شدید جرمن باس کی طرح کی پلے لسٹ واپس کرتا ہوں،\n تو میرے الگورتھم کی درستگی شاید تھوڑی دور ہے۔ اگر کوئی\nواقعی عام لفظ جیسا کہ \"the\" تلاش کرتا ہے اور\nمیرے ڈیٹا بیس میں میرے 100 ملین گانے ہیں، تو مجھے ان تمام گانوں کو تلاش کرنے میں کافی وقت لگ سکتا ہے جن میں لفظ \"the\" ہے، جس سے  میرا الگورتھم\nزیادہ موثر نہیں ہے۔ اس معاملے میں، میں کارکردگی حاصل کرنے کے لیے کچھ درستی کو قربان کرنے کا انتخاب کر سکتا ہوں۔ \n اس لیے ان تمام گانوں کو تلاش کرنے کے بجائے جن میں لفظ \"the\" ہے، میں\nشاید 20 سب سے عام کا انتخاب کروں اور کہوں کہ یہ کافی اچھا ہے۔ اگر میں روٹ فائنڈنگ الگورتھم ڈیزائن کرتا ہوں، اور ہوسکتا ہے کہ تکنیکی طور پر پوائنٹ A سے\nپوائنٹ B تک جانے کا تیز ترین طریقہ یہ ہے کہ 20 مختلف موڑ کے ساتھ راستہ اختیار کیا جائے اور اس پر منحصر ہے کہ\nاسٹاپ لائٹ سبز ہے یا نہیں  یا سرخ، ٹھیک ہے، یہ یقینی طور پر\nکارآمد ہے اور یہ درست ہے، یہ منزل تک پہنچ جاتا ہے، لیکن یہ اتنا پڑھنے کے قابل نہیں ہے۔ اپنے دوست کو وہ ہدایات دینے کی کوشش کریں اور دیکھیں کہ آیا وہ اس کا پتہ لگا سکتے ہیں۔ ہو سکتا ہے کہ یہاں ایک آپشن بھی ہو\nکہ کوئی موڑ نہ ہو اور\nرفتار کی حد قدرے کم ہو۔ یہ بہت زیادہ پڑھنے کے قابل ہے۔ لہذا اگر کارکردگی کم سے کم ہے، جیسے اس میں 10 منٹ لگتے ہیں اور دوسرے راستے میں آٹھ منٹ لگتے ہیں، تو شاید یہ بہتر راستہ ہے۔ جیسا کہ ہم\nترتیب اور انتخاب کے ساتھ اپنے الگورتھم کو ڈیزائن کرتے ہیں، ہمیں ہمیشہ\nان ٹریڈ آف کو ذہن میں رکھنا چاہیے۔ جو ہمیں ہمارے اگلے مرحلے پر لاتا ہے، ہمارے الگورتھم کو\nانتخاب کے ساتھ کوڈ میں ترجمہ کرتا ہے۔",
    "t_spanish": "- [Instructor] Imagina que\nestás jugando un juego de palabras en el que solo necesitas adivinar\npalabras de tres letras.  ¿ Qué estrategia podrías usar para resolver todas las palabras de este juego? Un enfoque podría ser\nsimplemente adivinar todas las letras en orden alfabético, de modo que comience adivinando la\nA, luego la B, luego la C, y así sucesivamente\nhasta obtener la palabra completa. Creemos que podemos ser un poco\nmás inteligentes que eso, entonces, ¿qué pasa si, en cambio, adivinamos las letras en el orden de la frecuencia con la que aparecen en el idioma inglés? Ambos procesos eventualmente llegarán a la\nsolución correcta, pero ninguno es particularmente\ninteligente o eficiente. Estas soluciones hacen\nexactamente lo mismo cada vez. No tienen\nen cuenta la nueva información para informar lo que harán a continuación. Por ejemplo, que haya una E y sea la última letra de la palabra. Para hacer esto, necesitamos un nuevo tipo de flujo de control llamado selección. Hemos visto un flujo de control en nuestros\nprogramas que utiliza secuencia, donde un paso viene tras otro. La selección permite que nuestro\nflujo de control se ramifique. Hacemos una pregunta de sí o no y luego, según la\nrespuesta a esa pregunta, seleccionamos qué rama continuar hacia abajo, omitiendo la otra rama por completo. Con nuestro juego de palabras,\naún podríamos comenzar con un paso que adivina la letra E, pero luego podríamos hacer una pausa aquí para considerar la información que\ntenemos disponible y luego decidir qué\nhacer a continuación en función de ella. Usaremos un diagrama de flujo de control para modelar todas las diferentes\nrutas que están disponibles. Aquí preguntamos, ¿hay una E? Si la respuesta es no, queremos\nseguir intentando encontrar la vocal, así que adivinaremos A. Si la respuesta es sí, entonces\nla mejor letra para adivinar depende de si esa\nE es la primera, segunda o tercera letra de la palabra.  . Entonces hacemos otra selección. Si la respuesta a nuestra pregunta, es E, la última letra de la palabra, es sí, entonces es probable que tengamos\nuna terminación O-E o I-E, ya que son bastante comunes. Entonces nuestro próximo paso en este\nproceso en esta rama será adivinar I. Podemos continuar de esta manera hasta que tengamos un proceso completo. Es mucho más complejo que\nnuestros dos primeros procesos, pero podemos ver fácilmente cómo es más probable que este proceso obtenga la\npalabra correcta con menos conjeturas. Ahora, en cuanto a la terminología, todas estas cosas que acabo de\nllamar procesos, en informática se\nllaman algoritmos. Un algoritmo es simplemente un proceso repetible para realizar una tarea. Como vimos, los algoritmos son independientes del lenguaje de programación. Los expresamos en inglés o en cualquier otro\nidioma natural que usted hable. Como programadores, queremos pensar en cómo vamos a\nresolver un problema antes de comenzar a escribir código. Por eso, a menudo dedicamos la mayor parte\nde nuestro tiempo a diseñar, evaluar e iterar\nnuestros algoritmos. Sólo al final trabajamos para traducir nuestro algoritmo en código. En programación,\nsiempre hay muchas soluciones a un problema. Para evaluar qué algoritmo es\nmejor para un caso de uso específico, analizamos tres características. Corrección, ¿el\nalgoritmo logra la tarea? Eficiencia, ¿cuánto tiempo\nlleva realizar la tarea? Y legibilidad, ¿qué tan\ncomplejo es el proceso y qué tan difícil es para\nalguien entenderlo?  A menudo no existe una\nmejor solución objetiva. Todo depende de cómo\nevalúes las compensaciones. Si diseño un algoritmo de búsqueda, y cuando alguien busca música de estudio, devuelvo listas de reproducción de\nbajo alemán realmente intenso, entonces la corrección de mi algoritmo probablemente esté un poco equivocada. Si alguien busca una\npalabra realmente genérica como \"the\", y tengo 100 millones de\ncanciones en mi base de datos, puede que me lleve mucho tiempo encontrar todas las canciones que contienen la palabra \"the\", lo que hace que  Mi algoritmo\nno es súper eficiente. En este caso, podría optar por sacrificar parte de la corrección\npara obtener eficiencia. Entonces, en lugar de buscar todas las canciones que tienen la palabra \"the\",\npodría elegir las 20 más comunes y decir que es suficiente. Si diseño un algoritmo de búsqueda de rutas, y tal vez técnicamente la forma más rápida de llegar del punto A al\npunto B sea tomar una ruta con como 20 giros diferentes y cambiar de opinión sobre qué camino tomar, dependiendo de si el\nsemáforo está en verde.  o rojo, bueno, ciertamente es\neficiente y correcto, llega al destino, pero no es tan legible. Intente darle esas instrucciones a su amigo y vea si puede resolverlo. Quizás aquí también exista la opción\nde tomar una carretera secundaria sin curvas y con un\nlímite de velocidad ligeramente inferior. Eso es mucho más legible. Entonces, si el compromiso de eficiencia es mínimo, como si esto tomara 10 minutos y el otro método toma ocho minutos, entonces tal vez esta sea la mejor ruta. Al diseñar nuestros propios algoritmos\ncon secuencia y selección, siempre debemos tener en\ncuenta estas compensaciones. Lo que nos lleva al siguiente paso, traducir nuestros algoritmos\nde selección a código.",
    "t_arabic": "- [المدرس] تخيل أنك\nتلعب لعبة كلمات حيث يتعين عليك تخمين\nكلمات مكونة من ثلاثة أحرف فقط. ما هي الإستراتيجية التي يمكنك استخدامها لحل جميع الكلمات في هذه اللعبة؟ قد يكون أحد الأساليب هو\nتخمين جميع الحروف حسب الترتيب الأبجدي، بحيث تبدأ بتخمين\nأ، ثم تخمين ب، ثم تخمين ج، وهكذا\nحتى تحصل على الكلمة الكاملة. نعتقد أننا يمكن أن نكون\nأكثر ذكاءً من ذلك، فماذا لو قمنا بدلاً من ذلك بتخمين الحروف حسب عدد مرات تكرارها في اللغة الإنجليزية؟  ستصل هاتان العمليتان إلى\nالحل الصحيح في النهاية، لكن لا تتسم أي منهما بالذكاء\nأو الكفاءة. هذه الحلول تفعل نفس\nالشيء بالضبط في كل مرة. إنهم لا يأخذون\nالمعلومات الجديدة في الاعتبار لإبلاغهم بما يفعلونه بعد ذلك. على سبيل المثال، يوجد حرف E وهو الحرف الأخير من الكلمة. للقيام بذلك، نحتاج إلى نوع جديد من تدفق التحكم يسمى الاختيار.  لقد رأينا تدفق التحكم في\nبرامجنا التي تستخدم التسلسل، حيث تأتي خطوة تلو الأخرى. يسمح التحديد\nبتدفق التحكم الخاص بنا إلى الفرع. نطرح سؤالاً بنعم أو لا، ثم بناءً على\nإجابة هذا السؤال، نختار الفرع الذي سنستمر فيه، ونتخطى الفرع الآخر تمامًا. في لعبة الكلمات الخاصة بنا، قد\nنبدأ بخطوة لتخمين الحرف E، ولكن بعد ذلك قد نتوقف هنا للنظر في المعلومات\nالمتوفرة لدينا ثم نقرر ما يجب\nفعله بعد ذلك بناءً على ذلك. سنستخدم مخطط تدفق التحكم لنمذجة كافة\nالمسارات المختلفة المتوفرة. وهنا نسأل هل يوجد حرف E؟ إذا كانت الإجابة لا، فنحن نريد\nالاستمرار في محاولة العثور على حرف العلة، لذلك سنخمن A. إذا كانت الإجابة بنعم، فإن\nأفضل حرف يمكن تخمينه يعتمد على ما إذا كان\nE هو الحرف الأول أو الثاني أو الثالث من الكلمة  . لذلك نقوم باختيار آخر. إذا كانت الإجابة على سؤالنا، هي نعم، الحرف الأخير من الكلمة E، فمن المحتمل أن يكون لدينا\nنهاية O-E أو I-E، نظرًا لأنها شائعة جدًا. لذا فإن خطوتنا التالية في هذه\nالعملية في هذا الفرع ستكون التخمين I. يمكننا الاستمرار بهذه الطريقة حتى ننتهي من العملية الكاملة. إنها أكثر تعقيدًا بكثير من\nالعمليتين الأوليين، ولكن يمكننا أن نرى بسهولة كيف من المرجح أن تحصل هذه العملية على \nالكلمة الصحيحة بعدد أقل من التخمينات. الآن بالنسبة للمصطلحات، كل هذه الأشياء التي كنت\nأسميها للتو عمليات، في علوم الكمبيوتر،\nتسمى هذه بالخوارزميات. الخوارزمية هي مجرد عملية قابلة للتكرار لإنجاز مهمة ما. كما رأينا، الخوارزميات مستقلة عن لغة البرمجة. نحن نعبر عنها باللغة الإنجليزية أو أي لغة طبيعية أخرى\nقد تتحدثها. كمبرمجين، نريد أن نفكر في كيفية\nحل مشكلة ما قبل أن نبدأ في كتابة التعليمات البرمجية. لذلك غالبًا ما نقضي معظم\nوقتنا في تصميم خوارزمياتنا وتقييمها وتكرارها\n. فقط في النهاية نعمل على ترجمة الخوارزمية إلى كود. في البرمجة، هناك\nدائمًا العديد من الحلول للمشكلة. لتقييم أي خوارزمية هي\nالأفضل لحالة استخدام محددة، فإننا ننظر إلى ثلاث خصائص. صحيح، هل\nتنجز الخوارزمية المهمة؟ الكفاءة، كم من الوقت\nيستغرق إنجاز المهمة؟ وسهولة القراءة، ما مدى\nتعقيد العملية وما مدى صعوبة\nفهمها بالنسبة لشخص ما؟  في كثير من الأحيان لا يوجد\nحل موضوعي أفضل. الأمر كله يتعلق بكيفية\nتقييم المقايضات. إذا قمت بتصميم خوارزمية بحث، وعندما يبحث شخص ما عن موسيقى دراسية، أقوم بإرجاع قوائم تشغيل مثل صوت\nالجهير الألماني القوي حقًا، فمن المحتمل أن تكون صحة الخوارزمية الخاصة بي بعيدة بعض الشيء. إذا قام شخص ما بالبحث عن\nكلمة عامة مثل \"the\"، ولدي 100 مليون\nأغنية في قاعدة البيانات الخاصة بي، فقد يستغرق الأمر وقتًا طويلاً حقًا بالنسبة لي للعثور على جميع الأغاني التي تحتوي على كلمة \"the\" بداخلها، مما يجعل  الخوارزمية الخاصة بي\nليست فائقة الكفاءة. في هذه الحالة، قد أختار التضحية ببعض الصواب من\nأجل الحصول على الكفاءة. لذا بدلاً من البحث عن جميع الأغاني التي تحتوي على كلمة \"the\"،\nقد أختار العشرين الأكثر شيوعًا وأقول إنها جيدة بما فيه الكفاية. إذا قمت بتصميم خوارزمية للعثور على الطريق، وربما تكون أسرع طريقة من الناحية الفنية للانتقال من النقطة أ إلى\nالنقطة ب هي أن تسلك طريقًا به 20 منعطفًا مختلفًا تقريبًا وأغير رأيي بشأن الطريق الذي يجب أن أسلكه، اعتمادًا على ما إذا كانت\nإشارة التوقف خضراء  أو الأحمر، حسنًا، إنه بالتأكيد\nفعال وصحيح، ويصل إلى الوجهة، لكنه ليس قابلاً للقراءة. حاول إعطاء هذه التوجيهات لصديقك ومعرفة ما إذا كان بإمكانه اكتشافها. ربما يكون هناك أيضًا خيار\nهنا لسلوك طريق خلفي بدون منعطفات\nوحد سرعة أقل قليلاً. هذا أكثر قابلية للقراءة. لذا، إذا كانت مقايضة الكفاءة في حدها الأدنى، مثل أن يستغرق هذا 10 دقائق والطريقة الأخرى تستغرق ثماني دقائق، فربما يكون هذا هو الطريق الأفضل. عندما نصمم خوارزمياتنا الخاصة\nبالتسلسل والاختيار، يجب علينا دائمًا أن نضع\nهذه المقايضات في الاعتبار. وهو ما يقودنا إلى خطوتنا التالية، وهي ترجمة خوارزمياتنا\nمع التحديد إلى تعليمات برمجية.",
    "t_italian": "- [Istruttore] Immagina di\ngiocare a un gioco di parole in cui devi indovinare\nsolo parole di tre lettere. Quale strategia potresti usare per risolvere tutte le parole di questo gioco? Un approccio potrebbe essere quello di\nindovinare semplicemente tutte le lettere in ordine alfabetico, quindi inizi indovinando\nA, poi indovina B, poi indovina C e così via\nfinché non ottieni la parola completa. Pensiamo di poter essere un po'\npiù intelligenti di così, e se invece indovinassimo le lettere in ordine di frequenza con cui compaiono nella lingua inglese? Entrambi questi processi \nprima o poi arriveranno alla soluzione corretta, ma nessuno dei due è particolarmente\nintelligente o efficiente. Queste soluzioni fanno la stessa\nidentica cosa ogni volta. Non tengono\nconto delle nuove informazioni per definire ciò che faranno dopo. Ad esempio, che esiste una E ed è l'ultima lettera della parola. Per fare ciò, abbiamo bisogno di un nuovo tipo di flusso di controllo chiamato selezione. Abbiamo visto un flusso di controllo nei nostri\nprogrammi che utilizza la sequenza, dove un passaggio viene dopo l'altro.  La selezione consente al nostro\nflusso di controllo di ramificarsi. Facciamo una domanda sì o no e poi, in base alla\nrisposta a quella domanda, selezioniamo quale ramo proseguire, saltando completamente l'altro ramo. Con il nostro gioco di parole, potremmo\ncomunque iniziare con un passaggio che indovina la lettera E, ma poi potremmo fermarci qui per considerare le informazioni che\nabbiamo a disposizione e poi decidere cosa\nfare dopo in base ad esse. Utilizzeremo un diagramma di flusso di controllo per modellare tutti i diversi\npercorsi disponibili. Qui chiediamo, c'è una E? Se la risposta è no, vogliamo\ncontinuare a cercare la vocale, quindi indovineremo la A. Se la risposta è sì,\nla lettera migliore da indovinare dipende da se la\nE è la prima, la seconda o la terza lettera della parola  . Quindi facciamo un'altra selezione. Se la risposta alla nostra domanda, è E l'ultima lettera della parola, è sì, allora è probabile che avremo una\ndesinenza O-E o I-E, poiché sono piuttosto comuni. Quindi il nostro prossimo passo in questo\nprocesso su questo ramo sarà indovinare I. Possiamo continuare in questo modo finché non avremo un processo completo. È molto più complesso dei\nnostri primi due processi, ma possiamo facilmente vedere come questo processo abbia maggiori probabilità di ottenere la\nparola corretta con meno tentativi. Ora, per quanto riguarda la terminologia, tutte queste cose che\nchiamo processi, in informatica si\nchiamano algoritmi. Un algoritmo è semplicemente un processo ripetibile per portare a termine un compito. Come abbiamo visto, gli algoritmi sono indipendenti dal linguaggio di programmazione. Li esprimiamo in inglese o in qualsiasi altra\nlingua naturale che potresti parlare. Come programmatori, vogliamo pensare a come\nrisolvere un problema prima di iniziare a scrivere il codice. Pertanto, spesso dedichiamo la maggior parte\ndel nostro tempo a progettare, valutare e ripetere i\nnostri algoritmi. Solo alla fine lavoriamo per tradurre il nostro algoritmo in codice. Nella programmazione ci\nsono sempre molte soluzioni a un problema. Per valutare quale algoritmo è\nmigliore per un caso d'uso specifico, esaminiamo tre caratteristiche. Esattezza, l'\nalgoritmo porta a termine il compito? Efficienza, quanto tempo ci\nvuole per portare a termine il compito? E la leggibilità: quanto\nè complesso il processo e quanto è difficile da\ncomprendere per qualcuno? Spesso non esiste una\nsoluzione migliore oggettiva. Dipende tutto da come\nvaluti i compromessi. Se progetto un algoritmo di ricerca e quando qualcuno cerca musica da studio, restituisco playlist di\nbassi tedeschi davvero intensi, probabilmente la correttezza del mio algoritmo è un po' sbagliata. Se qualcuno cerca una\nparola davvero generica come \"il\" e ho 100 milioni di\nbrani nel mio database, potrebbe volerci molto tempo per trovare tutti i brani che contengono la parola \"il\", il che rende  il mio algoritmo\nnon è super efficiente. In questo caso, potrei scegliere di sacrificare parte della correttezza\nper ottenere efficienza. Quindi, invece di cercare tutte le canzoni che contengono la parola \"the\",\npotrei scegliere le 20 più comuni e dire che sono abbastanza buone. Se progetto un algoritmo per la ricerca del percorso, e forse tecnicamente il modo più rapido per andare dal punto A al\npunto B è prendere un percorso con circa 20 svolte diverse e cambiare idea su quale strada prendere, a seconda che il\nsemaforo sia verde  oppure rosso, beh, è ​​certamente\nefficace ed è corretto, arriva a destinazione, ma non è così leggibile. Prova a dare queste indicazioni al tuo amico e vedi se riesce a capirlo. Forse qui c'è anche la possibilità\ndi prendere una strada secondaria senza curve e con un\nlimite di velocità leggermente inferiore.  E' molto più leggibile. Quindi, se il compromesso in termini di efficienza è minimo, ad esempio in questo caso ci vogliono 10 minuti e nell'altro modo ci vogliono otto minuti, allora forse questa è la strada migliore. Quando progettiamo i nostri algoritmi\ncon sequenza e selezione, dovremmo sempre tenere a\nmente questi compromessi. Il che ci porta al passaggio successivo, tradurre i nostri algoritmi\ncon selezione in codice."
}