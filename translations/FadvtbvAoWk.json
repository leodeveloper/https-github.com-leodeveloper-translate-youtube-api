{
    "source": "FadvtbvAoWk",
    "youtubelink": "https://www.youtube.com/watch?v=FadvtbvAoWk",
    "t_english": "- [Instructor] What exactly is happening behind the scenes when the computer executes a while loop? Let's trace a while loop step by step to find out. Before we start, let's see if we can get some intuition for how many times this loop repeats. To count repetitions, we just need to look at the loop variable, what value it starts at before the loop, what value it stops at to terminate the loop, and what value it updates by on each loop iteration. Here we see that our loop variable is called pin and it's initialized to the empty string. The loop condition then is checking the length of the string pin and it's comparing it to the number four, which means this is the length that we'll stop it. Because pin is initialized to the empty string, we're starting out at length zero. Now we just need to look for how pin gets updated inside the loop body. The assignment statement here, it looks like it's concatenating a new digit onto pin on each iteration, so the length of pin would be increasing by one each time. So if we start at zero, we stop when we get to four, and we increment by one, this loop will repeat four times. Now let's double check that work by tracing the full execution. As usual, the computer starts executing at the first line of the program. Here we have an import statement, so the computer goes off and loads the code for the random module into its memory. This line initializes the variable pin. The computer goes off to its short-term memory, allocates a new chunk, stores the value, the empty string there, and then tags it with the name pin. Onto the next line, now we've reached the while loop, so the computer evaluates the loop condition. The variable pin currently contains the value the empty string, so the length of pin is zero. Zero is less than four, so the loop condition evaluates to true. Because it's true, the computer goes on to execute the loop body. The loop body is any lines of code that are intended inside the loop. So the next line to execute is this digit assignment statement. We evaluate the right-hand side of the assignment statement first, which calls the randint function. Randint generates a random number between these two bounds. This happens randomly, so it'll change on each run of the program, but let's say it returns zero this time. This is the first time we're assigning to digit, so the computer creates a new variable. Then we move on. Because this line is indented, it's still inside the while loop, so this is the next line of the loop body. We simplify the right-hand side of the assignment first, so we substitute in digit, which is the integer zero, and we cast it to a string, so we get the string zero. Then we substitute in pin, which is the empty string, and we concatenate together. We store that value back in the variable pin, overriding the previous value. Which line executes next? This print statement is not indented, so it's considered outside of the loop. It's not part of the loop body, that means we're at the bottom of the loop, so the computer jumps execution back to the top of the loop and checks the loop condition again. We substitute in the value of pin, which is now the string zero. We take the length, which is one, one is less than four, so the loop condition still evaluates to true. That means we're executing the loop body again for a second iteration. We generate a new random number, let's say five this time, assign that to digit, and then we update our loop variable pin. Pin currently contains the value zero, and then we concatenate on the string five to get 05. We store that back in pin, and now we're at the bottom of the loop again. We jump back to the top of the loop, and we check the loop condition for the third time. Pin now contains the value 05, so its length is two, two is less four, so the loop condition is true. So we're entering the loop body again. We execute the digit assignment statement, let's say we generate nine this time, we store that in digit, and then we update pin. Pin is currently 05. We can concatenate on the nine, and then we store back 059. Back to the top of the loop, the length of pin is now three. Three is less than four, so the loop condition is still true, and we start the fourth iteration. Randint generates a five this time, so we store that in digit, and then we go onto the next line. Pin is now 059, we can concatenate on the string five, and we store that back in pin. Once again, we find ourselves at the bottom of the loop, so we jump back to the top. We substitute in the current value of pin, which has length four, so now our loop condition is, is four less than four? which evaluates to false. That means it's finally time to terminate the loop. We skip the loop body and look for the next line of code that's not indented inside the loop. That's our print statement here. We substitute in the value of pin, concatenate together and print that sentence out to the console. And that's the last line of the program, so the computer terminates execution, and we see that our loop body indeed executed four times. \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n",
    "t_urdu": "- [انسٹرکٹر] پردے کے پیچھے اصل میں کیا ہو رہا ہے جب\nکمپیوٹر تھوڑی دیر کے لوپ کو چلاتا ہے؟ آئیے یہ\nجاننے کے لیے قدم بہ قدم کچھ دیر کے لوپ کا پتہ لگائیں۔  اس سے پہلے کہ ہم شروع کریں، آئیے دیکھتے ہیں کہ\nکیا ہم اس لوپ کو کتنی بار دہراتے ہیں اس کے لیے کچھ وجدان حاصل کر سکتے ہیں۔ تکرار کو شمار کرنے کے لیے، ہمیں صرف لوپ متغیر کو دیکھنے کی ضرورت ہے، یہ لوپ سے پہلے کس قدر سے شروع ہوتا ہے، یہ لوپ کو ختم کرنے کے لیے کس قدر پر رکتا ہے،\n اور ہر لوپ تکرار پر یہ کس قدر سے اپ ڈیٹ ہوتا ہے۔\n یہاں ہم دیکھتے ہیں کہ ہمارا لوپ\nویری ایبل پن کہلاتا ہے اور اسے خالی سٹرنگ سے شروع کیا گیا ہے۔  اس کے بعد لوپ کی حالت\n سٹرنگ پن کی لمبائی کی جانچ کر رہی ہے اور اس کا موازنہ نمبر چار سے کر رہی ہے، جس کا مطلب ہے کہ یہ وہ\nلمبائی ہے جسے ہم روکیں گے۔ چونکہ پن کو\nخالی سٹرنگ پر شروع کیا جاتا ہے، ہم لمبائی صفر سے شروع کر رہے ہیں۔ اب ہمیں صرف یہ دیکھنے کی ضرورت ہے کہ لوپ باڈی کے اندر\nپن کیسے اپ ڈیٹ ہوتا ہے۔ یہاں تفویض بیان، ایسا لگتا ہے کہ یہ ہر تکرار پر\nپن پر ایک نیا ہندسہ جوڑ رہا ہے، لہذا پن کی لمبائی\nہر بار ایک سے بڑھ رہی ہوگی۔ لہذا اگر ہم صفر سے شروع کرتے ہیں،\nجب ہم چار تک پہنچ جاتے ہیں تو ہم رک جاتے ہیں، اور ہم ایک سے بڑھتے ہیں، یہ لوپ چار بار دہرائے گا۔ اب آئیے مکمل عملدرآمد کا سراغ لگا کر اس کام کو دو بار چیک کریں۔ ہمیشہ کی طرح، کمپیوٹر پروگرام کی پہلی لائن پر عمل کرنا شروع کر دیتا ہے۔ یہاں ہمارے پاس ایک درآمدی بیان ہے، لہذا کمپیوٹر\nبند ہو جاتا ہے اور رینڈم ماڈیول کے لیے کوڈ کو اپنی میموری میں لوڈ کرتا ہے۔ یہ لائن متغیر پن کو شروع کرتی ہے۔ کمپیوٹر\nاپنی قلیل مدتی میموری پر چلا جاتا ہے، ایک نیا حصہ مختص کرتا ہے، قیمت، خالی سٹرنگ کو وہاں ذخیرہ کرتا ہے، اور پھر اسے نام پن کے ساتھ ٹیگ کرتا ہے۔ اگلی لائن پر، اب\nہم while loop پر پہنچ چکے ہیں، لہذا کمپیوٹر لوپ کی حالت کا جائزہ لیتا ہے۔\n متغیر پن فی الحال\nخالی سٹرنگ کی قدر پر مشتمل ہے، لہذا پن کی لمبائی صفر ہے۔ صفر چار سے کم ہے، اس لیے لوپ کی حالت درست پر جانچتی ہے۔ کیونکہ یہ سچ ہے، کمپیوٹر\nلوپ باڈی کو انجام دیتا ہے۔ لوپ باڈی کوڈ کی کوئی بھی لائن ہوتی ہے جس کا مقصد لوپ کے اندر ہوتا ہے۔ تو اگلی لائن اس ڈیجٹ اسائنمنٹ کا بیان ہے۔ ہم پہلے اسائنمنٹ سٹیٹمنٹ کے دائیں جانب کا جائزہ لیتے ہیں، جسے رینڈنٹ فنکشن کہتے ہیں۔ رینڈنٹ\nان دو حدود کے درمیان ایک بے ترتیب نمبر تیار کرتا ہے۔ یہ تصادفی طور پر ہوتا ہے، لہذا یہ پروگرام کے ہر رن پر تبدیل ہو جائے گا،\n لیکن ہم کہتے ہیں کہ اس بار صفر واپس آتا ہے۔ یہ پہلی بار ہے جب\nہم ہندسوں کو تفویض کر رہے ہیں، لہذا کمپیوٹر ایک نیا متغیر بناتا ہے۔ پھر ہم آگے بڑھتے ہیں۔ چونکہ یہ لائن انڈینٹڈ ہے، یہ اب بھی while لوپ کے اندر ہے، لہذا یہ لوپ باڈی کی اگلی لائن ہے۔ ہم پہلے اسائنمنٹ کے دائیں طرف کو آسان بناتے ہیں،\n اس لیے ہم ہندسوں میں بدل دیتے ہیں،\nجو کہ صفر کا عدد ہے، اور ہم اسے ایک سٹرنگ پر ڈالتے ہیں،\nتو ہمیں سٹرنگ صفر مل جاتی ہے۔ پھر ہم پن میں بدلتے ہیں،\nجو کہ خالی تار ہے، اور ہم ایک ساتھ جوڑتے ہیں۔ ہم اس قدر کو واپس\nمتغیر پن میں محفوظ کرتے ہیں، پچھلی قدر کو اوور رائیڈ کرتے ہیں۔ اگلی لائن کونسی ہے؟ یہ پرنٹ اسٹیٹمنٹ انڈینٹڈ نہیں ہے، لہذا اسے لوپ سے باہر سمجھا جاتا ہے۔ یہ لوپ باڈی کا حصہ نہیں ہے، اس کا مطلب ہے کہ ہم\nلوپ کے نچلے حصے میں ہیں، لہذا کمپیوٹر عمل درآمد کو\nواپس لوپ کے اوپری حصے پر لے جاتا ہے اور لوپ کی حالت کو دوبارہ چیک کرتا ہے۔ ہم پن کی قدر میں بدل دیتے ہیں، جو اب سٹرنگ صفر ہے۔ ہم لمبائی لیتے ہیں، جو ایک ہے، ایک چار سے کم ہے، اس لیے لوپ کی حالت\nپھر بھی درست پر جانچتی ہے۔ اس کا مطلب ہے کہ ہم\nلوپ باڈی کو دوبارہ ایک دوسری تکرار کے لیے انجام دے رہے ہیں۔ ہم ایک نیا رینڈم نمبر تیار کرتے ہیں،\nآئیے اس بار پانچ کہتے ہیں، اسے ہندسوں پر تفویض کرتے ہیں، اور پھر ہم اپنے لوپ متغیر پن کو اپ ڈیٹ کرتے ہیں۔ پن میں فی الحال ویلیو صفر ہے، اور پھر ہم\n05 حاصل کرنے کے لیے سٹرنگ فائیو پر جوڑتے ہیں۔ ہم اسے واپس پن میں محفوظ کرتے ہیں، اور اب ہم\nدوبارہ لوپ کے نیچے ہیں۔ ہم واپس لوپ کے سب سے اوپر کودتے ہیں، اور ہم\nتیسری بار لوپ کی حالت کو چیک کرتے ہیں۔ پن اب ویلیو\n05 پر مشتمل ہے، لہذا اس کی لمبائی دو ہے، دو کم چار ہے، لہذا\nلوپ کی حالت درست ہے۔ تو ہم دوبارہ لوپ باڈی میں داخل ہو رہے ہیں۔ ہم ڈیجٹ اسائنمنٹ سٹیٹمنٹ پر عمل کرتے ہیں، ہم کہتے ہیں کہ ہم اس بار نو پیدا کرتے ہیں، ہم اسے ہندسے میں محفوظ کرتے ہیں،\nاور پھر ہم پن کو اپ ڈیٹ کرتے ہیں۔ پن فی الحال 05 ہے۔ ہم نو پر جوڑ سکتے ہیں، اور پھر ہم 059 کو واپس اسٹور کرتے ہیں۔ لوپ کے اوپری حصے پر واپس، پن کی لمبائی اب تین ہے۔ تین چار سے کم ہے، لہذا لوپ کی حالت اب بھی درست ہے، اور ہم چوتھی تکرار شروع کرتے ہیں۔ Randint اس بار پانچ پیدا کرتا ہے، لہذا ہم اسے ہندسے میں محفوظ کرتے ہیں، اور پھر ہم اگلی لائن پر جاتے ہیں۔ پن اب 059 ہے، ہم\nسٹرنگ فائیو پر جمع کر سکتے ہیں، اور ہم اسے واپس پن میں محفوظ کر لیتے ہیں۔ ایک بار پھر، ہم خود کو\nلوپ کے نچلے حصے میں پاتے ہیں، لہذا ہم واپس اوپر کودتے ہیں۔ ہم پن کی موجودہ قیمت میں بدل دیتے ہیں، جس کی لمبائی چار ہے، تو اب ہماری لوپ کی حالت یہ ہے، کیا چار چار سے کم ہے؟ جس کا اندازہ جھوٹ پر ہوتا ہے۔ اس کا مطلب ہے کہ آخر کار\nلوپ کو ختم کرنے کا وقت آگیا ہے۔ ہم لوپ باڈی کو چھوڑتے ہیں اور کوڈ کی اگلی لائن کو تلاش کرتے ہیں جو لوپ کے اندر نہیں لگایا گیا ہے۔ یہ ہمارا پرنٹ اسٹیٹمنٹ یہاں ہے۔ ہم پن کی قدر کو تبدیل کرتے ہیں، ایک ساتھ جوڑتے ہیں اور اس جملے کو کنسول پر پرنٹ کرتے ہیں۔\n اور یہ پروگرام کی آخری لائن ہے، لہذا کمپیوٹر عملدرآمد کو ختم کر دیتا ہے، اور ہم دیکھتے ہیں کہ ہمارے لوپ باڈی نے\nواقعی چار بار عمل درآمد کیا ہے۔",
    "t_spanish": "- [Instructor] ¿Qué sucede exactamente detrás de escena cuando la\ncomputadora ejecuta un bucle while? Tracemos un bucle while\npaso a paso para descubrirlo. Antes de comenzar, veamos\nsi podemos intuir cuántas veces se repite este ciclo. Para contar repeticiones, solo necesitamos mirar la variable del bucle, en qué valor comienza antes del bucle, en qué valor se detiene\npara terminar el bucle y con qué valor se actualiza\nen cada iteración del bucle. Aquí vemos que nuestra\nvariable de bucle se llama pin y se inicializa en la cadena vacía. La condición del bucle entonces\nes verificar la longitud del pasador de cuerda y compararlo con el número cuatro, lo que significa que esta es la\nlongitud en la que lo detendremos. Debido a que pin se inicializa\nen la cadena vacía, comenzamos con una longitud cero. Ahora sólo tenemos que buscar\ncómo se actualiza el pin dentro del cuerpo del bucle. La declaración de asignación aquí parece estar concatenando\nun nuevo dígito en un pin en cada iteración, por lo que la longitud del pin\naumentaría en uno cada vez. Entonces, si comenzamos en cero, nos\ndetenemos cuando llegamos a cuatro e incrementamos en uno, este ciclo se repetirá cuatro veces. Ahora revisemos ese trabajo rastreando la ejecución completa. Como es habitual, la computadora comienza a ejecutarse en la primera línea del programa. Aquí tenemos una declaración de importación, por lo que la computadora se\napaga y carga el código del módulo aleatorio en su memoria. Esta línea inicializa el pin variable. La computadora va a\nsu memoria a corto plazo, asigna un nuevo fragmento, almacena allí el valor, la cadena vacía, y luego lo etiqueta con el pin de nombre. En la siguiente línea, ahora\nhemos llegado al bucle while, por lo que la computadora evalúa\nla condición del bucle. La variable pin actualmente contiene el\nvalor de la cadena vacía, por lo que la longitud del pin es cero. Cero es menor que cuatro, por lo que la condición del bucle se evalúa como verdadera. Como es cierto, la computadora continúa\nejecutando el cuerpo del bucle. El cuerpo del bucle son las líneas de código que están previstas dentro del bucle. Entonces, la siguiente línea a ejecutar es esta declaración de asignación de dígitos.  Primero evaluamos el lado derecho de la declaración de asignación, que llama a la función randint. Randint genera un\nnúmero aleatorio entre estos dos límites. Esto sucede aleatoriamente, por lo que cambiará en cada\nejecución del programa, pero digamos que esta vez devuelve cero. Esta es la primera vez que\nasignamos un dígito, por lo que la computadora crea una nueva variable. Luego seguimos adelante. Debido a que esta línea tiene sangría, todavía está dentro del bucle while, por lo que esta es la siguiente línea del cuerpo del bucle.  Primero simplificamos el\nlado derecho de la asignación, por lo que sustituimos el dígito,\nque es el número entero cero, y lo convertimos en una cadena,\nde modo que obtenemos la cadena cero. Luego sustituimos pin,\nque es la cadena vacía, y concatenamos. Almacenamos ese valor nuevamente\nen el pin variable, anulando el valor anterior.  ¿ Qué línea se ejecuta a continuación? Esta declaración impresa no tiene sangría, por lo que se considera fuera del bucle. No es parte del cuerpo del bucle, eso significa que estamos en\nla parte inferior del bucle, por lo que la computadora salta la ejecución\nnuevamente a la parte superior del bucle y verifica la condición del bucle nuevamente. Sustituimos el valor del pin, que ahora es la cadena cero. Tomamos la longitud, que es uno, uno es menor que cuatro, por lo que la condición del bucle\naún se evalúa como verdadera. Eso significa que volveremos a ejecutar\nel cuerpo del bucle para una segunda iteración. Generamos un nuevo número aleatorio,\ndigamos cinco esta vez, lo asignamos a un dígito y luego actualizamos nuestro pin de variable de bucle. Actualmente, el pin contiene el valor cero y luego concatenamos\nla cadena cinco para obtener 05. Lo almacenamos nuevamente en el pin y ahora estamos\nnuevamente en la parte inferior del bucle. Volvemos a la parte superior del bucle y comprobamos la\ncondición del bucle por tercera vez.  El pin ahora contiene el valor\n05, por lo que su longitud es dos, dos es menos cuatro, por lo que la\ncondición del bucle es verdadera. Así que volvemos a entrar en el cuerpo del bucle. Ejecutamos la instrucción de asignación de dígitos, digamos que esta vez generamos nueve, lo almacenamos en dígitos\ny luego actualizamos el pin. El pin es actualmente 05. Podemos concatenar el nueve y luego almacenar nuevamente 059. Volviendo a la parte superior del bucle, la longitud del pin ahora es tres. Tres es menor que cuatro, por lo que la condición del bucle sigue siendo verdadera y comenzamos la cuarta iteración. Randint genera un cinco esta vez, así que lo almacenamos en dígitos y luego pasamos a la siguiente línea. El pin ahora es 059, podemos\nconcatenar en la cadena cinco y lo guardamos nuevamente en el pin. Una vez más, nos encontramos\nen la parte inferior del bucle, por lo que saltamos de nuevo a la cima. Sustituimos el valor actual del pin, que tiene una longitud de cuatro, por lo que ahora nuestra condición de bucle es: ¿ cuatro es menor que cuatro? que se evalúa como falso. Eso significa que finalmente es\nhora de terminar el ciclo. Nos saltamos el cuerpo del bucle y buscamos la siguiente línea de código que no tenga sangría dentro del bucle. Esa es nuestra declaración impresa aquí. Sustituimos el valor de pin, concatenamos e imprimimos esa oración en\nla consola. Y esa es la última línea del programa, por lo que la computadora finaliza la ejecución y vemos que nuestro cuerpo del bucle se\nejecutó cuatro veces.",
    "t_arabic": "- [المدرس] ما الذي يحدث بالضبط خلف الكواليس عندما يقوم\nالكمبيوتر بتنفيذ حلقة زمنية؟ دعونا نتتبع حلقة while\nخطوة بخطوة لمعرفة ذلك. قبل أن نبدأ، دعونا نرى\nما إذا كان بإمكاننا الحصول على فكرة عن عدد المرات التي تتكرر فيها هذه الحلقة. لحساب التكرارات، نحتاج فقط إلى النظر إلى متغير الحلقة، والقيمة التي يبدأ بها قبل الحلقة، والقيمة التي يتوقف عندها\nلإنهاء الحلقة، والقيمة التي يتم تحديثها بها\nفي كل تكرار للحلقة. هنا نرى أن متغير الحلقة الخاص بنا\nيسمى pin ويتم تهيئته إلى السلسلة الفارغة. شرط الحلقة بعد ذلك\nهو التحقق من طول دبوس السلسلة ومقارنته بالرقم أربعة، مما يعني أن هذا هو\nالطول الذي سنوقفه. نظرًا لأن الدبوس تمت تهيئته\nعلى السلسلة الفارغة، فإننا نبدأ بالطول صفر. الآن نحتاج فقط إلى البحث\nعن كيفية تحديث الدبوس داخل جسم الحلقة. بيان المهمة هنا، يبدو أنه يقوم بتسلسل\nرقم جديد على الدبوس في كل تكرار، وبالتالي فإن طول الدبوس\nسيزيد بمقدار واحد في كل مرة. لذا، إذا بدأنا من الصفر،\nوتوقفنا عندما نصل إلى أربعة، وزدنا بمقدار واحد، فستتكرر هذه الحلقة أربع مرات. الآن دعونا نتحقق مرة أخرى من هذا العمل من خلال تتبع التنفيذ الكامل. كالعادة، يبدأ الكمبيوتر بالتنفيذ عند السطر الأول من البرنامج. لدينا هنا بيان استيراد، لذلك ينطلق الكمبيوتر\nويقوم بتحميل كود الوحدة العشوائية في ذاكرته.  يقوم هذا الخط بتهيئة الدبوس المتغير. ينتقل الكمبيوتر إلى\nذاكرته قصيرة المدى، ويخصص قطعة جديدة، ويخزن القيمة، والسلسلة الفارغة هناك، ثم يضع علامة عليها باستخدام دبوس الاسم. في السطر التالي،\nوصلنا الآن إلى حلقة while، لذا يقوم الكمبيوتر بتقييم\nحالة الحلقة.  يحتوي الدبوس المتغير حاليًا على\nقيمة السلسلة الفارغة، وبالتالي فإن طول الدبوس هو صفر. الصفر أقل من أربعة، لذلك يتم تقييم حالة الحلقة على أنها صحيحة. ولأن هذا صحيح، يستمر الكمبيوتر في\nتنفيذ نص الحلقة. نص الحلقة هو أي أسطر من التعليمات البرمجية مخصصة داخل الحلقة. لذا فإن السطر التالي الذي يجب تنفيذه هو بيان تخصيص الأرقام. نقوم بتقييم الجانب الأيمن من بيان المهمة أولاً، والذي يستدعي دالة randint.  يقوم Randint بإنشاء\nرقم عشوائي بين هذين الحدين. يحدث هذا بشكل عشوائي، لذلك سيتغير عند كل\nتشغيل للبرنامج، لكن لنفترض أنه يُرجع صفرًا هذه المرة. هذه هي المرة الأولى التي\nنقوم فيها بتعيين رقم، لذلك يقوم الكمبيوتر بإنشاء متغير جديد. ثم ننتقل. نظرًا لأن هذا الخط به مسافة بادئة، فإنه لا يزال داخل الحلقة أثناء ذلك، لذلك هذا هو السطر التالي من جسم الحلقة. نقوم بتبسيط\nالجانب الأيمن من المهمة أولًا، لذلك نعوض بالرقم،\nوهو العدد الصحيح صفر، ونرسله إلى سلسلة،\nحتى نحصل على السلسلة صفر. ثم نستبدل الدبوس،\nوهو السلسلة الفارغة، ونقوم بالتسلسل معًا. نقوم بتخزين هذه القيمة مرة أخرى\nفي الطرف المتغير، متجاوزين القيمة السابقة. أي سطر ينفذ بعد ذلك؟ لم يتم وضع مسافة بادئة لبيان الطباعة هذا، لذا يتم اعتباره خارج الحلقة. إنه ليس جزءًا من جسم الحلقة، وهذا يعني أننا في الجزء\nالسفلي من الحلقة، لذلك ينتقل الكمبيوتر إلى التنفيذ\nمرة أخرى إلى أعلى الحلقة ويتحقق من حالة الحلقة مرة أخرى. نعوض بقيمة الدبوس، والتي أصبحت الآن السلسلة صفر. نحن نأخذ الطول، وهو واحد، وواحد أقل من أربعة، لذلك\nلا يزال تقييم حالة الحلقة صحيحًا. وهذا يعني أننا نقوم بتنفيذ\nجسم الحلقة مرة أخرى لتكرار ثانٍ. نقوم بإنشاء رقم عشوائي جديد،\nلنفترض خمسة هذه المرة، ونخصصه لرقم، ثم نقوم بتحديث دبوس متغير الحلقة الخاص بنا. يحتوي Pin حاليًا على القيمة صفر، ثم نقوم بالتسلسل على\nالسلسلة خمسة للحصول على 05. نقوم بتخزين ذلك مرة أخرى في Pin، والآن نحن في\nأسفل الحلقة مرة أخرى. نقفز مرة أخرى إلى أعلى الحلقة، ونتحقق من\nحالة الحلقة للمرة الثالثة. يحتوي Pin الآن على القيمة\n05، لذا فإن طوله هو اثنان، واثنان أقل من أربعة، وبالتالي فإن\nشرط الحلقة صحيح. لذلك نحن ندخل جسم الحلقة مرة أخرى. ننفذ بيان تخصيص الأرقام، لنفترض أننا أنشأنا تسعة هذه المرة، وقمنا بتخزين ذلك في أرقام،\nثم نقوم بتحديث الدبوس. الدبوس حاليًا هو 05. يمكننا التسلسل على التسعة، ثم نقوم بتخزين 059 مرة أخرى. بالعودة إلى أعلى الحلقة، أصبح طول الدبوس الآن ثلاثة. ثلاثة أقل من أربعة، وبالتالي فإن شرط الحلقة لا يزال صحيحا، ونبدأ التكرار الرابع. يُنشئ Randint الرقم خمسة هذه المرة، لذلك نقوم بتخزين ذلك بالأرقام، ثم ننتقل إلى السطر التالي. الدبوس الآن هو 059، يمكننا أن\nنتسلسل على السلسلة رقم خمسة، ونخزن ذلك مرة أخرى في الدبوس. مرة أخرى، نجد أنفسنا\nفي أسفل الحلقة، لذلك نقفز مرة أخرى إلى الأعلى. نعوض بالقيمة الحالية للطرف الذي يبلغ طوله أربعة، إذن شرط الحلقة الآن هو: أربعة أقل من أربعة؟ الذي يقيم إلى خطأ. وهذا يعني أن\nالوقت قد حان أخيرًا لإنهاء الحلقة. نحن نتخطى نص الحلقة ونبحث عن السطر التالي من التعليمات البرمجية الذي لم يتم وضع مسافة بادئة داخل الحلقة. هذا هو بياننا المطبوع هنا. نحن نستبدل قيمة الدبوس، ونسلسل معًا ونطبع تلك الجملة\nعلى وحدة التحكم. وهذا هو السطر الأخير من البرنامج، لذلك ينهي الكمبيوتر التنفيذ، ونرى أن جسم الحلقة قد تم\nتنفيذه بالفعل أربع مرات.",
    "t_italian": "- [Istruttore] Cosa succede esattamente dietro le quinte quando il\ncomputer esegue un ciclo while? Tracciamo un ciclo while\npasso dopo passo per scoprirlo. Prima di iniziare, vediamo\nse riusciamo ad avere un'idea di quante volte questo ciclo si ripete. Per contare le ripetizioni, dobbiamo solo guardare la variabile del ciclo, a quale valore inizia prima del ciclo, a quale valore si ferma per\nterminare il ciclo e con quale valore si aggiorna\nad ogni iterazione del ciclo. Qui vediamo che la nostra variabile del ciclo\nsi chiama pin ed è inizializzata sulla stringa vuota. La condizione del ciclo quindi\ncontrolla la lunghezza del perno della corda e lo confronta con il numero quattro, il che significa che questa è la\nlunghezza alla quale lo fermeremo. Poiché pin è inizializzato\nsu una stringa vuota, inizieremo con lunghezza zero. Ora dobbiamo solo cercare\ncome viene aggiornato il pin all'interno del corpo del loop. L'istruzione di assegnazione qui sembra che stia concatenando\nuna nuova cifra sul pin ad ogni iterazione, quindi la lunghezza del pin\naumenterebbe di uno ogni volta. Quindi, se iniziamo da zero, ci\nfermiamo quando arriviamo a quattro e incrementiamo di uno, questo ciclo si ripeterà quattro volte. Ora ricontrolliamo il lavoro tracciando l'intera esecuzione. Come al solito, l'esecuzione del computer inizia dalla prima riga del programma. Qui abbiamo un'istruzione import, quindi il computer si\nspegne e carica nella sua memoria il codice per il modulo random. Questa riga inizializza il pin variabile. Il computer va nella\nsua memoria a breve termine, alloca un nuovo pezzo, memorizza lì il valore, la stringa vuota, e poi lo contrassegna con il nome pin. Nella riga successiva, ora\nabbiamo raggiunto il ciclo while, quindi il computer valuta\nla condizione del ciclo. La variabile pin attualmente contiene il\nvalore della stringa vuota, quindi la lunghezza del pin è zero. Zero è inferiore a quattro, quindi la condizione del ciclo risulta vera. Poiché è vero, il computer prosegue con l'\nesecuzione del corpo del ciclo. Il corpo del ciclo è costituito da qualsiasi riga di codice destinata all'interno del ciclo. Quindi la riga successiva da eseguire è questa istruzione di assegnazione delle cifre. Valutiamo prima la parte destra dell'istruzione di assegnazione, che richiama la funzione randint. Randint genera un\nnumero casuale compreso tra questi due limiti. Ciò accade in modo casuale, quindi cambierà ad ogni\nesecuzione del programma, ma supponiamo che questa volta restituisca zero. Questa è la prima volta che\nassegniamo una cifra, quindi il computer crea una nuova variabile. Poi andiamo avanti. Poiché questa riga è rientrata, è ancora all'interno del ciclo while, quindi questa è la riga successiva del corpo del ciclo. Semplifichiamo\nprima la parte destra dell'assegnazione, quindi sostituiamo con digit,\nche è l'intero zero, e lo trasformiamo in una stringa,\nin modo da ottenere la stringa zero. Quindi sostituiamo pin,\nche è la stringa vuota, e concateniamo insieme. Memorizziamo quel valore\nnella variabile pin, sovrascrivendo il valore precedente. Quale riga verrà eseguita dopo? Questa istruzione print non è rientrata, quindi è considerata fuori dal ciclo. Non fa parte del corpo del ciclo, ciò significa che siamo\nalla fine del ciclo, quindi il computer riporta l'esecuzione\nall'inizio del ciclo e controlla nuovamente la condizione del ciclo. Sostituiamo il valore di pin, che ora è la stringa zero. Prendiamo la lunghezza, che è uno, uno è inferiore a quattro, quindi la condizione del ciclo\nrisulta comunque vera. Ciò significa che stiamo eseguendo\nnuovamente il corpo del loop per una seconda iterazione. Generiamo un nuovo numero casuale,\ndiciamo cinque questa volta, lo assegniamo a digit e quindi aggiorniamo la nostra variabile del loop pin. Pin attualmente contiene il valore zero, quindi concateniamo\nla stringa cinque per ottenere 05. Lo memorizziamo nuovamente in pin e ora siamo di\nnuovo alla fine del ciclo. Torniamo all'inizio del ciclo e controlliamo la\ncondizione del ciclo per la terza volta.  Il pin ora contiene il valore\n05, quindi la sua lunghezza è due, due è meno quattro, quindi la\ncondizione del ciclo è vera. Quindi stiamo entrando di nuovo nel corpo del loop. Eseguiamo l'istruzione di assegnazione delle cifre, diciamo che questa volta ne generiamo nove, lo memorizziamo in digit\ne quindi aggiorniamo il pin.  Il pin è attualmente 05. Possiamo concatenare il nove e poi memorizziamo 059. Tornando all'inizio del ciclo, la lunghezza del pin ora è tre. Tre è minore di quattro, quindi la condizione del ciclo è ancora vera e iniziamo la quarta iterazione. Randint genera un cinque questa volta, quindi lo memorizziamo in digit e poi passiamo alla riga successiva. Il pin ora è 059, possiamo\nconcatenarlo sulla stringa cinque e memorizzarlo nuovamente nel pin.  Ancora una volta ci troviamo\nalla fine del giro, quindi torniamo all'inizio. Sostituiamo il valore corrente del pin, che ha lunghezza quattro, quindi ora la nostra condizione di loop è quattro meno di quattro? che restituisce falso. Ciò significa che è finalmente giunto il\nmomento di terminare il ciclo. Saltiamo il corpo del loop e cerchiamo la riga di codice successiva che non sia rientrata all'interno del loop. Questa è la nostra dichiarazione stampata qui. Sostituiamo il valore di pin, concateniamo insieme e stampiamo quella frase\nsulla console. E questa è l'ultima riga del programma, quindi il computer termina l'esecuzione e vediamo che il corpo del nostro ciclo è stato\neffettivamente eseguito quattro volte."
}