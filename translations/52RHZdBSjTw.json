{
    "source": "52RHZdBSjTw",
    "youtubelink": "https://www.youtube.com/watch?v=52RHZdBSjTw",
    "t_english": "- [Instructor] When we run a program, the computer executes each instruction line by line. Then, when it finishes with an instruction, it clears out its working memory. So, the computer has forgotten what it just did by the time it gets to the next line. But what if we want to remember the result of a calculation across lines? We need a way to tell the computer, \"Hey, remember the result of this instruction this time. I'm gonna need this value later.\" To do that, we use variables. A variable is a reserved location in the computer's memory for storing a value. We associate each location with a name, so it's easy for us as the programmers to refer to a specific location later. We can also update the value that a specific name points to over time. Because we have a name, we can ask the computer questions like, \"What value do you have stored at location view_count right now?\" To create a new variable or update the value stored in an existing variable, we'll use an assignment statement. An assignment statement starts with the name of the variable on the left hand side. Then an equal sign, also called the assignment operator. And on the right hand side, the value to be stored. We read this statement as the variable view_count is assigned the value 324. When the computer executes this instruction, it'll go off to its short-term memory and look for a label with the name view_count. If it doesn't find one, it'll set aside or allocate a new chunk of its memory and then label that location with the name view_count. Finally, it'll store the value on the right hand side of the assignment operator in that location. If it does find that label, it will allocate a new chunk of memory, store the new value there, and take that label from the old location and move it to point to the new location. That old location is now unreachable. There's no way for you as the programmer to ask about that location in memory anymore because it doesn't have a name. There's no need for the computer to keep this around, so it just erases it. Anytime we wanna access the value stored at a location, we can ask the computer to retrieve it by giving it the name. For example, if I had the instruction print (view_count), the computer would go find the memory location view_count, grab the value stored there and substitute it in. So, this would print 324. Remember, instructions in a program execute in order, so the value stored in a certain variable might be different at different points in the program. For example, after the first line executes, the location view_count contains the value 324. But after the third line executes, the location view_count now contains the value 501. So, when I access view_count on line 2, this prints 324. But when I access view_count on line 4, this prints 501. Note that after line 4, when the program terminates, the computer clears out all these locations in memory. That means the next time you're on the program, the computer starts fresh again. You can think of variables like mini whiteboards. When you create a new variable, you go off and get a new whiteboard. You give that whiteboard a name, and then you write a value on it to store it there. You can create a hundred variables, which means you went off and got a hundred different whiteboards. And if you wanna know what value is stored on a specific whiteboard named color_theme, then you look for the label color_theme, grab that whiteboard and look at the value written on it. If you have a second or third assignment statement for the same variable color_theme, the computer doesn't go off and grab a new whiteboard 'cause then it would have two whiteboards labeled color_theme, and that's confusing. Instead, it grabs the existing whiteboard named color_theme, erases the old value on the front, and then in its place writes down the new value. When the program terminates, we erase all the whiteboards, peel the labels off the back, and put them neatly back on the shelf where we found them, so they're nice and clean for the next program execution to use. How might we use variables in a real program? Say, we're building a game. What data might we need to keep track of? Well, we might need to remember the player's current score, what level they're on, and what character they selected. As the program runs, we'll need to update these values over time. Like, maybe when the player collects an item, their score increases by 5. If we wanna be able to ask the computer what's the player's current score at any point in the program, we need to tell the computer to store that value in a variable. Some games might have hundreds or thousands of different pieces of data that they need to keep track of, which means hundreds or thousands of different variables. Think closely about a piece of technology you use every day like an app or a game or an appliance in your house. What data is it keeping track of? What variables might it have? As you learn to think like a programmer, you'll start seeing variables everywhere. \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n",
    "t_urdu": "- [انسٹرکٹر] جب ہم کسی پروگرام کو چلاتے ہیں، تو کمپیوٹر ہر\nانسٹرکشن لائن کو بذریعہ لائن چلاتا ہے۔ پھر، جب یہ\nکسی ہدایت کے ساتھ ختم ہوتا ہے، تو یہ اپنی ورکنگ میموری کو صاف کرتا ہے۔ لہذا، کمپیوٹر\nبھول گیا ہے کہ اس نے ابھی کیا کیا تھا جب تک وہ اگلی لائن پر پہنچتا ہے۔ لیکن کیا ہوگا اگر ہم لکیروں میں حساب کتاب کا نتیجہ یاد رکھنا چاہتے ہیں؟ ہمیں کمپیوٹر کو بتانے کا ایک طریقہ درکار ہے، \"ارے،\nاس بار اس ہدایت کا نتیجہ یاد رکھیں۔ مجھے بعد میں اس قدر کی ضرورت ہوگی۔\" ایسا کرنے کے لیے، ہم متغیرات استعمال کرتے ہیں۔ ایک متغیر کسی قدر کو ذخیرہ کرنے کے لیے کمپیوٹر کی میموری میں ایک محفوظ مقام ہے۔\n ہم ہر مقام کو ایک نام کے ساتھ جوڑتے ہیں، اس لیے پروگرامرز کے لیے بعد میں کسی مخصوص مقام کا حوالہ دینا ہمارے لیے آسان ہے۔ ہم اس قدر کو بھی اپ ڈیٹ کر سکتے ہیں جس کی طرف ایک مخصوص نام وقت کے ساتھ اشارہ کرتا ہے۔ چونکہ ہمارے پاس ایک نام ہے، اس لیے ہم کمپیوٹر سے سوالات پوچھ سکتے ہیں جیسے، \"اس وقت آپ نے لوکیشن view_count پر کون سی قیمت ذخیرہ کی ہے؟\" ایک نیا متغیر بنانے یا موجودہ متغیر میں ذخیرہ شدہ قدر کو اپ ڈیٹ کرنے کے لیے،\n ہم ایک اسائنمنٹ اسٹیٹمنٹ استعمال کریں گے۔ ایک اسائنمنٹ اسٹیٹمنٹ بائیں جانب متغیر کے نام سے شروع ہوتا ہے۔\n پھر ایک مساوی نشان، جسے\nاسائنمنٹ آپریٹر بھی کہا جاتا ہے۔ اور دائیں طرف،\nذخیرہ کرنے کی قدر۔ ہم اس بیان کو پڑھتے ہیں کیونکہ ویری ایبل view_count کو\nویلیو 324 تفویض کی گئی ہے۔ جب کمپیوٹر\nاس ہدایات پر عمل کرتا ہے، تو یہ اپنی شارٹ ٹرم میموری پر چلا جائے گا اور view_count نام کے ساتھ ایک لیبل تلاش کرے گا۔\n اگر اسے کوئی نہیں ملتا ہے، تو یہ\nاپنی میموری کا ایک نیا حصہ الگ کر دے گا یا مختص کر دے گا اور پھر اس مقام کو\nview_count کے نام سے لیبل کر دے گا۔ آخر میں، یہ\n \nاس مقام پر اسائنمنٹ آپریٹر کے دائیں جانب ویلیو کو اسٹور کرے گا۔ اگر اسے وہ لیبل مل جاتا ہے، تو یہ میموری کا ایک نیا حصہ مختص کرے گا، وہاں نئی ​​قدر ذخیرہ کرے گا، اور اس لیبل کو پرانے مقام سے لے جائے گا اور اسے نئے مقام کی طرف اشارہ کرنے کے لیے لے جائے گا۔ وہ پرانا مقام اب ناقابل رسائی ہے۔ بطور پروگرامر آپ کے لیے میموری میں اس مقام کے بارے میں پوچھنے کا کوئی طریقہ نہیں ہے\n کیونکہ اس کا کوئی نام نہیں ہے۔ \nکمپیوٹر کو اس کے ارد گرد رکھنے کی ضرورت نہیں ہے، لہذا یہ صرف اسے مٹا دیتا ہے۔ جب بھی ہم\nکسی مقام پر ذخیرہ شدہ قدر تک رسائی حاصل کرنا چاہتے ہیں، ہم کمپیوٹر سے اسے نام دے کر اسے بازیافت کرنے کے لیے کہہ سکتے ہیں۔ مثال کے طور پر، اگر میرے پاس\nانسٹرکشن پرنٹ (view_count) ہو، تو کمپیوٹر\nمیموری لوکیشن view_count تلاش کرے گا، وہاں ذخیرہ شدہ ویلیو کو پکڑے گا\nاور اس کی جگہ لے گا۔ اس طرح، یہ 324 پرنٹ کرے گا۔ یاد رکھیں، پروگرام میں ہدایات\nترتیب سے چلتی ہیں، لہذا ایک مخصوص متغیر میں ذخیرہ شدہ قدر پروگرام کے مختلف مقامات پر مختلف ہو سکتی ہے۔\n مثال کے طور پر،\nپہلی لائن کے مکمل ہونے کے بعد، لوکیشن view_count میں\nویلیو 324 ہوتی ہے۔ لیکن تیسری لائن کے مکمل ہونے کے بعد، لوکیشن view_count میں\nاب ویلیو 501 ہوتی ہے۔ لہذا، جب میں\nلائن 2 پر view_count تک رسائی کرتا ہوں تو یہ 324 پرنٹ کرتا ہے۔ لیکن جب میں  لائن 4 پر view_count تک رسائی حاصل کریں\n، یہ 501 پرنٹ کرتا ہے۔ نوٹ کریں کہ لائن 4 کے بعد،\nجب پروگرام ختم ہوتا ہے، کمپیوٹر\nمیموری میں ان تمام مقامات کو صاف کرتا ہے۔ اس کا مطلب ہے کہ اگلی بار جب\nآپ پروگرام پر ہوں گے، کمپیوٹر دوبارہ تازہ شروع ہو جائے گا۔ آپ منی وائٹ بورڈز جیسے متغیرات کے بارے میں سوچ سکتے ہیں۔\n جب آپ نیا متغیر بناتے ہیں، تو آپ چلے جاتے ہیں اور ایک نیا وائٹ بورڈ حاصل کرتے ہیں۔ آپ اس وائٹ بورڈ کو ایک نام دیتے ہیں، اور پھر آپ\nاسے وہاں ذخیرہ کرنے کے لیے اس پر ایک قدر لکھتے ہیں۔ آپ سو متغیرات بنا سکتے ہیں\n، جس کا مطلب ہے کہ آپ چلے گئے اور سو مختلف وائٹ بورڈز ملے۔ اور اگر آپ یہ جاننا چاہتے ہیں کہ کلر_تھیم نامی مخصوص وائٹ بورڈ پر کون سی ویلیو محفوظ ہے،\n تو آپ رنگ_تھیم کا لیبل تلاش کریں، اس وائٹ بورڈ کو پکڑیں ​​اور\nاس پر لکھی ہوئی قدر کو دیکھیں۔ اگر آپ کے پاس ایک ہی متغیر کلر_تھیم کے لیے دوسرا یا\nتیسرا اسائنمنٹ اسٹیٹمنٹ ہے، تو کمپیوٹر بند نہیں ہوتا\nاور ایک نیا وائٹ بورڈ نہیں پکڑتا 'کیونکہ پھر اس میں رنگ_تھیم کے لیبل والے دو وائٹ بورڈز ہوں گے، اور یہ الجھن کا باعث ہے۔  اس کے بجائے، یہ\ncolor_theme نامی موجودہ وائٹ بورڈ کو پکڑتا ہے، سامنے کی پرانی قدر کو مٹا دیتا ہے، اور پھر اس کی جگہ\nنئی قدر لکھ دیتا ہے۔ پروگرام ختم ہونے پر،\nہم تمام وائٹ بورڈز کو مٹا دیتے ہیں، لیبلز کو پیچھے سے چھیل دیتے ہیں، اور انہیں صفائی کے ساتھ واپس شیلف پر رکھ دیتے ہیں\nجہاں ہم نے انہیں پایا، تاکہ اگلے پروگرام کے استعمال کے لیے وہ اچھے اور صاف ہوں۔ ہم\nایک حقیقی پروگرام میں متغیرات کو کیسے استعمال کر سکتے ہیں؟ کہو، ہم ایک کھیل بنا رہے ہیں۔ ہمیں کس ڈیٹا پر نظر رکھنے کی ضرورت ہو سکتی ہے؟ ٹھیک ہے، ہمیں\nکھلاڑی کے موجودہ سکور، وہ کس سطح پر ہیں، اور\nانہوں نے کون سا کردار منتخب کیا ہے، یہ یاد رکھنے کی ضرورت ہو سکتی ہے۔ جیسے جیسے پروگرام چلتا ہے، ہمیں وقت کے ساتھ ساتھ ان اقدار کو اپ ڈیٹ کرنے کی ضرورت ہوگی۔\n جیسے، ہو سکتا ہے کہ جب\nکھلاڑی کسی چیز کو اکٹھا کرتا ہے، تو اس کا سکور 5 تک بڑھ جاتا ہے۔ اگر ہم کمپیوٹر سے یہ پوچھنا چاہتے ہیں کہ پروگرام میں کسی بھی وقت کھلاڑی کا موجودہ سکور کیا ہے، تو ہمیں کمپیوٹر کو بتانا ہوگا کہ وہ اس قدر کو متغیر میں محفوظ کرے۔  . کچھ گیمز میں\nسینکڑوں یا ہزاروں مختلف ڈیٹا ہوتے ہیں\nجن کا انہیں ٹریک رکھنے کی ضرورت ہوتی ہے، جس کا مطلب ہے سینکڑوں یا\nہزاروں مختلف متغیرات۔  ٹکنالوجی کے اس ٹکڑے کے بارے میں باریک بینی سے سوچیں جو\nآپ ہر روز استعمال کرتے ہیں جیسے ایپ یا گیم یا\nاپنے گھر میں کوئی سامان۔ یہ کس ڈیٹا کو ٹریک کر رہا ہے؟  اس میں کیا متغیرات ہوسکتے ہیں؟ جیسے جیسے آپ ایک پروگرامر کی طرح سوچنا سیکھیں گے، آپ کو ہر جگہ متغیرات نظر آنے لگیں گے۔",
    "t_spanish": "- [Instructor] Cuando ejecutamos un programa, la computadora ejecuta cada\ninstrucción línea por línea. Luego, cuando termina\ncon una instrucción, borra su memoria de trabajo. Entonces, la computadora ha\nolvidado lo que acaba de hacer cuando llega a la siguiente línea. Pero ¿qué pasa si queremos recordar el resultado de un cálculo entre líneas? Necesitamos una forma de decirle a la computadora: \"Oye, esta vez recuerda el resultado de\nesta instrucción. Necesitaré este valor más adelante\". Para hacer eso, usamos variables. Una variable es una ubicación reservada en la memoria de la computadora\npara almacenar un valor. Asociamos cada ubicación con un nombre, por lo que es fácil para nosotros, como programadores, referirnos a una ubicación específica más adelante. También podemos actualizar el valor al que apunta un nombre específico con el tiempo. Como tenemos un nombre, podemos hacerle a la computadora preguntas como: \"¿Qué valor tienes almacenado en la ubicación view_count en este momento?\" Para crear una nueva variable o actualizar el valor almacenado\nen una variable existente, usaremos una declaración de asignación. Una declaración de asignación comienza con el nombre de la variable\nen el lado izquierdo. Luego un signo igual, también\nllamado operador de asignación. Y en el lado derecho,\nel valor a almacenar. Leemos esta declaración cuando a la variable view_count se le\nasigna el valor 324. Cuando la computadora\nejecuta esta instrucción, irá a su memoria a corto plazo y buscará una etiqueta\ncon el nombre view_count. Si no encuentra uno, reservará o asignará\nuna nueva porción de su memoria y luego etiquetará esa ubicación\ncon el nombre view_count. Finalmente, almacenará el\nvalor en el lado derecho del\noperador de asignación en esa ubicación. Si encuentra esa etiqueta, asignará una nueva porción de memoria, almacenará el nuevo valor allí, tomará esa etiqueta de la ubicación anterior y la moverá para que apunte a la nueva ubicación. Esa antigua ubicación ahora es inalcanzable.  Ya no hay forma de que usted, como programador, pregunte sobre esa\nubicación en la memoria porque no tiene nombre. No es necesario que la\ncomputadora guarde esto, por lo que simplemente lo borra. Cada vez que queramos acceder al\nvalor almacenado en una ubicación, podemos pedirle a la computadora que lo recupere dándole el nombre. Por ejemplo, si tuviera la\ninstrucción print (view_count), la computadora buscaría la\nubicación de la memoria view_count, tomaría el valor almacenado\nallí y lo sustituiría. Entonces, esto imprimiría 324. Recuerde, las instrucciones en\nun programa se ejecutan en orden, por lo que el valor almacenado en una determinada variable puede ser diferente en diferentes\npuntos del programa. Por ejemplo, después de que\nse ejecuta la primera línea, la ubicación view_count\ncontiene el valor 324. Pero después de que se ejecuta la tercera línea, la ubicación view_count\nahora contiene el valor 501. Entonces, cuando accedo a view_count\nen la línea 2, esto imprime 324. Pero cuando  acceda a view_count\nen la línea 4, esto imprime 501. Tenga en cuenta que después de la línea 4,\ncuando el programa termina, la computadora borra todas\nestas ubicaciones en la memoria. Eso significa que la próxima vez que\nesté en el programa, la computadora comenzará de nuevo. Puedes pensar en variables\ncomo mini pizarras. Cuando creas una nueva variable, sales y obtienes una nueva pizarra.  Le das un nombre a esa pizarra y luego escribes un valor\nen ella para almacenarla allí. Puedes crear cien\nvariables, lo que significa que saliste y obtuviste cien pizarras diferentes. Y si desea saber qué valor está almacenado en una pizarra específica\nllamada color_theme, busque la etiqueta color_theme, tome esa pizarra y observe\nel valor escrito en ella. Si tiene una segunda o\ntercera declaración de asignación para la misma variable color_theme, la computadora no se apaga\ny toma una nueva pizarra porque entonces tendría dos pizarras etiquetadas color_theme, y eso es confuso. En su lugar, toma la\npizarra existente llamada color_theme, borra el valor anterior en el frente y luego, en su lugar,\nescribe el nuevo valor. Cuando el programa termina,\nborramos todas las pizarras, quitamos las etiquetas de la parte posterior y las colocamos ordenadamente nuevamente en\nel estante donde las encontramos, para que estén bonitas y limpias para usar en la siguiente ejecución del programa.  ¿ Cómo podríamos usar variables\nen un programa real? Digamos que estamos construyendo un juego.  ¿ Qué datos podríamos necesitar para realizar un seguimiento? Bueno, es posible que necesitemos recordar\nla puntuación actual del jugador, en qué nivel se encuentra y\nqué personaje seleccionó. A medida que se ejecuta el programa, necesitaremos actualizar\nestos valores con el tiempo. Por ejemplo, tal vez cuando el\njugador recolecta un elemento, su puntuación aumenta en 5. Si queremos poder preguntarle a la computadora cuál es la puntuación actual del jugador en cualquier punto del programa, debemos decirle a la computadora que almacene ese valor en una variable.  . Algunos juegos pueden tener\ncientos o miles de datos diferentes\nde los que necesitan realizar un seguimiento, lo que significa cientos o\nmiles de variables diferentes. Piense detenidamente en una pieza de\ntecnología que usa todos los días, como una aplicación, un juego o\nun electrodoméstico en su casa.  ¿De qué datos realiza un seguimiento?  ¿ Qué variables podría tener? A medida que aprenda a pensar como un programador, comenzará a ver variables en todas partes.",
    "t_arabic": "- [المدرس] عندما نقوم بتشغيل برنامج، يقوم الكمبيوتر بتنفيذ كل\nتعليمات سطرًا تلو الآخر. وبعد ذلك، عندما ينتهي\nمن التعليمات، فإنه يقوم بمسح ذاكرته العاملة. لذا، فقد\nنسي الكمبيوتر ما فعله للتو بحلول الوقت الذي وصل فيه إلى السطر التالي. ولكن ماذا لو أردنا أن نتذكر نتيجة العملية الحسابية عبر الخطوط؟ نحتاج إلى طريقة لإخبار الكمبيوتر، \"مرحبًا، تذكر نتيجة\nهذه التعليمات هذه المرة. سأحتاج إلى هذه القيمة لاحقًا.\" للقيام بذلك، نستخدم المتغيرات. المتغير هو مكان محجوز في ذاكرة الكمبيوتر\nلتخزين القيمة. نقوم بربط كل موقع باسم، لذلك يسهل علينا كمبرمجين الإشارة إلى موقع محدد لاحقًا. يمكننا أيضًا تحديث القيمة التي يشير إليها اسم معين بمرور الوقت. نظرًا لأن لدينا اسمًا، يمكننا أن نطرح أسئلة على الكمبيوتر مثل، \"ما القيمة التي قمت بتخزينها في موقع view_count الآن؟\" لإنشاء متغير جديد أو تحديث القيمة المخزنة\nفي متغير موجود، سنستخدم عبارة الإسناد. يبدأ بيان المهمة باسم المتغير\nعلى الجانب الأيسر. ثم علامة يساوي،\nوتسمى أيضًا عامل الإسناد. وعلى الجانب الأيمن\nالقيمة المراد تخزينها. نقرأ هذه العبارة حيث تم\nتعيين القيمة 324 للمتغير view_count. عندما\nينفذ الكمبيوتر هذه التعليمات، سينتقل إلى ذاكرته قصيرة المدى ويبحث عن تسمية\nباسم view_count. إذا لم يعثر على واحدة، فسوف يضع جانبًا أو يخصص\nجزءًا جديدًا من ذاكرته ثم يسمي هذا الموقع\nبالاسم view_count. وأخيرًا، سيتم تخزين\nالقيمة على الجانب الأيمن من\nعامل التعيين في ذلك الموقع. إذا عثر على تلك التسمية، فسوف يخصص جزءًا جديدًا من الذاكرة، ويخزن القيمة الجديدة هناك، ويأخذ تلك التسمية من الموقع القديم وينقلها للإشارة إلى الموقع الجديد. هذا الموقع القديم لا يمكن الوصول إليه الآن. لم يعد من الممكن بالنسبة لك كمبرمج أن تسأل عن هذا\nالموقع في الذاكرة لأنه ليس له اسم. ليست هناك حاجة\nللكمبيوتر للاحتفاظ بهذا، لذا فهو يمحوه فقط. في أي وقت نريد الوصول إلى\nالقيمة المخزنة في موقع ما، يمكننا أن نطلب من الكمبيوتر استردادها عن طريق إعطائها الاسم. على سبيل المثال، إذا قمت\nبطباعة التعليمات (view_count)، فسيبحث الكمبيوتر عن\nموقع الذاكرة view_count، ويلتقط القيمة المخزنة\nهناك ويستبدلها. لذا، سيؤدي هذا إلى طباعة 324. تذكر،\nيتم تنفيذ التعليمات الموجودة في البرنامج بالترتيب، لذا فإن القيمة المخزنة في متغير معين قد تكون مختلفة في\nنقاط مختلفة في البرنامج. على سبيل المثال، بعد\nتنفيذ السطر الأول، يحتوي موقع view_count على\nالقيمة 324. ولكن بعد تنفيذ السطر الثالث، يحتوي موقع view_count\nالآن على القيمة 501. لذا، عندما أقوم بالوصول إلى view_count\nفي السطر 2، فإن هذا يطبع 324. ولكن عندما أقوم بالوصول إلى view_count في السطر 2، فإن هذا يطبع 324. قم بالوصول إلى view_count\nفي السطر 4، وهذا يطبع 501. لاحظ أنه بعد السطر 4،\nعندما ينتهي البرنامج، يقوم الكمبيوتر بمسح كل\nهذه المواقع في الذاكرة. وهذا يعني أنه في المرة التالية التي\nتستخدم فيها البرنامج، سيبدأ الكمبيوتر من جديد مرة أخرى. يمكنك التفكير في متغيرات\nمثل السبورات البيضاء الصغيرة. عندما تقوم بإنشاء متغير جديد، فإنك تنطلق وتحصل على لوحة معلومات جديدة.  قم بتسمية هذه السبورة البيضاء، ثم اكتب قيمة\nعليها لتخزينها هناك. يمكنك إنشاء مائة\nمتغير، مما يعني أنك حصلت على مائة لوحة بيضاء مختلفة. وإذا كنت تريد معرفة القيمة المخزنة على لوحة معلومات محددة\nتسمى color_theme، فابحث عن التسمية color_theme، وامسك تلك اللوحة البيضاء وانظر\nإلى القيمة المكتوبة عليها. إذا كان لديك\nبيان مهمة ثانية أو ثالثة لنفس المتغير color_theme، فلن يبدأ الكمبيوتر\nويلتقط لوحة معلومات جديدة لأنه سيكون به لوحتين معلومات يحملان اسم color_theme، وهذا أمر محير. بدلاً من ذلك، فإنه يلتقط السبورة\nالبيضاء الموجودة المسماة color_theme، ويمسح القيمة القديمة من المقدمة، ثم\nيكتب القيمة الجديدة في مكانها. عندما ينتهي البرنامج،\nنقوم بمسح جميع ألواح المعلومات، ونزيل الملصقات من الخلف، ونعيدها بشكل أنيق إلى\nالرف حيث وجدناها، بحيث تكون جميلة ونظيفة لاستخدامها في تنفيذ البرنامج التالي. كيف يمكننا استخدام المتغيرات\nفي برنامج حقيقي؟ لنفترض أننا نبني لعبة. ما هي البيانات التي قد نحتاج لتتبعها؟ حسنًا، قد نحتاج إلى تذكر\nالنتيجة الحالية للاعب، والمستوى الذي وصل إليه،\nوالشخصية التي اختارها. أثناء تشغيل البرنامج، سنحتاج إلى تحديث\nهذه القيم بمرور الوقت. مثلًا، ربما عندما\nيجمع اللاعب عنصرًا ما، تزيد درجاته بمقدار 5. إذا أردنا أن نكون قادرين على سؤال الكمبيوتر عن النتيجة الحالية للاعب في أي وقت في البرنامج، نحتاج إلى إخبار الكمبيوتر بتخزين هذه القيمة في متغير  . قد تحتوي بعض الألعاب على\nمئات أو آلاف الأجزاء المختلفة من البيانات\nالتي تحتاج إلى تتبعها، وهو ما يعني مئات أو\nآلاف المتغيرات المختلفة. فكر جيدًا في قطعة من\nالتكنولوجيا التي تستخدمها كل يوم مثل تطبيق أو لعبة أو\nجهاز في منزلك. ما هي البيانات التي يتم تتبعها؟ ما هي المتغيرات التي قد يكون لها؟ عندما تتعلم التفكير كمبرمج، ستبدأ في رؤية المتغيرات في كل مكان.",
    "t_italian": "- [Istruttore] Quando eseguiamo un programma, il computer esegue ogni\nistruzione riga per riga. Quindi, quando termina\ncon un'istruzione, cancella la sua memoria di lavoro. Quindi, il computer ha\ndimenticato quello che ha appena fatto quando arriva alla riga successiva. Ma cosa succede se vogliamo ricordare il risultato di un calcolo su più righe? Abbiamo bisogno di un modo per dire al computer: \"Ehi, ricorda il risultato di\nquesta istruzione questa volta. Avrò bisogno di questo valore più tardi\". Per fare ciò, utilizziamo le variabili. Una variabile è una posizione riservata nella memoria del computer\nper archiviare un valore. Associamo ogni posizione a un nome, quindi è facile per noi programmatori fare riferimento a una posizione specifica in seguito. Possiamo anche aggiornare il valore a cui punta un nome specifico nel tempo. Poiché abbiamo un nome, possiamo porre al computer domande del tipo: \"Quale valore hai memorizzato nella posizione view_count in questo momento?\" Per creare una nuova variabile o aggiornare il valore memorizzato\nin una variabile esistente, utilizzeremo un'istruzione di assegnazione. Un'istruzione di assegnazione inizia con il nome della variabile\nsul lato sinistro. Poi un segno di uguale,\nchiamato anche operatore di assegnazione. E sul lato destro,\nil valore da memorizzare. Leggiamo questa istruzione poiché alla variabile view_count\nè assegnato il valore 324. Quando il computer\nesegue questa istruzione, andrà nella sua memoria a breve termine e cercherà un'etichetta\ncon il nome view_count. Se non ne trova uno, metterà da parte o allocherà\nuna nuova parte della sua memoria e quindi etichetterà quella posizione\ncon il nome view_count. Infine, memorizzerà il\nvalore sul lato destro dell'operatore di assegnazione\nin quella posizione. Se trova quell'etichetta, allocherà una nuova porzione di memoria, memorizzerà lì il nuovo valore, prenderà quell'etichetta dalla vecchia posizione e la sposterà in modo che punti alla nuova posizione. Quella vecchia posizione ora è irraggiungibile. Non c'è più modo per te come programmatore di chiedere informazioni su quella\nposizione nella memoria perché non ha un nome. Non è necessario che il\ncomputer lo conservi, quindi lo cancella e basta. Ogni volta che vogliamo accedere al\nvalore memorizzato in una posizione, possiamo chiedere al computer di recuperarlo dandogli il nome. Ad esempio, se avessi l'\nistruzione print (view_count), il computer troverebbe la\nposizione di memoria view_count, prenderebbe il valore memorizzato\nlì e lo sostituirebbe. Quindi, stamperebbe 324. Ricorda, le istruzioni in\nun programma vengono eseguite in ordine, quindi il valore memorizzato in una determinata variabile potrebbe essere diverso in diversi\npunti del programma. Ad esempio, dopo l'\nesecuzione della prima riga, la posizione view_count\ncontiene il valore 324. Ma dopo l'esecuzione della terza riga, la posizione view_count\nora contiene il valore 501. Quindi, quando accedo a view_count\nsulla riga 2, viene stampato 324. Ma quando  accedi a view_count\nalla riga 4, verrà stampato 501. Nota che dopo la riga 4,\nquando il programma termina, il computer cancella tutte\nqueste posizioni in memoria. Ciò significa che la prossima volta che\nutilizzerai il programma, il computer si riavvierà di nuovo. Puoi pensare a variabili\ncome mini lavagne. Quando crei una nuova variabile, vai e ottieni una nuova lavagna. Dai un nome a quella lavagna e poi scrivi un valore\nsu di essa per memorizzarla lì. Puoi creare un centinaio di\nvariabili, il che significa che sei partito e hai ottenuto un centinaio di lavagne diverse. E se vuoi sapere quale valore è memorizzato su una lavagna specifica\ndenominata color_theme, cerca l'etichetta color_theme, prendi quella lavagna e guarda\nil valore scritto su di essa. Se hai una seconda o\nterza istruzione di assegnazione per la stessa variabile color_theme, il computer non si spegne\ne prende una nuova lavagna perché avrebbe due lavagne etichettate color_theme, e questo crea confusione. Invece, prende la\nlavagna esistente denominata color_theme, cancella il vecchio valore sulla parte anteriore e quindi al suo posto\nscrive il nuovo valore. Quando il programma termina,\ncancelliamo tutte le lavagne, stacchiamo le etichette dal retro e le rimettiamo ordinatamente sullo\nscaffale dove le abbiamo trovate, in modo che siano belle e pulite da utilizzare per la successiva esecuzione del programma. Come potremmo usare le variabili\nin un programma reale? Diciamo che stiamo costruendo un gioco.  Di quali dati potremmo aver bisogno di tenere traccia? Bene, potremmo aver bisogno di ricordare\nil punteggio attuale del giocatore, a che livello si trova e\nquale personaggio ha selezionato. Durante l'esecuzione del programma, dovremo aggiornare\nquesti valori nel tempo. Ad esempio, quando il\ngiocatore raccoglie un oggetto, il suo punteggio aumenta di 5. Se vogliamo poter chiedere al computer qual è il punteggio attuale del giocatore in qualsiasi punto del programma, dobbiamo dire al computer di memorizzare quel valore in una variabile  . Alcuni giochi potrebbero avere\ncentinaia o migliaia di dati diversi\ndi cui tenere traccia, il che significa centinaia o\nmigliaia di variabili diverse. Pensa attentamente a un dispositivo\ntecnologico che usi ogni giorno come un'app, un gioco o\nun elettrodomestico di casa.  Di quali dati tiene traccia? Quali variabili potrebbe avere? Man mano che impari a pensare come un programmatore, inizierai a vedere variabili ovunque."
}