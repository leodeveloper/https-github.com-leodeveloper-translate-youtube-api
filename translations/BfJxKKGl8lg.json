{
    "source": "BfJxKKGl8lg",
    "youtubelink": "https://www.youtube.com/watch?v=BfJxKKGl8lg",
    "t_english": "- [Instructor] If you were building a bike, you would probably go off and get a seat, a set of handlebars, a set of tires, and then assemble those pieces together. You wouldn't harvest your own rubber and try and forge a tire from scratch. With programming, we do the same. We can reuse components that other people have already built and made available. As programmers, then, our job is to assemble these components in unique and interesting ways, rather than spend time re-solving the same problems over and over again. In Python, programmers can package code that they've written for other people to use in what's called a module. You may also hear them referred to as libraries or packages. A module is essentially just a file of code, generally organized into a set of functions. Modules can quickly up-level what we're able to accomplish in a program, because we can use that functionality without having to understand the details of how that code works. We've used functions written by other people before in the form of built-in functions like print, input, round, length. These are different from modules, because they're loaded into Python by default, we can access the print function anywhere we write Python code. With modules, we have to explicitly import the module into our code first before we can access any of its functions. That's because the computer has limited memory, it doesn't have space to pre-memorize the thousands of modules that are out there in the rare event that we might use a specific one. Instead, it waits for us to tell it that we need a specific module, only then does it bother to go read that file and memorize all those functions for us. To load a module into our program, we use the import statement. This is just the key word, import, followed by the module name. Import statements go at the very top of our program. Then we can access any function defined inside that module with the syntax module name.function name. This tells the computer to look for that function inside that module, and then run that code. Let's take a look at an example built-in module. Here we have the documentation for the math module. The math module provides functions for a lot of common mathematical operations. We see here that we have a function to get the square root of a number, it takes one input, or argument, and returns out the square root. So, if we open up our code editor, we can add an import statement at the top to import the math module, and then we can call the square root function using math.sqrt. Note that if we forgot the import statement, or the proceeding module name dot syntax, we would get a NameError, because the computer wouldn't know where to find the sqrt function. Now that we've imported the math module, we can use any of its other functions in our program, like perm, or factorial, which saves us from having to write code to calculate factorial ourselves. We can take advantage of the many other built-in Python modules, like date, time, random, and unittest, to expand the functionality of our programs. Built-in modules come pre-installed with the Python programming language, so they're available for us to import anywhere we write Python code. There are many other modules out there that have made available for general use, but they don't come pre-installed with Python, we have to download the module code off the internet and install it to make it available to import into our programs. With these modules, we need to be careful about plagiarism. We can't just use any code we want as if it's our own without giving credit to the original creator. Programmers can decide how other people can use their module through a license agreement. Some common licenses, like MIT and Apache, are open source, which means they largely allow anyone to use, modify, or distribute the code as they please. Other licenses may be more restrictive, where they don't allow people to modify the code or use it in commercial projects. As with downloading anything off the internet, we also need to think about security. One, it could just be a virus masquerading as a Python module. And two, that module could have bugs or other security vulnerabilities. We don't have any guarantees from the people who wrote it, so we're using it at our own risk, which ultimately makes any programs we build on top of it vulnerable to the same problems. But note that there are many popular and trusted modules out there, like Pandas for data analysis, Pygame for game development, and TensorFlow for machine learning, that you may find fun to experiment with as you become more comfortable with Python. Just note that the Khan Academy IDE doesn't support downloading arbitrary modules off the internet, for these same security reasons. So, for now, let's stick to the built-in modules, because we still have so much to explore.\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n",
    "t_urdu": "- [انسٹرکٹر] اگر آپ\nموٹر سائیکل بنا رہے تھے، تو شاید آپ اتریں گے اور سیٹ، ہینڈل بار کا ایک سیٹ، ٹائروں کا ایک سیٹ لیں گے، اور پھر ان ٹکڑوں کو ایک ساتھ جوڑیں گے۔ آپ خود ربڑ کی کٹائی نہیں کریں گے اور شروع سے ٹائر بنانے کی کوشش کریں گے۔ پروگرامنگ کے ساتھ، ہم بھی ایسا ہی کرتے ہیں۔ ہم ان اجزاء کو دوبارہ استعمال کر سکتے ہیں جنہیں دوسرے لوگوں نے پہلے ہی\nبنایا اور دستیاب کرایا ہے۔ پروگرامرز کے طور پر، ہمارا کام ان اجزاء کو منفرد اور دلچسپ طریقوں سے جمع کرنا ہے، بجائے اس کے کہ\nانہی مسائل کو بار بار حل کرنے میں وقت گزاریں۔ Python میں، پروگرامرز اس کوڈ کو پیک کر سکتے ہیں جو انہوں نے\nدوسرے لوگوں کے لیے لکھا ہے جس کو ماڈیول کہا جاتا ہے۔ آپ انہیں لائبریریوں یا پیکجز کے نام سے بھی سن سکتے ہیں۔\n ایک ماڈیول بنیادی طور پر\nکوڈ کی صرف ایک فائل ہے، عام طور پر\nافعال کے ایک سیٹ میں ترتیب دیا جاتا ہے۔ ماڈیولز تیزی سے اس سطح کو اوپر لے سکتے ہیں جو ہم\nکسی پروگرام میں پورا کر سکتے ہیں، کیونکہ ہم اس کوڈ کے کام کرنے کی تفصیلات کو سمجھے بغیر اس فعالیت کو استعمال کر سکتے ہیں۔ ہم پہلے دوسرے لوگوں کے لکھے ہوئے فنکشنز کو\n بلٹ ان\nفنکشنز جیسے پرنٹ، ان پٹ، گول، لینتھ کی شکل میں استعمال کر چکے ہیں۔ یہ ماڈیولز سے مختلف ہیں، کیونکہ وہ\nڈیفالٹ طور پر Python میں لوڈ ہوتے ہیں، ہم Python کوڈ لکھتے ہوئے کہیں بھی پرنٹ فنکشن تک رسائی حاصل کر سکتے ہیں۔ ماڈیولز کے ساتھ، ہمیں\nماڈیول کو پہلے اپنے کوڈ میں واضح طور پر درآمد کرنا ہوگا اس سے پہلے کہ ہم اس کے کسی بھی فنکشن تک رسائی حاصل کرسکیں۔ اس کی وجہ یہ ہے کہ کمپیوٹر کی\nمیموری محدود ہے، اس کے پاس ہزاروں ماڈیولز کو پہلے سے حفظ کرنے کی جگہ نہیں ہے \n جو کہ غیر معمولی صورت میں ہم کسی\nمخصوص کو استعمال کر سکتے ہیں۔  اس کے بجائے، یہ ہمارے یہ بتانے کا انتظار کرتا ہے کہ ہمیں ایک مخصوص ماڈیول کی ضرورت ہے، تب ہی یہ\nاس فائل کو پڑھنے اور ہمارے لیے ان تمام افعال کو یاد کرنے کی زحمت کرتا ہے۔ ہمارے پروگرام میں ماڈیول لوڈ کرنے کے لیے، ہم امپورٹ اسٹیٹمنٹ استعمال کرتے ہیں۔ یہ صرف کلیدی لفظ ہے، درآمد، اس کے بعد ماڈیول کا نام آتا ہے۔ درآمدی بیانات\nہمارے پروگرام کے بالکل اوپر جاتے ہیں۔ اس کے بعد ہم اس ماڈیول کے اندر بیان کردہ کسی بھی فنکشن تک رسائی حاصل کر سکتے ہیں\n نحوی ماڈیول name.function نام کے ساتھ۔ یہ کمپیوٹر کو کہتا ہے\nکہ اس ماڈیول کے اندر اس فنکشن کو تلاش کرے، \nاور پھر اس کوڈ کو چلائیں۔ آئیے بلٹ ان ماڈیول کی ایک مثال پر ایک نظر ڈالیں۔\n یہاں ہمارے پاس\nریاضی کے ماڈیول کے لیے دستاویزات ہیں۔ ریاضی کا ماڈیول بہت سارے عام ریاضی کے کاموں کے لیے افعال فراہم کرتا ہے۔\n ہم یہاں دیکھتے ہیں کہ ہمارے پاس نمبر کا مربع جڑ حاصل کرنے کے لیے ایک فنکشن ہے، یہ ایک ان پٹ، یا دلیل لیتا ہے، اور مربع جڑ کو واپس کرتا ہے۔ لہذا، اگر ہم اپنا کوڈ ایڈیٹر کھولتے ہیں، تو ہم ریاضی کے ماڈیول کو درآمد کرنے کے لیے سب سے اوپر ایک درآمدی بیان شامل کر سکتے ہیں، اور پھر ہم\n math.sqrt کا استعمال کرتے ہوئے مربع جڑ فنکشن کو کال کر سکتے ہیں۔ نوٹ کریں کہ اگر ہم\nامپورٹ سٹیٹمنٹ، یا پروسیسنگ ماڈیول کا نام ڈاٹ سنٹیکس بھول گئے، تو ہمیں NameError ملے گا، کیونکہ کمپیوٹر نہیں جانتا تھا کہ sqrt فنکشن کہاں تلاش کرنا ہے۔ اب جب کہ ہم نے ریاضی کا ماڈیول درآمد کر لیا ہے، ہم اپنے پروگرام میں اس کے کسی بھی دوسرے فنکشن کو استعمال کر سکتے ہیں\n، جیسے پرم، یا فیکٹوریل، جو ہمیں خود فیکٹریل کا حساب لگانے کے لیے کوڈ لکھنے سے بچاتا ہے۔ ہم اپنے پروگراموں کی فعالیت کو بڑھانے کے لیے بہت سے دوسرے بلٹ ان Python ماڈیولز، جیسے تاریخ، وقت، بے ترتیب، اور یونٹیسٹ سے فائدہ اٹھا سکتے ہیں۔ \n بلٹ ان ماڈیولز Python پروگرامنگ لینگویج کے ساتھ پہلے سے انسٹال ہوتے ہیں، اس لیے وہ ہمارے لیے دستیاب ہیں جہاں سے ہم Python کوڈ لکھتے ہیں درآمد کر سکتے ہیں۔ وہاں بہت سے دوسرے ماڈیولز موجود ہیں جو عام استعمال کے لیے دستیاب ہیں، لیکن وہ\nPython کے ساتھ پہلے سے انسٹال نہیں ہوتے، ہمیں\nانٹرنیٹ سے ماڈیول کوڈ ڈاؤن لوڈ کرنا پڑتا ہے اور اسے اپنے پروگراموں میں درآمد کرنے کے لیے دستیاب کرنے کے لیے اسے انسٹال کرنا ہوتا ہے۔ ان ماڈیولز کے ساتھ، ہمیں\nسرقہ کے بارے میں محتاط رہنے کی ضرورت ہے۔ ہم اصل تخلیق کار کو کریڈٹ دیئے بغیر کسی بھی کوڈ کا استعمال نہیں کر سکتے\nجیسے ہم چاہتے ہیں۔ \n پروگرامرز فیصلہ کر سکتے ہیں کہ دوسرے\nلوگ لائسنس کے معاہدے کے ذریعے اپنے ماڈیول کو کس طرح استعمال کر سکتے ہیں۔ کچھ عام لائسنس، جیسے MIT\nاور Apache، اوپن سورس ہیں، جس کا مطلب ہے کہ وہ\nکسی کو بھی اپنی مرضی کے مطابق کوڈ استعمال کرنے، اس میں ترمیم کرنے یا تقسیم کرنے کی اجازت دیتے ہیں۔ دوسرے لائسنس زیادہ پابندی والے ہو سکتے ہیں، جہاں وہ\nلوگوں کو کوڈ میں ترمیم کرنے یا اسے تجارتی منصوبوں میں استعمال کرنے کی اجازت نہیں دیتے ہیں۔  انٹرنیٹ سے کسی بھی چیز کو ڈاؤن لوڈ کرنے کی طرح،\n ہمیں سیکیورٹی کے بارے میں بھی سوچنے کی ضرورت ہے۔ ایک، یہ صرف ایک وائرس ہو سکتا ہے جو ازگر کے ماڈیول کے طور پر چھپا ہوا ہو۔ اور دو، اس ماڈیول میں کیڑے یا دیگر حفاظتی خطرات ہو سکتے ہیں۔ ہمارے پاس\nان لوگوں کی طرف سے کوئی گارنٹی نہیں ہے جنہوں نے اسے لکھا ہے، اس لیے ہم اسے اپنے خطرے پر استعمال کر رہے ہیں، جس کی وجہ سے بالآخر\nہم جو بھی پروگرام بناتے ہیں اسے انہی مسائل کا خطرہ لاحق ہو جاتا ہے۔ لیکن نوٹ کریں کہ وہاں بہت سے مشہور اور بھروسہ مند ماڈیولز موجود ہیں، جیسے کہ ڈیٹا کے تجزیہ کے لیے پانڈاس، گیم ڈویلپمنٹ کے لیے Pygame، اور مشین لرننگ کے لیے TensorFlow، جن کے ساتھ تجربہ کرنے میں آپ کو مزہ آئے گا کیونکہ آپ\nPython کے ساتھ زیادہ آرام دہ ہو جائیں گے۔ بس یاد رکھیں کہ خان\nاکیڈمی IDE انہی حفاظتی وجوہات کی بنا پر انٹرنیٹ سے صوابدیدی ماڈیولز کو ڈاؤن لوڈ کرنے کی حمایت نہیں کرتا ہے۔\n تو، ابھی کے لیے، آئیے بلٹ\nان ماڈیولز پر قائم رہیں، کیونکہ ہمارے پاس ابھی بھی بہت کچھ دریافت کرنا ہے۔",
    "t_spanish": "- [Instructor] Si\nestuvieras construyendo una bicicleta, probablemente irías y conseguirías un asiento, un juego de manillares, un juego de neumáticos y luego ensamblarías esas piezas. No cosecharías tu propio caucho e intentarías forjar un neumático desde cero. Con la programación hacemos lo mismo. Podemos reutilizar componentes que otras personas ya han\nconstruido y puesto a disposición. Entonces, como programadores, nuestro trabajo es ensamblar estos componentes de maneras únicas e interesantes, en lugar de perder tiempo\nresolviendo los mismos problemas una y otra vez. En Python, los programadores pueden empaquetar código que han escrito\npara que otras personas lo utilicen en lo que se llama un módulo.  Es posible que también escuche que se hace referencia a ellos\ncomo bibliotecas o paquetes. Un módulo es esencialmente\nun archivo de código, generalmente organizado\nen un conjunto de funciones. Los módulos pueden mejorar rápidamente lo que podemos\nlograr en un programa, porque podemos usar esa funcionalidad sin tener que comprender los detalles de cómo funciona ese código. Hemos usado funciones escritas\npor otras personas antes en forma de\nfunciones integradas como imprimir, ingresar, redondear, longitud. Estos son diferentes de los módulos porque están cargados\nen Python de forma predeterminada, podemos acceder a la función de impresión en cualquier lugar donde escribimos código Python. Con los módulos, primero tenemos que importar explícitamente\nel módulo a nuestro código antes de poder acceder a cualquiera de sus funciones. Esto se debe a que la computadora\ntiene memoria limitada, no tiene espacio para memorizar previamente los miles de módulos\nque existen en el raro caso de que\nutilicemos uno específico. En cambio, espera a que le digamos que necesitamos un módulo específico, sólo entonces se molesta\nen leer ese archivo y memorizar todas esas funciones por nosotros. Para cargar un módulo en nuestro programa, usamos la declaración de importación. Esta es sólo la palabra clave, importar, seguida del nombre del módulo.  Las declaraciones de importación se encuentran en la\nparte superior de nuestro programa. Luego podemos acceder a cualquier función\ndefinida dentro de ese módulo con la sintaxis nombre del módulo.nombre de la función. Esto le dice a la computadora\nque busque esa función dentro de ese módulo\ny luego ejecute ese código. Echemos un vistazo a un\nmódulo integrado de ejemplo. Aquí tenemos la documentación\npara el módulo de matemáticas. El módulo matemático proporciona funciones para muchas\noperaciones matemáticas comunes. Vemos aquí que tenemos una función para obtener la raíz cuadrada de un número, toma una entrada o argumento y devuelve la raíz cuadrada. Entonces, si abrimos nuestro editor de código, podemos agregar una declaración de importación en la parte superior para importar el módulo matemático y luego podemos llamar\na la función de raíz cuadrada usando math.sqrt. Tenga en cuenta que si olvidamos\nla declaración de importación o la sintaxis de puntos del nombre del módulo anterior, obtendríamos un NameError, porque la computadora no sabría dónde encontrar la función sqrt. Ahora que hemos importado el módulo matemático, podemos usar cualquiera de sus otras\nfunciones en nuestro programa, como permanente o factorial, lo que nos ahorra tener que escribir código para calcular el factorial nosotros mismos. Podemos aprovechar muchos otros módulos integrados de Python, como fecha, hora, aleatorio y prueba unitaria, para ampliar la funcionalidad\nde nuestros programas.  Los módulos integrados vienen preinstalados con el lenguaje de programación Python, por lo que están disponibles para que los importemos en cualquier lugar donde escribamos código Python. Hay muchos otros módulos que están disponibles para uso general, pero no vienen\npreinstalados con Python, tenemos que descargar el\ncódigo del módulo de Internet e instalarlo para que esté disponible para importarlo a nuestros programas. Con estos módulos, debemos\ntener cuidado con el plagio. No podemos simplemente usar cualquier código que\nqueramos como si fuera nuestro sin darle crédito\nal creador original. Los programadores pueden decidir cómo otras\npersonas pueden usar su módulo mediante un acuerdo de licencia. Algunas licencias comunes, como MIT\ny Apache, son de código abierto, lo que significa que permiten en gran medida que\ncualquiera use, modifique o distribuya el código como quiera. Otras licencias pueden ser más restrictivas y no permiten que\nlas personas modifiquen el código o lo utilicen en proyectos comerciales. Al igual que cuando descargamos\ncualquier cosa de Internet, también debemos pensar en la seguridad. Primero, podría ser simplemente un virus disfrazado de módulo de Python. Y dos, ese módulo podría tener errores u otras vulnerabilidades de seguridad. No tenemos ninguna garantía\nde las personas que lo escribieron, por lo que lo usamos bajo nuestro propio riesgo, lo que en última instancia hace que cualquier\nprograma que construyamos sobre él sea vulnerable a los mismos problemas. Pero tenga en cuenta que existen muchos módulos populares y confiables, como Pandas para análisis de datos, Pygame para desarrollo de juegos y TensorFlow para aprendizaje automático, con los que puede resultarle divertido experimentar a medida que se sienta más\ncómodo con Python. Solo tenga en cuenta que el\nIDE de Khan Academy no admite la descarga de\nmódulos arbitrarios de Internet, por las mismas razones de seguridad. Entonces, por ahora, centrémonos\nen los módulos integrados, porque todavía tenemos mucho que explorar.",
    "t_arabic": "- [المدرس] إذا كنت\nتصنع دراجة، فمن المحتمل أن تذهب وتحصل على مقعد، ومجموعة من المقاود، ومجموعة من الإطارات، ثم تقوم بتجميع تلك القطع معًا. لن تقوم بجمع المطاط الخاص بك ومحاولة تصنيع إطار من الصفر. مع البرمجة، نحن نفعل الشيء نفسه. يمكننا إعادة استخدام المكونات التي أنشأها أشخاص آخرون بالفعل\nوجعلوها متاحة. إذن، كمبرمجين، مهمتنا هي تجميع هذه المكونات بطرق فريدة ومثيرة للاهتمام، بدلاً من قضاء الوقت في\nإعادة حل المشكلات نفسها مرارًا وتكرارًا. في بايثون، يمكن للمبرمجين حزم التعليمات البرمجية التي كتبوها\nلأشخاص آخرين لاستخدامها في ما يسمى بالوحدة النمطية. قد تسمع أيضًا الإشارة\nإليها باسم المكتبات أو الحزم. الوحدة هي في الأساس\nمجرد ملف من التعليمات البرمجية، يتم تنظيمها عمومًا\nفي مجموعة من الوظائف. يمكن للوحدات أن ترفع مستوى ما يمكننا\nإنجازه في البرنامج بسرعة، لأنه يمكننا استخدام هذه الوظيفة دون الحاجة إلى فهم تفاصيل كيفية عمل هذا الرمز.  لقد استخدمنا وظائف كتبها\nأشخاص آخرون من قبل في شكل\nوظائف مدمجة مثل الطباعة والإدخال والدائرية والطول. هذه تختلف عن الوحدات، لأنه يتم تحميلها\nفي Python افتراضيًا، يمكننا الوصول إلى وظيفة الطباعة في أي مكان نكتب فيه كود Python. بالنسبة للوحدات، يتعين علينا استيراد\nالوحدة بشكل صريح إلى الكود الخاص بنا أولاً قبل أن نتمكن من الوصول إلى أي من وظائفها. وذلك لأن\nذاكرة الكمبيوتر محدودة، ولا توجد به مساحة لحفظ آلاف الوحدات\nالموجودة مسبقًا في حالة نادرة\nقد نستخدم فيها وحدة معينة. بدلاً من ذلك، فإنه ينتظر منا أن نخبره أننا بحاجة إلى وحدة معينة، وعندها فقط سيكلفنا عناء\nقراءة هذا الملف وحفظ كل هذه الوظائف لنا. لتحميل وحدة نمطية في برنامجنا، نستخدم عبارة الاستيراد. هذه مجرد الكلمة الأساسية، استيراد، متبوعة باسم الوحدة.  توجد بيانات الاستيراد في الجزء\nالعلوي من برنامجنا. ثم يمكننا الوصول إلى أي وظيفة\nمحددة داخل تلك الوحدة باستخدام وحدة بناء الجملة name.function name. وهذا يخبر الكمبيوتر\nبالبحث عن تلك الوظيفة داخل تلك الوحدة،\nثم تشغيل هذا الرمز. دعونا نلقي نظرة على\nمثال للوحدة المضمنة. هنا لدينا الوثائق\nالخاصة بوحدة الرياضيات. توفر وحدة الرياضيات وظائف للعديد من \nالعمليات الرياضية الشائعة. نرى هنا أن لدينا دالة للحصول على الجذر التربيعي لرقم ما، وتتطلب إدخالاً واحدًا أو وسيطة واحدة، وترجع الجذر التربيعي. لذا، إذا فتحنا محرر التعليمات البرمجية الخاص بنا، فيمكننا إضافة عبارة استيراد في الأعلى لاستيراد وحدة الرياضيات، وبعد ذلك يمكننا استدعاء دالة\nالجذر التربيعي باستخدام math.sqrt. لاحظ أننا إذا نسينا\nعبارة الاستيراد، أو بناء الجملة النقطي لاسم وحدة المتابعة، فسنحصل على خطأ NameError، لأن الكمبيوتر لن يعرف مكان العثور على الدالة sqrt. الآن بعد أن استوردنا وحدة الرياضيات، يمكننا استخدام أي من\nوظائفها الأخرى في برنامجنا، مثل بيرم، أو المضروب، مما يوفر علينا كتابة التعليمات البرمجية لحساب المضروب بأنفسنا. يمكننا الاستفادة من العديد من وحدات Python المدمجة الأخرى، مثل التاريخ والوقت والعشوائية وUnittest، لتوسيع وظائف\nبرامجنا. تأتي الوحدات المضمنة مثبتة مسبقًا بلغة برمجة Python، لذا فهي متاحة لنا لاستيرادها في أي مكان نكتب فيه كود Python. هناك العديد من الوحدات الأخرى التي تم توفيرها للاستخدام العام، لكنها لا تأتي\nمثبتة مسبقًا مع Python، وعلينا تنزيل\nرمز الوحدة من الإنترنت وتثبيته لجعله متاحًا للاستيراد إلى برامجنا. مع هذه الوحدات، علينا أن نكون\nحذرين بشأن الانتحال. لا يمكننا استخدام أي رمز\nنريده كما لو كان خاصًا بنا دون أن ننسب الفضل\nإلى منشئه الأصلي. يمكن للمبرمجين أن يقرروا كيف\nيمكن للأشخاص الآخرين استخدام وحدتهم من خلال اتفاقية الترخيص. بعض التراخيص الشائعة، مثل MIT\nوApache، مفتوحة المصدر، مما يعني أنها\nتسمح لأي شخص إلى حد كبير باستخدام التعليمات البرمجية أو تعديلها أو توزيعها كما يحلو له. قد تكون التراخيص الأخرى أكثر تقييدًا، حيث لا تسمح\nللأشخاص بتعديل الكود أو استخدامه في المشاريع التجارية. كما هو الحال مع تنزيل\nأي شيء من الإنترنت، نحتاج أيضًا إلى التفكير في الأمان. أولاً، من الممكن أن يكون مجرد فيروس يتنكر في شكل وحدة بايثون. وثانيًا، قد تحتوي هذه الوحدة على أخطاء أو ثغرات أمنية أخرى. ليس لدينا أي ضمانات\nمن الأشخاص الذين كتبوه، لذلك نستخدمه على مسؤوليتنا الخاصة، مما يجعل في النهاية أي\nبرامج نبنيها فوقه عرضة لنفس المشاكل. لكن لاحظ أن هناك العديد من الوحدات الشائعة والموثوقة، مثل Pandas لتحليل البيانات، و Pygame لتطوير الألعاب، وTensorFlow للتعلم الآلي، والتي قد تجد متعة في تجربتها عندما تصبح أكثر\nارتياحًا مع Python. لاحظ فقط أن\nبيئة التطوير المتكاملة لأكاديمية خان لا تدعم تنزيل\nالوحدات العشوائية من الإنترنت، لنفس الأسباب الأمنية. لذا، دعونا نلتزم الآن\nبالوحدات المضمنة، لأنه لا يزال أمامنا الكثير لنستكشفه.",
    "t_italian": "- [Istruttore] Se stessi\ncostruendo una bicicletta, probabilmente andresti a prendere un sedile, un set di manubri, un set di pneumatici e poi assembleresti insieme quei pezzi. Non raccoglieresti la tua gomma e non proveresti a forgiare uno pneumatico da zero. Con la programmazione, facciamo lo stesso. Possiamo riutilizzare componenti che altre persone hanno già\ncostruito e reso disponibili. Come programmatori, quindi, il nostro compito è assemblare questi componenti in modi unici e interessanti, piuttosto che perdere tempo a\nrisolvere gli stessi problemi più e più volte. In Python, i programmatori possono impacchettare il codice che hanno scritto\naffinché altre persone lo utilizzino in quello che viene chiamato modulo. Potresti anche sentirli\nindicati come librerie o pacchetti. Un modulo è essenzialmente\nsolo un file di codice, generalmente organizzato\nin un insieme di funzioni.  I moduli possono migliorare rapidamente ciò che siamo in grado di\nrealizzare in un programma, perché possiamo utilizzare quella funzionalità senza dover comprendere i dettagli di come funziona quel codice. Abbiamo già utilizzato funzioni scritte\nda altre persone sotto forma di\nfunzioni integrate come print, input, round, length. Questi sono diversi dai moduli, poiché sono caricati\nin Python per impostazione predefinita, possiamo accedere alla funzione print ovunque scriviamo codice Python. Con i moduli, dobbiamo importare esplicitamente\nil modulo nel nostro codice prima di poter accedere a qualsiasi delle sue funzioni. Questo perché il computer\nha una memoria limitata, non ha spazio per pre-memorizzare le migliaia di moduli\ndisponibili nel raro caso in cui\npotremmo usarne uno specifico. Aspetta invece che gli diciamo che abbiamo bisogno di un modulo specifico, solo allora si prende la briga\ndi andare a leggere quel file e memorizzare tutte quelle funzioni per noi. Per caricare un modulo nel nostro programma, utilizziamo l'istruzione import. Questa è solo la parola chiave, import, seguita dal nome del modulo.  Le dichiarazioni di importazione sono in\ncima al nostro programma. Quindi possiamo accedere a qualsiasi funzione\ndefinita all'interno di quel modulo con la sintassi nome modulo.nome funzione. Questo dice al computer\ndi cercare quella funzione all'interno di quel modulo\ne quindi di eseguire quel codice. Diamo un'occhiata ad un\nesempio di modulo integrato. Qui abbiamo la documentazione\nper il modulo di matematica. Il modulo matematico fornisce funzioni per molte\noperazioni matematiche comuni. Vediamo qui che abbiamo una funzione per ottenere la radice quadrata di un numero, richiede un input, o argomento, e restituisce la radice quadrata. Quindi, se apriamo il nostro editor di codice, possiamo aggiungere un'istruzione import in alto per importare il modulo matematico, quindi possiamo chiamare\nla funzione radice quadrata utilizzando math.sqrt. Tieni presente che se dimenticassimo\nl'istruzione import o la sintassi del punto del nome del modulo, otterremmo un NameError, perché il computer non saprebbe dove trovare la funzione sqrt. Ora che abbiamo importato il modulo matematico, possiamo utilizzare qualsiasi altra sua\nfunzione nel nostro programma, come perm o fattoriale, il che ci evita di dover scrivere codice per calcolare noi stessi il fattoriale. Possiamo sfruttare molti altri moduli Python integrati, come data, ora, casuale e unittest, per espandere la funzionalità\ndei nostri programmi.  I moduli integrati vengono preinstallati con il linguaggio di programmazione Python, quindi possiamo importarli ovunque scriviamo codice Python. Ci sono molti altri moduli là fuori che sono stati resi disponibili per uso generale, ma non vengono\npreinstallati con Python, dobbiamo scaricare il\ncodice del modulo da Internet e installarlo per renderlo disponibile per l'importazione nei nostri programmi. Con questi moduli dobbiamo\nstare attenti al plagio. Non possiamo semplicemente utilizzare il codice che\nvogliamo come se fosse nostro senza dare credito\nal creatore originale. I programmatori possono decidere come altre\npersone possono utilizzare il proprio modulo tramite un contratto di licenza. Alcune licenze comuni, come MIT\ne Apache, sono open source, il che significa che consentono in gran parte a\nchiunque di utilizzare, modificare o distribuire il codice a proprio piacimento. Altre licenze potrebbero essere più restrittive e non consentire alle\npersone di modificare il codice o utilizzarlo in progetti commerciali. Come quando si scarica\nqualsiasi cosa da Internet, dobbiamo pensare anche alla sicurezza. Uno, potrebbe essere semplicemente un virus mascherato da modulo Python. E due, quel modulo potrebbe contenere bug o altre vulnerabilità di sicurezza. Non abbiamo alcuna garanzia\nda parte delle persone che lo hanno scritto, quindi lo utilizziamo a nostro rischio e pericolo, il che alla fine rende tutti i\nprogrammi che costruiamo sopra vulnerabili agli stessi problemi. Ma tieni presente che ci sono molti moduli popolari e affidabili là fuori, come Pandas per l'analisi dei dati, Pygame per lo sviluppo di giochi e TensorFlow per l'apprendimento automatico, che potresti trovare divertente da sperimentare man mano che acquisisci più\ndimestichezza con Python.  Tieni presente che l'\nIDE Khan Academy non supporta il download di\nmoduli arbitrari da Internet, per gli stessi motivi di sicurezza. Quindi, per ora, atteniamoci\nai moduli integrati, perché abbiamo ancora tanto da esplorare."
}