{
    "source": "7Gc4wAQZcfA",
    "youtubelink": "https://www.youtube.com/watch?v=7Gc4wAQZcfA",
    "t_english": "- [Presenter] How does the computer evaluate expressions with multiple operators, multiple function calls, or even nested function calls? That's a function call inside the parentheses of another function call. To examine this order of operations, let's trace a program with some complex arithmetic expressions. As always, the first thing the computer does when we run the program is load the first instruction into its working memory. When it sees an instruction like this where there's nested function calls, it's going to search for the innermost parentheses first. Then it starts evaluating from the inside out. Here in the innermost parentheses, we have the string. How many servings? This is already a single value, so it doesn't need simplifying. Okay, so the computer's going to peek outside of those parentheses and ask, \"What did you want me to do with this value, How many servings?\" And it sees the input function. The computer takes that value, displays it in the console, pops up a prompt, and then waits for the user to enter something. The computer's done with this part of the instruction, but it won't continue evaluating until it gets an answer back from the user. Let's say I type in five and hit enter. Where does that five go? Well, the input function returns out whatever value the user entered. Remember that the input function always returns that entered value as a string. So this isn't the integer five, it's the string five. Great. Now we have a much simpler expression. The computer goes to the parentheses first, sees that it's already a single value, so there's nothing to do. Peeks outside the parentheses and sees the int function. The int function takes that string five, casts it to an integer and returns out the value five. Now we just have a standard assignment statement. This statement tells the computer to go off to its memory, allocate a new chunk of it to remember a new value. Then it tags it with the name servings and sticks that value five in there. This instruction is now complete. Computer did everything. So it's gonna clear out that working memory and look for that next line of the program. Okay, we load the second instruction into working memory. Looks like we're just doing some math here. We follow PEMDAS or MDAS, that's parentheses, exponents, then multiplication and division, and then addition and subtraction. So we've got parentheses first, the computer evaluates six minus two. Then we're left with only multiplication and division operators, which are at the same level of precedence. So the computer just evaluates left to right. First thing it sees is this variable servings. It needs to go off and access that chunk of memory that was associated with the name servings. So it goes here, see servings, follows that line, and it finds the value five. So we substitute that in here. 5 times 4 is 20. Then we have 20 divided by 3. This is the float division operator. So we get 6.66666 repeating. Now it sees that equal sign and it says, \"Ah, you want me to assign this value I finally have to the variable spices.\" It checks its memory and sees that it has no recollection of a spices. So it allocates a new trunk, tags it with a name and sticks that value in there for later. All done. Clear it out. This next line is blank so the computer skips that, and then the line after that is a comment because it starts with this hashtag character. So the computer ignores that too. Comments are for humans, not for computers. Load in that next line, and here we have two sets of parentheses, but those parentheses are at the same level of precedence. They're not one inside of the other. So that means we're just gonna evaluate them left to right. Starting with those left parentheses, the computer is going to grab that value of spices from its memory, substitute it in. Now, it has two values inside these parentheses separated by a comma, but they're both simplified all the way down. So we're good here. We pop out the parentheses and we see the min function. And the min function returns out the minimum of those two input values. Now it jumps to the next set of parentheses, substitute in the value of servings. That's five. Two single values. Pops outside the parentheses sees that it wants to take the maximum. Five is greater than four. And now we just have two numbers to add together. We have a single value now on the right hand side of the equal sign so we can go ahead and do that assignment. Checks in its memory, and sees, \"Oh, I already know a spices, so I'm just gonna erase what's in there and replace it with this new value.\" Cool. Clear out working memory, move on. Next line now. That's a lot of parentheses. We're starting in and we're moving out. We've got an expression here that needs simplifying. We're substituting in spices. And then we're adding three to get that down to a single value. Now, everything inside here has been simplified, so we peek out and we see the round function. The round function tells the computer to take that first value and round it to the number of decimal places that the second value says. Here, we're rounding to two decimal places. Now we're in the next innermost parentheses. We already have a single value, so we pop outside those parentheses and we see the string function. The string function casts this to a string and returns out that value. Now we're in the last set of parentheses. We're concatenating two strings, so we just smoosh them together. And what should it do with this value? Oh, print it. There's no next line so it terminates the program execution. And when it terminates, that means the computer also forgets everything in its short term memory so all these values go away too. That's it for this program. Remember, if you ever have a complex expression, the computer always evaluates innermost parentheses to outermost.\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n",
    "t_urdu": "- [پیش کنندہ]\nکمپیوٹر ایک سے زیادہ آپریٹرز،\nایک سے زیادہ فنکشن کالز، یا یہاں تک کہ نیسٹڈ فنکشن کالز کے ساتھ اظہار کی جانچ کیسے کرتا ہے؟ یہ ایک اور فنکشن کال کے قوسین کے اندر ایک فنکشن کال ہے۔  آپریشن کے اس ترتیب کو جانچنے کے لیے،\nآئیے کچھ پیچیدہ ریاضی کے تاثرات کے ساتھ ایک پروگرام کا پتہ لگائیں۔ ہمیشہ کی طرح،\n جب ہم پروگرام چلاتے ہیں تو کمپیوٹر سب سے پہلے جو کام کرتا ہے وہ ہے پہلی ہدایات کو\nاس کی ورکنگ میموری میں لوڈ کرنا۔ جب یہ اس طرح کی ہدایت دیکھتا ہے جہاں نیسٹڈ فنکشن کالز ہوتی ہیں، تو یہ سب سے پہلے سب سے\nاندرونی قوسین کو تلاش کرے گا۔ پھر اس کا اندر سے جائزہ لینا شروع ہو جاتا ہے۔\n یہاں سب سے اندرونی\nقوسین میں، ہمارے پاس سٹرنگ ہے۔ کتنی سرونگ؟ یہ پہلے سے ہی ایک واحد قدر ہے، لہذا اسے آسان بنانے کی ضرورت نہیں ہے۔ ٹھیک ہے، تو کمپیوٹر\n ان قوسین کے باہر جھانک کر پوچھے گا، \"آپ مجھ سے\nاس قدر کے ساتھ کیا کرنا چاہتے تھے، کتنی سرونگ؟\" اور یہ ان پٹ فنکشن کو دیکھتا ہے۔ کمپیوٹر اس قدر کو لیتا ہے،\nاسے کنسول میں دکھاتا ہے، ایک پرامپٹ پاپ اپ کرتا ہے، اور پھر صارف کے کچھ داخل کرنے کا انتظار کرتا ہے۔ کمپیوٹر نے ہدایات کے اس حصے کے ساتھ کام کر لیا ہے،\n لیکن یہ اس وقت تک جانچ جاری نہیں رکھے گا جب تک اسے صارف کی طرف سے جواب نہیں مل جاتا۔\n آئیے کہتے ہیں کہ میں پانچ میں ٹائپ کرتا ہوں اور انٹر دبائیں۔ وہ پانچ کہاں جاتے ہیں؟ ٹھیک ہے، ان پٹ فنکشن صارف نے جو بھی قیمت درج کی ہے اسے واپس کرتا ہے۔ یاد رکھیں کہ ان پٹ فنکشن ہمیشہ اسٹرنگ کے طور پر داخل کردہ ویلیو کو واپس کرتا ہے۔ تو یہ انٹیجر پانچ نہیں ہے،\nیہ سٹرنگ پانچ ہے۔ زبردست۔  اب ہمارے پاس ایک\nبہت آسان اظہار ہے۔ کمپیوٹر پہلے قوسین پر جاتا ہے،\n دیکھتا ہے کہ یہ پہلے سے ہی ایک واحد قدر ہے، اس لیے کرنے کو کچھ نہیں ہے۔ قوسین کے باہر جھانکتا ہے\nاور int فنکشن کو دیکھتا ہے۔ int فنکشن اس سٹرنگ پانچ کو لیتا ہے، اسے ایک عدد پر ڈالتا ہے اور\nپانچ کی قدر واپس کرتا ہے۔ اب ہمارے پاس صرف ایک معیاری\nاسائنمنٹ کا بیان ہے۔ یہ بیان\nکمپیوٹر سے کہتا ہے کہ وہ اپنی میموری پر جائے، نئی قدر کو یاد رکھنے کے لیے اس کا ایک نیا حصہ مختص کرے۔\n پھر یہ اسے نام سرونگ اور اسٹک کے ساتھ ٹیگ کرتا ہے جس کی قیمت وہاں پانچ ہے۔ یہ ہدایت اب مکمل ہو چکی ہے۔\nکمپیوٹر نے سب کچھ کیا۔ تو یہ\nکام کرنے والی میموری کو صاف کرنے والا ہے اور\nپروگرام کی اگلی لائن کو تلاش کریں۔ ٹھیک ہے، ہم دوسری\nہدایات کو ورکنگ میموری میں لوڈ کرتے ہیں۔  ایسا لگتا ہے کہ ہم\nیہاں کچھ ریاضی کر رہے ہیں۔ ہم PEMDAS یا\nMDAS کی پیروی کرتے ہیں، یعنی قوسین، ایکسپوننٹ، پھر\nضرب اور تقسیم، اور پھر اضافہ اور گھٹاؤ۔ تو ہمارے پاس پہلے قوسین ہیں، کمپیوٹر چھ مائنس دو کا اندازہ کرتا ہے۔ پھر ہمارے پاس صرف ضرب اور تقسیم کے آپریٹرز رہ گئے ہیں، جو ایک ہی سطح پر مقدم ہیں۔ تو کمپیوٹر صرف\nبائیں سے دائیں جانچتا ہے۔ پہلی چیز یہ دیکھتی ہے کہ\nیہ متغیر سرونگ ہے۔ اسے جانے اور\nمیموری کے اس حصے تک رسائی حاصل کرنے کی ضرورت ہے جو\nنام کی خدمت سے وابستہ تھی۔ تو یہ یہاں جاتا ہے،\nسرونگ دیکھتا ہے، اس لائن کی پیروی کرتا ہے، اور اسے پانچ کی قیمت ملتی ہے۔ تو ہم اسے یہاں میں بدل دیتے ہیں۔\n5 ضرب 4 ہے 20۔ پھر ہمارے پاس 20 کو 3 سے تقسیم کیا گیا ہے۔ یہ فلوٹ ڈویژن آپریٹر ہے۔ تو ہمیں 6.66666 دہرایا جاتا ہے۔ اب یہ وہ مساوی نشان دیکھتا ہے اور یہ کہتا ہے، \"آہ، آپ چاہتے ہیں کہ میں اس قدر کو تفویض کروں جو مجھے آخر کار\nمتغیر مصالحوں کے لیے ہے۔\" یہ اس کی یادداشت کو چیک کرتا ہے اور دیکھتا ہے کہ اسے کسی مصالحے کی یاد نہیں ہے۔ لہذا یہ ایک نیا\nٹرنک مختص کرتا ہے، اسے ایک نام کے ساتھ ٹیگ کرتا ہے اور بعد میں اس کی قیمت کو وہاں رکھ دیتا ہے۔ سب ہو گیا  اسے صاف کریں۔ یہ اگلی لائن خالی ہے لہذا\nکمپیوٹر اسے چھوڑ دیتا ہے، اور پھر اس کے بعد کی لائن ایک تبصرہ ہے کیونکہ یہ\nاس ہیش ٹیگ کیریکٹر سے شروع ہوتی ہے۔ تو کمپیوٹر اسے بھی نظر انداز کرتا ہے۔ تبصرے انسانوں کے لیے ہیں،\nکمپیوٹر کے لیے نہیں۔ اس اگلی لائن میں لوڈ کریں، اور یہاں ہمارے پاس قوسین کے دو سیٹ ہیں، لیکن وہ قوسین\nایک ہی سطح پر مقدم ہیں۔ وہ ایک دوسرے کے اندر نہیں ہیں۔ تو اس کا مطلب ہے کہ ہم صرف\nان کا بائیں سے دائیں جائزہ لیں گے۔ ان بائیں قوسین کے ساتھ شروع کرتے ہوئے، کمپیوٹر اپنی میموری سے\nمسالوں کی اس قدر کو حاصل کرنے جا رہا ہے ، اس کی جگہ لے لے گا۔ اب، اس میں ان قوسین کے اندر دو قدریں ہیں جو\nکوما سے الگ کی گئی ہیں، لیکن وہ دونوں نیچے تک آسان ہیں۔\n تو ہم یہاں اچھے ہیں۔ ہم قوسین کو پاپ آؤٹ کرتے ہیں\nاور ہم min فنکشن دیکھتے ہیں۔ اور min فنکشن ان دو ان پٹ ویلیو کی کم از کم واپسی کرتا ہے۔ اب یہ\nقوسین کے اگلے سیٹ پر جاتا ہے، سرونگ کی قدر میں متبادل۔ وہ پانچ۔  دو واحد اقدار۔ قوسین کے باہر پاپس دیکھتا ہے کہ یہ زیادہ سے زیادہ لینا چاہتا ہے۔ پانچ چار سے بڑا ہے۔ اور اب ہمارے پاس ایک\nساتھ جوڑنے کے لیے صرف دو نمبر ہیں۔ ہمارے پاس\nاب مساوی نشان کے دائیں جانب ایک واحد قدر ہے تاکہ ہم\nآگے بڑھ کر اس اسائنمنٹ کو انجام دے سکیں۔ اس کی یادداشت میں چیک کرتا ہے، اور دیکھتا ہے، \"اوہ، میں پہلے سے ہی ایک مصالحہ جانتا ہوں،\nاس لیے میں وہاں جو کچھ ہے اسے مٹا دوں گا اور\nاسے اس نئی قیمت سے بدل دوں گا۔\" ٹھنڈا  ورکنگ میموری کو صاف کریں، آگے بڑھیں۔ اب اگلی لائن۔  یہ بہت\nسارے قوسین ہیں۔ ہم شروع کر رہے ہیں اور ہم باہر جا رہے ہیں۔ ہمیں یہاں ایک اظہار ملا ہے\nجسے آسان بنانے کی ضرورت ہے۔ ہم مصالحے میں بدل رہے ہیں۔ اور پھر ہم تین کا اضافہ کر رہے ہیں تاکہ اسے ایک ہی قیمت تک لے جا سکیں۔ اب، یہاں کے اندر کی ہر چیز کو\nآسان بنا دیا گیا ہے، لہذا ہم باہر جھانکتے ہیں اور ہمیں\nگول فنکشن نظر آتا ہے۔ راؤنڈ فنکشن کمپیوٹر سے کہتا ہے کہ\n وہ پہلی ویلیو لے اور اسے اعشاریہ کی تعداد تک گول کرے\nجو دوسری ویلیو کہتی ہے۔ یہاں، ہم\nدو اعشاریہ دو جگہوں پر گول کر رہے ہیں۔ اب ہم اگلے سب سے\nاندرونی قوسین میں ہیں۔ ہمارے پاس پہلے سے ہی ایک\nقیمت ہے، لہذا ہم ان قوسین کے باہر پاپ کرتے ہیں اور ہم\nسٹرنگ فنکشن دیکھتے ہیں۔ سٹرنگ فنکشن اسے سٹرنگ میں ڈالتا ہے اور اس قدر کو واپس کرتا ہے۔ اب ہم قوسین کے آخری سیٹ میں ہیں۔ ہم دو تاروں کو جوڑ رہے ہیں، لہذا ہم انہیں ایک ساتھ ہموار کرتے ہیں۔ اور اسے اس قدر کے ساتھ کیا کرنا چاہئے\n؟  اوہ، اسے پرنٹ کریں.  کوئی اگلی لائن نہیں ہے لہذا یہ\nپروگرام پر عمل درآمد کو ختم کرتا ہے۔ اور جب یہ ختم ہو جاتا ہے تو\nاس کا مطلب ہے کہ کمپیوٹر بھی\nاپنی شارٹ ٹرم میموری میں سب کچھ بھول جاتا ہے تو یہ تمام قدریں بھی ختم ہو جاتی ہیں۔ اس پروگرام کے لیے یہی ہے۔ یاد رکھیں، اگر آپ کے پاس کبھی بھی\nکوئی پیچیدہ اظہار ہوتا ہے، تو کمپیوٹر ہمیشہ اندرونی قوسین کو بیرونی سے لے کر جانچتا ہے۔",
    "t_spanish": "- [Presentador] ¿Cómo\nevalúa la computadora expresiones con múltiples operadores,\nmúltiples llamadas a funciones o incluso llamadas a funciones anidadas? Esa es una llamada a función dentro del paréntesis de otra llamada a función. Para examinar este orden de\noperaciones, tracemos un programa con algunas expresiones aritméticas complejas. Como siempre, lo primero que\nhace el ordenador cuando ejecutamos el programa es cargar la primera instrucción\nen su memoria de trabajo. Cuando ve una instrucción como esta donde hay llamadas a funciones anidadas, primero buscará los\nparéntesis más internos. Luego comienza a evaluar\ndesde adentro hacia afuera. Aquí, entre paréntesis más internos\n, tenemos la cadena.  ¿ Cuántas porciones? Este ya es un valor único, por lo que no es necesario simplificarlo. Bien, entonces la computadora\nmirará fuera de esos paréntesis y preguntará: \"¿Qué querías que\nhiciera con este valor? ¿ Cuántas porciones?\" Y ve la función de entrada. La computadora toma ese valor,\nlo muestra en la consola, muestra un mensaje emergente y luego espera a que el usuario ingrese algo. La computadora ha terminado con\nesta parte de la instrucción, pero no continuará evaluando hasta que reciba una respuesta\ndel usuario. Digamos que escribo cinco y presiono enter.  ¿ A dónde van esos cinco? Bueno, la función de entrada devuelve cualquier valor que haya ingresado el usuario. Recuerde que la función de entrada siempre devuelve el valor ingresado como una cadena. Entonces este no es el número entero\ncinco, es la cadena cinco. Excelente.  Ahora tenemos una\nexpresión mucho más simple. La computadora va\nprimero al paréntesis y ve que ya es un valor único, por lo que no hay nada que hacer. Mira fuera del paréntesis\ny ve la función int. La función int toma esa cadena cinco, la convierte en un número entero y\ndevuelve el valor cinco. Ahora solo tenemos una\ndeclaración de asignación estándar. Esta declaración le dice a la\ncomputadora que vaya a su memoria y asigne una nueva porción\npara recordar un nuevo valor. Luego lo etiqueta con el nombre de las porciones y pega el valor cinco allí. Esta instrucción ya está completa.\nLa computadora hizo todo. Entonces\nborrará esa memoria de trabajo y buscará la siguiente\nlínea del programa. Bien, cargamos la segunda\ninstrucción en la memoria de trabajo. Parece que solo estamos\nhaciendo algunos cálculos aquí. Seguimos PEMDAS o\nMDAS, es decir, paréntesis, exponentes, luego\nmultiplicación y división, y luego suma y resta. Primero tenemos los paréntesis, la computadora evalúa seis menos dos. Entonces nos quedan sólo los operadores de multiplicación y división, que están en el mismo nivel de precedencia. Entonces la computadora simplemente\nevalúa de izquierda a derecha. Lo primero que ve son\nestas porciones variables. Necesita activarse y\nacceder a esa porción de memoria asociada\ncon las porciones de nombres. Entonces va aquí, ve\nporciones, sigue esa línea y encuentra el valor cinco. Así que lo sustituimos\naquí.  5 por 4 es 20. Luego tenemos 20 dividido por 3. Este es el operador de división flotante. Entonces obtenemos 6,66666 repeticiones. Ahora ve ese signo igual y dice: \"Ah, quieres que asigne este valor que finalmente tengo\na la variable especias\". Comprueba su memoria y ve que no recuerda ninguna especia. Entonces asigna un nuevo\ntronco, lo etiqueta con un nombre y guarda ese valor allí para más adelante. Todo listo.  Límpielo. La siguiente línea está en blanco, por lo que\nla computadora la omite, y luego la línea siguiente es un comentario porque comienza con\neste carácter de hashtag. Entonces la computadora también ignora eso. Los comentarios son para humanos,\nno para computadoras. Cargue la siguiente línea y aquí tenemos dos conjuntos de paréntesis, pero esos paréntesis están en\nel mismo nivel de precedencia. No son uno dentro del otro. Eso significa que simplemente\nlos evaluaremos de izquierda a derecha. Comenzando con esos paréntesis izquierdos, la computadora\ntomará ese valor de especias de su memoria y lo sustituirá. Ahora, tiene dos valores dentro de estos paréntesis\nseparados por una coma, pero ambos están simplificados\ncompletamente. Entonces estamos bien aquí. Sacamos los paréntesis\ny vemos la función min. Y la función min devuelve el mínimo de esos dos valores de entrada. Ahora salta al\nsiguiente conjunto de paréntesis, sustituye el valor de las porciones. Son cinco.  Dos valores únicos. Aparece fuera del paréntesis y ve que quiere aprovechar al máximo. Cinco es mayor que cuatro. Y ahora solo tenemos dos\nnúmeros para sumar.  Ahora tenemos un valor único\nen el lado derecho del signo igual para que podamos seguir\nadelante y hacer esa tarea. Revisa su memoria y ve: \"Oh, ya conozco una especia,\nasí que borraré lo que hay allí y\nlo reemplazaré con este nuevo valor\". Fresco.  Limpia la memoria de trabajo y sigue adelante. Siguiente línea ahora.  Son\nmuchos paréntesis. Estamos empezando y nos estamos mudando. Tenemos una expresión\naquí que necesita simplificarse. Estamos sustituyéndolo por especias. Y luego sumamos tres para reducirlo a un solo valor. Ahora, todo\naquí dentro se ha simplificado, así que nos asomamos y\nvemos la función redonda. La función de ronda le dice a\nla computadora que tome ese primer valor y lo redondee al número de decimales\nque dice el segundo valor. Aquí redondeamos\na dos decimales. Ahora estamos en el siguiente\nparéntesis más interno. Ya tenemos un\nvalor único, por lo que salimos de esos paréntesis y\nvemos la función de cadena. La función de cadena convierte esto en una cadena y devuelve ese valor. Ahora estamos en el último conjunto de paréntesis. Estamos concatenando dos cadenas, así que simplemente las unimos.  ¿ Y qué debería hacer con\neste valor?  Oh, imprímelo. No hay línea siguiente por lo que\nfinaliza la ejecución del programa. Y cuando termina,\neso significa que la computadora también olvida todo lo que hay\nen su memoria a corto plazo, por lo que todos estos valores también desaparecen. Eso es todo por este programa. Recuerde, si alguna vez\ntiene una expresión compleja, la computadora siempre evalúa los paréntesis más internos hasta los más externos.",
    "t_arabic": "- [المقدم] كيف يقوم\nالكمبيوتر بتقييم التعبيرات باستخدام عوامل تشغيل متعددة، أو\nاستدعاءات دوال متعددة، أو حتى استدعاءات دوال متداخلة؟ هذا استدعاء دالة داخل قوسين لاستدعاء دالة أخرى. لفحص ترتيب\nالعمليات هذا، دعونا نتتبع برنامجًا يحتوي على بعض التعبيرات الحسابية المعقدة. كما هو الحال دائمًا، أول\nشيء يفعله الكمبيوتر عند تشغيل البرنامج هو تحميل التعليمات الأولى\nفي ذاكرته العاملة. عندما ترى تعليمات مثل هذه حيث توجد استدعاءات دالة متداخلة، فسوف تبحث عن\nالأقواس الأعمق أولاً. ثم يبدأ بالتقييم\nمن الداخل إلى الخارج. هنا في\nالأقواس الداخلية، لدينا السلسلة. كم عدد الحصص؟ هذه قيمة واحدة بالفعل، لذا لا تحتاج إلى تبسيط. حسنًا،\nسينظر الكمبيوتر خارج تلك الأقواس ويسأل، \"ماذا تريد مني\nأن أفعل بهذه القيمة، كم عدد الحصص؟\" وترى وظيفة الإدخال. يأخذ الكمبيوتر هذه القيمة،\nويعرضها في وحدة التحكم، وينبثق مطالبة، ثم ينتظر حتى يقوم المستخدم بإدخال شيء ما.  لقد انتهى الكمبيوتر من\nهذا الجزء من التعليمات، لكنه لن يستمر في التقييم حتى يحصل على إجابة\nمن المستخدم. لنفترض أنني أكتب خمسة ثم اضغط على زر الإدخال. أين يذهب هؤلاء الخمسة؟ حسنًا، تقوم وظيفة الإدخال بإرجاع أي قيمة أدخلها المستخدم. تذكر أن دالة الإدخال تُرجع دائمًا القيمة المُدخلة كسلسلة. إذًا هذا ليس العدد الصحيح\nخمسة، بل السلسلة خمسة. عظيم.  الآن لدينا\nتعبير أبسط بكثير. يذهب الكمبيوتر إلى\nالأقواس أولاً، ويرى أنها قيمة واحدة بالفعل، لذلك ليس هناك ما يمكن فعله. يلقي نظرة خاطفة خارج الأقواس\nويرى الدالة int. تأخذ الدالة int تلك السلسلة رقم خمسة، وتحولها إلى عدد صحيح\nوترجع القيمة خمسة. الآن لدينا فقط\nبيان المهمة القياسية. يخبر هذا البيان\nالكمبيوتر بالانتقال إلى ذاكرته، وتخصيص جزء جديد منها\nلتذكر قيمة جديدة. ثم يتم وضع علامة عليه مع حصص الأسماء والعصي التي تبلغ قيمتها خمسة هناك. هذه التعليمات اكتملت الآن.\nالكمبيوتر فعل كل شيء. لذلك سوف تقوم\nبمسح تلك الذاكرة العاملة والبحث عن\nالسطر التالي من البرنامج. حسنًا، نقوم بتحميل\nالتعليمة الثانية في الذاكرة العاملة. يبدو أننا نقوم ببعض\nالعمليات الحسابية هنا. نحن نتبع PEMDAS أو\nMDAS، أي الأقواس، ثم الأسس، ثم\nالضرب والقسمة، ثم الجمع والطرح. إذن لدينا قوسين أولًا، يقوم الكمبيوتر بحساب ستة ناقص اثنين. ثم يتبقى لدينا فقط عوامل الضرب والقسمة، والتي لها نفس مستوى الأسبقية. لذلك يقوم الكمبيوتر\nبالتقييم من اليسار إلى اليمين فقط. أول شيء تراه هو\nهذه الحصص المتغيرة. يجب أن ينفجر\nويصل إلى تلك القطعة من الذاكرة المرتبطة\nبخدمات الأسماء. إذن، يذهب هنا، انظر\nالحصص، ويتبع هذا السطر، ويجد القيمة خمسة. لذلك نعوض بذلك\nهنا.  5 ضرب 4 يساوي 20. ثم لدينا 20 مقسومًا على 3. هذا هو عامل القسمة العائمة. إذن نحصل على 6.66666 متكرر. الآن ترى علامة التساوي هذه وتقول، \"آه، تريد مني أن أخصص هذه القيمة التي أملكها أخيرًا\nللتوابل المتغيرة.\" يفحص ذاكرته ويرى أنه لا يتذكر أي بهارات. لذا فهو يخصص\nصندوقًا جديدًا، ويضع عليه اسمًا ويضع تلك القيمة فيه لوقت لاحق. كله تمام.  امسحها. هذا السطر التالي فارغ لذا\nيتخطى الكمبيوتر ذلك، ثم السطر الذي بعد ذلك هو تعليق لأنه يبدأ بحرف\nالهاشتاج هذا. لذلك يتجاهل الكمبيوتر ذلك أيضًا. التعليقات مخصصة للإنسان\nوليست للكمبيوتر. قم بتحميل السطر التالي، وهنا لدينا مجموعتان من الأقواس، لكن تلك الأقواس لها\nنفس مستوى الأسبقية. إنهم ليسوا واحدًا داخل الآخر. وهذا يعني أننا\nسنوجد قيمة هذه القيم من اليسار إلى اليمين. بدءًا من تلك الأقواس اليسرى، سيقوم الكمبيوتر\nبسحب قيمة التوابل من ذاكرته، واستبدالها بها. الآن، لديه قيمتان داخل هذه الأقواس\nمفصولة بفاصلة، لكن تم تبسيطهما على\nطول الطريق. لذلك نحن جيدون هنا. نخرج الأقواس\nونرى الدالة min. وتقوم الدالة min بإرجاع الحد الأدنى من قيمتي الإدخال هاتين. ينتقل الآن إلى\nالمجموعة التالية من الأقواس، ويعوض بقيمة الحصص. هذا خمسة.  قيمتان منفردتان. يرى الملوثات العضوية الثابتة خارج الأقواس أنه يريد أن يأخذ الحد الأقصى. خمسة أكبر من أربعة. والآن ليس لدينا سوى\nعددين لنجمعهما معًا. لدينا الآن قيمة واحدة\nعلى الجانب الأيمن من علامة التساوي حتى نتمكن من\nالمتابعة وإجراء هذه المهمة. يتحقق من ذاكرته، ويرى، \"أوه، أنا أعرف بالفعل إحدى التوابل،\nلذا سأقوم بمسح ما بداخلها واستبدالها\nبهذه القيمة الجديدة.\" رائع.  امسح الذاكرة العاملة، تابع. السطر التالي الآن.  هذا\nكثير من الأقواس.  لقد بدأنا ونحن نخرج. لدينا\nهنا تعبير يحتاج إلى التبسيط. نحن نستبدل التوابل. ثم نضيف ثلاثة لنصل إلى قيمة واحدة. الآن، تم تبسيط كل شيء بالداخل\nهنا، لذا نلقي نظرة خاطفة على\nالدالة الدائرية. تطلب الدالة المستديرة من\nالكمبيوتر أن يأخذ القيمة الأولى ويقربها إلى عدد المنازل العشرية\nالتي تشير إليها القيمة الثانية. نحن هنا نقوم بالتقريب\nإلى منزلتين عشريتين. نحن الآن في\nالأقواس الأعمق التالية. لدينا بالفعل\nقيمة واحدة، لذلك نخرج من تلك الأقواس\nونرى دالة السلسلة.  تقوم دالة السلسلة بإرسال هذا إلى سلسلة وإرجاع تلك القيمة. نحن الآن في المجموعة الأخيرة من الأقواس. نحن نقوم بربط سلسلتين، لذلك نقوم بدمجهما معًا. وماذا يجب أن يفعل بهذه\nالقيمة؟  أوه، طباعته. لا يوجد سطر تالي، لذا فهو\nينهي تنفيذ البرنامج. وعندما تنتهي،\nفهذا يعني أن الكمبيوتر ينسى أيضًا كل شيء\nفي ذاكرته قصيرة المدى، وبالتالي تختفي كل هذه القيم أيضًا. هذا كل شيء لهذا البرنامج. تذكر، إذا كان\nلديك تعبير معقد، فسيقوم الكمبيوتر دائمًا بتقييم الأقواس الداخلية إلى الأقواس الخارجية.",
    "t_italian": "- [Presentatore] In che modo il\ncomputer valuta le espressioni con più operatori,\npiù chiamate a funzioni o anche chiamate a funzioni nidificate? Questa è una chiamata di funzione racchiusa tra parentesi di un'altra chiamata di funzione. Per esaminare questo ordine di\noperazioni, tracciamo un programma con alcune espressioni aritmetiche complesse. Come sempre, la prima\ncosa che fa il computer quando eseguiamo il programma è caricare la prima istruzione\nnella sua memoria di lavoro. Quando vede un'istruzione come questa in cui sono presenti chiamate di funzioni annidate, cercherà\nprima le parentesi più interne. Quindi inizia a valutare\ndall'interno. Qui tra le parentesi più interne\nabbiamo la stringa. Quante porzioni? Questo è già un valore singolo, quindi non è necessario semplificarlo. Ok, quindi il computer\nsbircerà fuori da quelle parentesi e chiederà: \"Cosa volevi che\nfacessi con questo valore, quante porzioni?\" E vede la funzione di input. Il computer prende quel valore,\nlo visualizza nella console, visualizza un messaggio e quindi attende che l'utente inserisca qualcosa. Il computer ha terminato\nquesta parte dell'istruzione, ma non continuerà la valutazione finché non riceverà una risposta\ndall'utente. Diciamo che digito cinque e premo invio. Dove vanno a finire quei cinque? Bene, la funzione di input restituisce qualunque valore inserito dall'utente. Ricorda che la funzione di input restituisce sempre il valore immesso come stringa. Quindi questo non è l'intero\ncinque, è la stringa cinque. Grande.  Ora abbiamo\nun'espressione molto più semplice. Il computer va\nprima alle parentesi, vede che è già un valore singolo, quindi non c'è niente da fare. Sbircia fuori dalle parentesi\ne vede la funzione int. La funzione int prende la stringa cinque, la trasforma in un numero intero e\nrestituisce il valore cinque. Ora abbiamo solo una\ndichiarazione di assegnazione standard. Questa istruzione dice al\ncomputer di andare in memoria, allocarne una nuova parte\nper ricordare un nuovo valore. Quindi lo tagga con il nome porzioni e inserisce il valore cinque. Questa istruzione è ora completa.  Il\ncomputer ha fatto tutto. Quindi\ncancellerà quella memoria di lavoro e cercherà la\nriga successiva del programma. Ok, carichiamo la seconda\nistruzione nella memoria di lavoro. Sembra che stiamo solo\nfacendo un po' di conti qui. Seguiamo PEMDAS o\nMDAS, ovvero parentesi, esponenti, quindi\nmoltiplicazione e divisione, quindi addizione e sottrazione. Quindi prima abbiamo le parentesi, il computer calcola sei meno due. Rimangono quindi solo gli operatori di moltiplicazione e divisione, che hanno lo stesso livello di precedenza. Quindi il computer\nvaluta semplicemente da sinistra a destra.  La prima cosa che vede sono le\nporzioni variabili. È necessario che si spenga e\nacceda a quella porzione di memoria associata\nalle porzioni di nome. Quindi va qui, vedi\nporzioni, segue quella linea e trova il valore cinque. Quindi lo sostituiamo\nqui.  5 per 4 fa 20. Quindi abbiamo 20 diviso per 3. Questo è l'operatore di divisione in virgola mobile. Quindi otteniamo 6.66666 ripetuto. Ora vede il segno uguale e dice: \"Ah, vuoi che assegni questo valore che ho finalmente\nalla variabile spezie\". Controlla la memoria e vede che non ricorda alcuna spezia. Quindi assegna un nuovo\ntrunk, lo etichetta con un nome e inserisce quel valore per dopo. Tutto fatto.  Puliscilo. La riga successiva è vuota, quindi\nil computer la salta, quindi la riga successiva è un commento perché inizia con\nquesto carattere hashtag. Quindi anche il computer lo ignora. I commenti sono per gli esseri umani,\nnon per i computer. Carica nella riga successiva e qui abbiamo due serie di parentesi, ma quelle parentesi hanno\nlo stesso livello di precedenza. Non sono uno dentro l'altro. Ciò significa che\nli valuteremo da sinistra a destra. Iniziando con quelle parentesi lasciate, il computer\nprenderà quel valore di spezie dalla sua memoria, lo sostituirà. Ora, ci sono due valori all'interno di queste parentesi\nseparati da una virgola, ma sono entrambi semplificati\nfino in fondo. Quindi stiamo bene qui. Tiriamo fuori le parentesi\ne vediamo la funzione min. E la funzione min restituisce il minimo di questi due valori di input. Ora passa alla\nserie successiva di parentesi, sostitutiva nel valore delle porzioni. Sono cinque.  Due valori singoli. Se si apre fuori dalle parentesi si vede che si vuole prendere il massimo. Cinque è maggiore di quattro.  E ora ci restano solo due\nnumeri da sommare.  Ora abbiamo un singolo valore\nsul lato destro del segno di uguale, quindi possiamo andare\navanti ed eseguire il compito. Controlla nella sua memoria e vede: \"Oh, conosco già una spezia,\nquindi cancellerò semplicemente quello che c'è dentro e\nlo sostituirò con questo nuovo valore\".  Freddo .  Cancella la memoria di lavoro, vai avanti. La prossima riga adesso.  Sono\nun sacco di parentesi. Stiamo iniziando e stiamo uscendo. Abbiamo un'espressione\nqui che deve essere semplificata. Stiamo sostituendo le spezie. E poi ne aggiungiamo tre per ridurlo a un unico valore. Adesso tutto\nqui dentro è stato semplificato, quindi sbirchiamo e\nvediamo la funzione rotonda. La funzione round dice\nal computer di prendere il primo valore e di arrotondarlo al numero di cifre decimali\nindicato dal secondo valore. Qui stiamo arrotondando\na due cifre decimali. Ora siamo nella prossima\nparentesi più interna. Abbiamo già un singolo\nvalore, quindi usciamo da quelle parentesi e\nvediamo la funzione stringa. La funzione stringa lo converte in una stringa e restituisce quel valore. Ora siamo nell'ultima serie di parentesi. Stiamo concatenando due stringhe, quindi le uniamo insieme. E cosa dovrebbe fare con\nquesto valore?  Oh, stampalo. Non esiste una riga successiva, quindi\ntermina l'esecuzione del programma. E quando termina,\nsignifica che anche il computer dimentica tutto\nnella sua memoria a breve termine, quindi anche tutti questi valori scompaiono. Questo è tutto per questo programma. Ricorda, se mai\nhai un'espressione complessa, il computer valuta sempre le parentesi più interne con quelle più esterne."
}