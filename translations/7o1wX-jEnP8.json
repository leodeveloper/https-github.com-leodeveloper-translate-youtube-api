{
    "source": "7o1wX-jEnP8",
    "youtubelink": "https://www.youtube.com/watch?v=7o1wX-jEnP8",
    "t_english": "- [Instructor] We can use Boolean expressions to ask questions in our programs, but how can we branch control flow based on the answer? To do that, we need conditionals. Conditionals form the basis of selection. They allow the computer to decide which code to run depending on whether the answer to a specific question or condition is true or false. The first piece of a conditional is the IF statement. We start an IF statement with the keyword If. Then we add our condition, which can be any boolean expression. We always end this line with a colon because an IF statement comes in two parts. This first part, which is the condition and the second part, which is the instructions to run if that condition evaluates to true. In Python, we indicate those instructions using indentation. Any lines of code immediately following that condition that are indented one level in are considered inside that IF statement, if the condition evaluates to true, the computer will go on to execute all of the instructions indented inside the IF statement in order. When it's done, it'll go on to execute the rest of the program as normal. If the condition evaluates to false, the computer will skip all the lines of code that are indented inside of that IF statement. Instead, it'll jump directly to the next line of code that's outside of the IF statement. That means the first line of code that is indented at the same level as that initial if. Let's try an example. Here we have the Boolean expression, num_orders equals equals 10, which asks the question, is this the customer's 10th order? We can then use this Boolean value in our IF statement. We'll indent one print function call inside of the IF statement and one outside. The one inside will only execute if it is the 10th order, that is if the variable is 10th order contains the Boolean value True. We can also write this without the variable where we just inline that whole Boolean expression in the IF statement. Let's trace how the computer executes this. It starts with the first line and assigns a value 10 to the variable num_orders. Then it hits this IF statement, so first it evaluates the Boolean expression. 10 is equal to 10, so this evaluates to true. Because it's true, the computer will execute the lines of code indented inside of the IF statement. First, it'll print, \"Your order is free!\" And then it'll assign the value zero to the variable num_orders. Then it just keeps moving through the rest of the program in order, so it'll print the value of num_orders, which is now zero. Now let's say instead num_orders was originally set to three. When the computer executes this program, it'll assign the value three to num_orders, evaluate the Boolean expression. Three is not equal to 10, so this is false, and then because it's false, we'll skip the lines of code indented inside the IF statement. It'll jump to the next line of code outside, which is print num_orders, so it'll print three. Note that if we didn't indent the line of code num_orders equal zero, it would be considered outside of the IF statement, so in the false case, num_orders would be set to zero, and then it would print zero. In the true case, we would print, \"Your order is free.\" Then we would set num_orders to zero, and then we would print zero. You can write IF statements with any Boolean expressions as conditions, and you can put any and as many instructions as you want inside of them. With this conditional, I could make sure to only ask the follow-up question, chicken or tofu, if the user ordered pad Thai, because if they order the papaya salad, that question doesn't make sense. Note that in most IDEs we indent using the tab key. Our standard lines of code should line up directly with the left margin. That is, there should be no spaces or indents before them. Lines of code indented inside of an IF statement should be one tab key over. Getting the indentation right is crucial because this is the only way we can tell the computer which lines of code are inside the IF statement and which are outside. We need to be careful here though because now our control flow branches. If the user orders pad Thai, this program works fine, but if the user orders something else, we get a name error. The variable protein is only defined inside the IF statement. If the condition is false, this assignment statement doesn't execute, so the computer doesn't know a variable protein. To fix this, we either need to make sure we're only accessing the variable protein inside the IF statement where we're guaranteed it exists, or we need to initialize the variable protein before the IF statement, which guarantees that it's always defined. It's common in situations like this to initialize the variable to an empty or placeholder value like the empty string or no protein. Now there's no error on either possible path. If the order is equal to pad Thai or if it's not. Now that our control flow branches, when we run a program, we're only testing one of perhaps many possible passive execution through the code. Just because it works for one case doesn't mean it works for the other, and it's up to us to test for that. Otherwise, it'll be our users who suffer when they're the first ones to find the bug.\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n",
    "t_urdu": "- [انسٹرکٹر] ہم\n اپنے پروگراموں میں سوالات پوچھنے کے لیے بولین ایکسپریشنز کا استعمال کر سکتے ہیں، لیکن\nجواب کی بنیاد پر ہم برانچ کنٹرول فلو کیسے کر سکتے ہیں؟ ایسا کرنے کے لیے ہمیں شرائط کی ضرورت ہے۔ شرائط انتخاب کی بنیاد بنتی ہیں۔ وہ کمپیوٹر کو یہ فیصلہ کرنے کی اجازت دیتے ہیں کہ کون سا کوڈ چلنا ہے اس\nپر منحصر ہے کہ آیا کسی مخصوص سوال یا\nحالت کا جواب درست ہے یا غلط۔  مشروط کا پہلا ٹکڑا\nIF بیان ہے۔ ہم\nکلیدی لفظ If کے ساتھ IF اسٹیٹمنٹ شروع کرتے ہیں۔ پھر ہم اپنی شرط شامل کرتے ہیں، جو کوئی بھی بولین اظہار ہو سکتا ہے۔ ہم اس لائن کو ہمیشہ بڑی آنت کے ساتھ ختم کرتے ہیں کیونکہ ایک IF بیان\nدو حصوں میں آتا ہے۔ یہ پہلا حصہ، جو شرط ہے اور دوسرا حصہ، جس کو\nچلانے کی ہدایات ہیں اگر اس شرط کی درستی کا اندازہ ہوتا ہے۔ Python میں، ہم\nانڈینٹیشن کا استعمال کرتے ہوئے ان ہدایات کی نشاندہی کرتے ہیں۔  اس شرط کے فوراً بعد کوڈ کی کوئی بھی لائن\n جو ایک لیول میں انڈینٹ کی جاتی ہے ان کو IF سٹیٹمنٹ کے اندر سمجھا جاتا ہے، اگر کنڈیشن درست ہونے کا اندازہ لگایا جاتا ہے، تو کمپیوٹر\n IF سٹیٹمنٹ کے اندر اندر کی گئی تمام ہدایات کو ترتیب سے عمل میں لائے گا۔ جب یہ ہو جائے گا، تو یہ باقی پروگرام کو معمول کے مطابق انجام دے گا۔ اگر حالت غلط پر تشخیص کرتی ہے، تو کمپیوٹر\nکوڈ کی ان تمام لائنوں کو چھوڑ دے گا جو\nاس IF سٹیٹمنٹ کے اندر اندر کی گئی ہیں۔  اس کے بجائے، یہ براہ راست\nکوڈ کی اگلی لائن پر جائے گا جو IF بیان سے باہر ہے۔ اس کا مطلب ہے کہ کوڈ کی پہلی لائن جو کہ ابتدائی اگر کے طور پر اسی سطح پر انڈینٹ کی گئی ہے۔ آئیے ایک مثال آزماتے ہیں۔ یہاں ہمارے پاس بولین ایکسپریشن ہے، num_orders برابر\n10 کے برابر ہے، جو سوال پوچھتا ہے، کیا یہ گاہک کا 10 واں آرڈر ہے؟  اس کے بعد ہم اس بولین\nویلیو کو اپنے IF بیان میں استعمال کر سکتے ہیں۔ ہم IF اسٹیٹمنٹ کے اندر ایک پرنٹ فنکشن کال انڈینٹ کریں گے \nاور ایک باہر۔ اندر والا صرف اس صورت میں\nعمل میں آئے گا جب یہ 10 واں آرڈر ہو، یعنی اگر متغیر 10 ویں آرڈر میں بولین ویلیو ٹرو پر مشتمل ہو۔ ہم اسے متغیر کے بغیر بھی لکھ سکتے ہیں\n جہاں ہم صرف IF بیان میں اس\nپورے بولین اظہار کو ان لائن کرتے ہیں۔ آئیے معلوم کرتے ہیں کہ\nکمپیوٹر اسے کیسے انجام دیتا ہے۔ یہ پہلی لائن سے شروع ہوتا ہے اور متغیر num_orders کو ایک قدر 10 تفویض کرتا ہے۔\n پھر یہ اس IF بیان کو مارتا ہے، تو پہلے یہ بولین اظہار کا اندازہ کرتا ہے۔\n 10 10 کے برابر ہے، لہذا\nاس کا اندازہ درست ہے۔ کیونکہ یہ سچ ہے، کمپیوٹر IF سٹیٹمنٹ کے اندر انڈینٹ کردہ\nکوڈ کی لائنوں پر عمل درآمد کرے گا۔ سب سے پہلے، یہ پرنٹ کرے گا، \"آپ کا آرڈر مفت ہے!\" اور پھر یہ متغیر num_orders کو صفر کی قدر تفویض کرے گا۔ پھر یہ باقی پروگرام میں ترتیب سے چلتا رہتا ہے، تو یہ num_orders کی ویلیو پرنٹ کرے گا\n، جو اب صفر ہے۔ اب اس کے بجائے کہتے ہیں کہ num_orders اصل میں تین پر سیٹ کیا گیا تھا۔ جب کمپیوٹر اس پروگرام کو چلاتا ہے، تو یہ num_orders کی قدر تین کو تفویض کرے گا،\n بولین ایکسپریشن کا جائزہ لے گا۔ تین 10 کے برابر نہیں ہے\n، لہذا یہ غلط ہے، اور پھر چونکہ یہ غلط ہے، ہم IF سٹیٹمنٹ کے اندر انڈینٹ کردہ کوڈ کی لائنوں کو چھوڑ دیں گے۔ یہ\nباہر کوڈ کی اگلی لائن پر جائے گا، جو پرنٹ نمبر_آرڈرز ہے،\nتو یہ تین پرنٹ کرے گا۔ نوٹ کریں کہ اگر ہم نے\nکوڈ نمبر_آرڈرز کی لائن کو صفر کے برابر نہیں کیا، تو\nاسے IF اسٹیٹمنٹ سے باہر سمجھا جائے گا،\nلہذا غلط کیس میں، num_orders صفر پر سیٹ ہوں گے، اور پھر یہ صفر پرنٹ کرے گا۔ حقیقی صورت میں، ہم\nپرنٹ کریں گے، \"آپ کا آرڈر مفت ہے۔\" پھر ہم num_orders کو صفر پر سیٹ کریں گے، اور پھر ہم صفر پرنٹ کریں گے۔ آپ IF سٹیٹمنٹس کو\nکسی بھی بولین ایکسپریشنز کے ساتھ شرائط کے طور پر لکھ سکتے ہیں، اور آپ ان کے اندر جتنی بھی ہدایات چاہیں ڈال سکتے ہیں۔ \n اس مشروط کے ساتھ، میں اس بات کو یقینی بنا سکتا ہوں کہ صرف فالو اپ سوال، چکن یا ٹوفو، اگر\nصارف نے پیڈ تھائی کا آرڈر دیا ہے، کیونکہ اگر وہ پپیتے کا سلاد آرڈر کرتے ہیں، تو اس سوال کا کوئی مطلب نہیں ہے۔ نوٹ کریں کہ زیادہ تر IDEs میں ہم\nٹیب کی کا استعمال کرتے ہوئے انڈینٹ کرتے ہیں۔ کوڈ کی ہماری معیاری لائنوں کو براہ راست\nبائیں مارجن کے ساتھ ملنا چاہیے۔ یعنی\nان کے سامنے کوئی خالی جگہ یا حاشیہ نہیں ہونا چاہیے۔  IF سٹیٹمنٹ کے اندر کوڈ کی لائنیں\n ایک ٹیب کی کلید کے اوپر ہونی چاہئیں۔ انڈینٹیشن کو درست کرنا بہت ضروری ہے کیونکہ یہ واحد\nطریقہ ہے جس سے ہم کمپیوٹر کو بتا سکتے ہیں کہ کوڈ کی کون سی لائنیں\nIF سٹیٹمنٹ کے اندر ہیں اور کون سی باہر ہیں۔ ہمیں یہاں محتاط رہنے کی ضرورت ہے کیونکہ اب ہمارے کنٹرول کے بہاؤ کی شاخیں ہیں۔ اگر صارف پیڈ تھائی آرڈر کرتا ہے، تو\nیہ پروگرام ٹھیک کام کرتا ہے، لیکن اگر صارف کچھ\nاور آرڈر کرتا ہے، تو ہمیں نام کی خرابی ملتی ہے۔ متغیر پروٹین کی وضاحت صرف IF بیان کے اندر کی گئی ہے۔ اگر شرط غلط ہے، تو اس اسائنمنٹ سٹیٹمنٹ پر عمل نہیں ہوتا، لہذا کمپیوٹر\nمتغیر پروٹین کو نہیں جانتا۔ اس کو ٹھیک کرنے کے لیے، ہمیں یا تو یہ یقینی بنانا ہوگا کہ ہم صرف IF اسٹیٹمنٹ کے اندر موجود متغیر پروٹین تک رسائی حاصل کر رہے ہیں جہاں\nہمیں اس کی موجودگی کی ضمانت دی گئی ہے، یا ہمیں\n IF اسٹیٹمنٹ سے پہلے متغیر پروٹین کو شروع کرنے کی ضرورت ہے، جو اس بات کی ضمانت دیتا ہے کہ اس کی ہمیشہ تعریف کی جاتی ہے۔ اس طرح کے حالات میں متغیر کو خالی یا پلیس ہولڈر ویلیو جیسے خالی سٹرنگ یا کوئی پروٹین سے شروع کرنا عام ہے۔ اب\nکسی بھی ممکنہ راستے پر کوئی خرابی نہیں ہے۔ اگر آرڈر\nپیڈ تھائی کے برابر ہے یا اگر نہیں ہے۔ اب جب کہ ہماری کنٹرول فلو\nبرانچز، جب ہم کوئی پروگرام چلاتے ہیں، تو ہم صرف کوڈ کے ذریعے ممکنہ طور پر بہت سے غیر فعال\nعمل میں سے ایک کی جانچ کر رہے ہیں۔ صرف اس لیے کہ یہ ایک کیس کے لیے کام کرتا ہے اس کا مطلب یہ نہیں ہے کہ یہ دوسرے کے لیے کام کرتا ہے، اور اس کی جانچ کرنا ہم پر منحصر ہے۔ بصورت دیگر، یہ ہمارے صارفین ہوں گے جو اس وقت نقصان اٹھائیں گے جب وہ\nبگ ڈھونڈنے والے پہلے ہوں گے۔",
    "t_spanish": "- [Instructor] Podemos\nusar expresiones booleanas para hacer preguntas en nuestros programas, pero ¿cómo podemos bifurcar el\nflujo de control en función de la respuesta? Para hacer eso, necesitamos condicionales. Los condicionales forman la base de la selección. Permiten que la computadora decida qué código ejecutar dependiendo\nde si la respuesta a una pregunta o\ncondición específica es verdadera o falsa. La primera parte de un\ncondicional es la declaración IF. Comenzamos una declaración IF\ncon la palabra clave If. Luego agregamos nuestra condición, que puede ser cualquier expresión booleana. Siempre terminamos esta línea con dos puntos porque una declaración IF\nviene en dos partes. Esta primera parte, que es la condición y la segunda parte, que\nson las instrucciones a ejecutar si esa condición se evalúa como verdadera. En Python, indicamos esas\ninstrucciones mediante sangría. Cualquier línea de código inmediatamente\ndespués de esa condición que tenga sangría de un nivel se considera dentro de esa declaración IF; si la condición se evalúa como verdadera, la computadora\nejecutará todas las instrucciones sangradas dentro de la declaración IF en orden. Cuando termine, continuará ejecutando el resto del programa normalmente. Si la condición se evalúa como falsa, la computadora omitirá\ntodas las líneas de código sangradas dentro\nde esa declaración IF. En cambio, saltará directamente\na la siguiente línea de código que está fuera de la declaración IF. Eso significa la primera línea de código que tiene sangría al mismo nivel que el if inicial. Probemos un ejemplo. Aquí tenemos la expresión booleana, num_orders es igual a\n10, que plantea la pregunta: ¿ es este el décimo pedido del cliente? Luego podemos usar este\nvalor booleano en nuestra declaración IF. Aplicaremos sangría a una llamada a la función de impresión dentro de la\ndeclaración IF y otra afuera. El que está dentro solo se\nejecutará si es de décimo orden, es decir, si la variable de décimo orden contiene el valor booleano Verdadero. También podemos escribir esto\nsin la variable donde simplemente alineamos esa\nexpresión booleana completa en la declaración IF. Rastreemos cómo la\ncomputadora ejecuta esto. Comienza con la primera línea y asigna un valor 10 a\nla variable num_orders. Luego llega a esta declaración IF, por lo que primero evalúa\nla expresión booleana. 10 es igual a 10, por lo que\nesto se evalúa como verdadero. Como es cierto, la computadora\nejecutará las líneas de código indentadas dentro de la declaración IF. Primero, imprimirá: \"¡Su pedido es gratis!\" Y luego asignará el valor cero a la variable num_orders. Luego continúa avanzando por el resto del programa en orden, por lo que imprimirá el valor de\nnum_orders, que ahora es cero. Ahora digamos que num_orders originalmente estaba establecido en tres. Cuando la computadora ejecute este programa, asignará el valor\ntres a num_orders y evaluará la expresión booleana. Tres no es igual a\n10, entonces esto es falso, y luego, como es falso, omitiremos las líneas de código sangradas dentro de la declaración IF. Saltará a la siguiente\nlínea de código exterior, que es print num_orders,\npor lo que imprimirá tres. Tenga en cuenta que si no\nsangramos la línea de código num_orders igual a cero, se\nconsideraría fuera de la declaración IF,\npor lo que en el caso falso, num_orders se establecería en cero y luego imprimiría cero. En el caso real,\nimprimiríamos \"Su pedido es gratuito\". Luego estableceríamos num_orders en cero y luego imprimiríamos cero. Puede escribir declaraciones IF\ncon cualquier expresión booleana como condición, y puede poner tantas instrucciones\ncomo desee dentro de ellas. Con este condicional, podría asegurarme de hacer la pregunta de seguimiento solo, pollo o tofu, si el\nusuario pidió pad Thai, porque si pide ensalada de papaya, esa pregunta no tiene sentido. Tenga en cuenta que en la mayoría de los IDE aplicamos\nsangrías utilizando la tecla de tabulación. Nuestras líneas de código estándar deben alinearse directamente\ncon el margen izquierdo.  Es decir, no debe haber\nespacios ni sangrías delante de ellos. Las líneas de código sangradas\ndentro de una declaración IF deben estar una tecla de tabulación por encima. Obtener la sangría correcta es crucial porque es la única\nforma en que podemos decirle a la computadora qué líneas de código están\ndentro de la declaración IF y cuáles están afuera. Sin embargo, debemos tener cuidado aquí porque ahora nuestro flujo de control se bifurca. Si el usuario pide pad Thai,\neste programa funciona bien, pero si el usuario pide algo\nmás, obtenemos un error de nombre. La proteína variable solo se define dentro de la declaración IF. Si la condición es falsa, esta declaración de asignación no se ejecuta, por lo que la computadora no\nconoce una proteína variable. Para solucionar este problema, debemos asegurarnos de que solo accedemos a la proteína variable dentro de la declaración IF donde\ntenemos garantizado que existe, o debemos inicializar\nla proteína variable antes de la declaración IF, lo que garantiza que siempre esté definida. Es común en situaciones como ésta inicializar la variable a un valor vacío o de marcador de posición como la cadena vacía o sin proteína. Ahora no hay ningún error en\nninguna de las rutas posibles. Si el pedido es igual al\npad thai o si no lo es. Ahora que nuestro flujo de control\nse bifurca, cuando ejecutamos un programa, solo estamos probando una de las muchas posibles\nejecuciones pasivas a través del código.  El hecho de que funcione en un caso no significa que funcione en el otro, y depende de nosotros probarlo. De lo contrario, serán nuestros usuarios los que sufrirán al ser los primeros\nen encontrar el error.",
    "t_arabic": "- [المدرس] يمكننا\nاستخدام التعبيرات المنطقية لطرح الأسئلة في برامجنا، ولكن كيف يمكننا تفرع\nتدفق التحكم بناءً على الإجابة؟ للقيام بذلك، نحن بحاجة إلى الشرطية. تشكل الشروط الشرطية أساس الاختيار. إنها تسمح للكمبيوتر بتحديد الكود الذي سيتم تشغيله اعتمادًا\nعلى ما إذا كانت الإجابة على سؤال أو\nشرط معين صحيحة أم خاطئة. الجزء الأول من\nالجملة الشرطية هو عبارة IF. نبدأ عبارة IF\nبالكلمة الأساسية If. ثم نضيف شرطنا، والذي يمكن أن يكون أي تعبير منطقي. نحن دائمًا ننهي هذا السطر بنقطتين لأن عبارة IF\nتأتي في جزأين. هذا الجزء الأول، وهو الشرط، والجزء الثاني،\nوهو التعليمات التي سيتم تشغيلها إذا تم تقييم هذا الشرط على أنه صحيح. في بايثون، نشير إلى تلك\nالتعليمات باستخدام المسافة البادئة.  يتم اعتبار أي أسطر من التعليمات البرمجية التي\nتلي هذا الشرط مباشرة والتي تم وضع مسافة بادئة لها على مستوى واحد داخل عبارة IF، إذا تم تقييم الشرط على أنه صحيح، فسوف يستمر الكمبيوتر في\nتنفيذ جميع التعليمات التي تم وضع مسافة بادئة لها داخل عبارة IF بالترتيب. عند الانتهاء، سوف يستمر في تنفيذ بقية البرنامج كالمعتاد. إذا تم تقييم الشرط على خطأ، فسيتخطى الكمبيوتر\nجميع أسطر التعليمات البرمجية التي تم وضع مسافة بادئة لها داخل\nعبارة IF تلك. وبدلاً من ذلك، سينتقل مباشرةً\nإلى السطر التالي من التعليمات البرمجية الموجود خارج عبارة IF. وهذا يعني أن السطر الأول من التعليمات البرمجية تم وضع مسافة بادئة له على نفس مستوى ذلك الحرف الأولي if. دعونا نجرب مثالا. لدينا هنا التعبير المنطقي، num_orders يساوي\n10، والذي يطرح السؤال، هل هذا هو الطلب العاشر للعميل؟ يمكننا بعد ذلك استخدام هذه\nالقيمة المنطقية في بيان IF الخاص بنا. سنقوم بوضع مسافة بادئة لاستدعاء دالة طباعة واحدة داخل\nعبارة IF وأخرى خارجها. سيتم تنفيذ المتغير الداخلي فقط\nإذا كان الترتيب العاشر، أي إذا كان المتغير هو الترتيب العاشر ويحتوي على القيمة المنطقية True. يمكننا أيضًا كتابة هذا\nبدون المتغير حيث نقوم فقط بتضمين هذا\nالتعبير المنطقي بالكامل في عبارة IF. دعونا نتتبع كيفية\nتنفيذ الكمبيوتر لهذا. يبدأ بالسطر الأول ويعين القيمة 10 للمتغير\nnum_orders. ثم يقوم بالنقر على عبارة IF هذه، لذا يقوم أولاً بتقييم\nالتعبير المنطقي. 10 يساوي 10، لذا\nيصبح هذا صحيحًا. نظرًا لأن هذا صحيح، فسيقوم الكمبيوتر\nبتنفيذ سطور التعليمات البرمجية التي تم وضع مسافة بادئة لها داخل عبارة IF. أولاً، ستتم طباعة \"طلبك مجاني!\" وبعد ذلك سيتم تعيين القيمة صفر للمتغير num_orders. ثم يستمر في التحرك خلال بقية البرنامج بالترتيب، لذلك سيطبع قيمة\nnum_orders، التي أصبحت الآن صفرًا. لنفترض الآن أنه تم تعيين num_orders في الأصل على ثلاثة. عندما يقوم الكمبيوتر بتنفيذ هذا البرنامج، فإنه سيعين القيمة\nثلاثة لـ num_orders، ويقيم التعبير المنطقي. ثلاثة لا يساوي\n10، لذا فهذا خطأ، ولأنه خطأ، فسنتخطى أسطر التعليمات البرمجية التي تم وضع مسافة بادئة لها داخل عبارة IF. سوف ينتقل إلى\nالسطر التالي من التعليمات البرمجية بالخارج، وهو طباعة num_orders،\nلذلك سيتم طباعة ثلاثة. لاحظ أنه إذا لم نضع\nمسافة بادئة لسطر الكود num_orders الذي يساوي الصفر،\nفسيتم اعتباره خارج عبارة IF،\nلذلك في الحالة الخاطئة، سيتم تعيين num_orders على صفر، ثم ستتم طباعة صفر. في الحالة الحقيقية،\nسنطبع عبارة \"طلبك مجاني\". ثم نقوم بتعيين num_orders على صفر، ثم نطبع صفرًا. يمكنك كتابة عبارات IF\nمع أي تعبيرات منطقية كشروط، ويمكنك وضع أي عدد\nتريده من التعليمات داخلها. مع هذا الشرط، يمكنني التأكد من طرح سؤال المتابعة فقط، الدجاج أو التوفو، إذا\nطلب المستخدم طبق باد تاي، لأنه إذا طلب سلطة البابايا، فإن هذا السؤال ليس له معنى. لاحظ أنه في معظم بيئة التطوير المتكاملة (IDEs) نقوم\nبوضع مسافة بادئة باستخدام مفتاح tab.  يجب أن تصطف أسطر التعليمات البرمجية القياسية الخاصة بنا مباشرة\nمع الهامش الأيسر.  أي أنه يجب ألا تكون هناك\nمسافات أو مسافات بادئة قبلها.  يجب أن تكون أسطر التعليمات البرمجية التي تم وضع مسافة بادئة لها\nداخل عبارة IF أعلى بمفتاح علامة تبويب واحدة.  يعد الحصول على المسافة البادئة بشكل صحيح أمرًا بالغ الأهمية لأن هذه هي\nالطريقة الوحيدة التي يمكننا من خلالها إخبار الكمبيوتر عن أسطر التعليمات البرمجية الموجودة\nداخل عبارة IF وأيها خارجها. نحن بحاجة إلى توخي الحذر هنا لأن تدفق التحكم لدينا أصبح الآن متفرعًا. إذا طلب المستخدم لوحة التايلاندية، فإن\nهذا البرنامج يعمل بشكل جيد، ولكن إذا طلب المستخدم شيئًا\nآخر، فسنحصل على خطأ في الاسم.  يتم تعريف البروتين المتغير فقط داخل عبارة IF. إذا كان الشرط خاطئًا، فلن يتم تنفيذ بيان المهمة هذا، وبالتالي لا\nيعرف الكمبيوتر البروتين المتغير. لإصلاح ذلك، نحتاج إما إلى التأكد من أننا نصل فقط إلى البروتين المتغير داخل عبارة IF حيث\nنضمن وجوده، أو نحتاج إلى تهيئة\nالبروتين المتغير قبل عبارة IF، مما يضمن تعريفه دائمًا. من الشائع في مثل هذه المواقف تهيئة المتغير إلى قيمة فارغة أو عنصر نائب مثل السلسلة الفارغة أو عدم وجود بروتين. الآن لا يوجد خطأ في\nأي من المسارين المحتملين. إذا كان الطلب يساوي\nالوسادة التايلاندية أو إذا لم يكن كذلك. الآن بعد أن تفرعنا من تدفق التحكم\n، عندما نقوم بتشغيل برنامج، فإننا نختبر فقط واحدًا من العديد من\nعمليات التنفيذ السلبي المحتملة من خلال الكود. فقط لأنه يعمل في حالة واحدة لا يعني أنه يعمل في الحالة الأخرى، والأمر متروك لنا لاختبار ذلك. وبخلاف ذلك، سيكون مستخدمونا هم من يعانون عندما يكونون أول\nمن يعثر على الخطأ.",
    "t_italian": "- [Istruttore] Possiamo\nutilizzare espressioni booleane per porre domande nei nostri programmi, ma come possiamo ramificare il\nflusso di controllo in base alla risposta? Per fare ciò, abbiamo bisogno dei condizionali. I condizionali costituiscono la base della selezione. Permettono al computer di decidere quale codice eseguire a seconda\nche la risposta a una domanda o\ncondizione specifica sia vera o falsa. La prima parte del\ncondizionale è l'istruzione IF. Iniziamo un'istruzione IF\ncon la parola chiave If. Quindi aggiungiamo la nostra condizione, che può essere una qualsiasi espressione booleana. Terminiamo sempre questa riga con i due punti perché un'istruzione IF è\ndivisa in due parti. La prima parte, che è la condizione, e la seconda parte, che\nsono le istruzioni da eseguire se la condizione risulta vera. In Python indichiamo quelle\nistruzioni usando il rientro. Qualsiasi riga di codice immediatamente\nsuccessiva a quella condizione che è rientrata di un livello viene considerata all'interno dell'istruzione IF, se la condizione risulta vera, il computer\neseguirà tutte le istruzioni rientrate all'interno dell'istruzione IF in ordine. Al termine, continuerà a eseguire il resto del programma normalmente. Se la condizione risulta falsa, il computer salterà\ntutte le righe di codice rientrate all'interno\ndell'istruzione IF. Passerà invece direttamente\nalla riga di codice successiva esterna all'istruzione IF. Ciò significa che la prima riga di codice è rientrata allo stesso livello dell'if iniziale. Proviamo un esempio. Qui abbiamo l'espressione booleana, num_orders uguale uguale a\n10, che pone la domanda: è questo il decimo ordine del cliente? Possiamo quindi utilizzare questo\nvalore booleano nella nostra istruzione IF. Faremo rientrare una chiamata alla funzione print all'interno dell'istruzione IF\ne una all'esterno. Quella interna verrà\neseguita solo se è del 10° ordine, cioè se la variabile di 10° ordine contiene il valore booleano True. Possiamo anche scriverlo\nsenza la variabile dove inlineiamo semplicemente l'\nintera espressione booleana nell'istruzione IF. Tracciamo come il\ncomputer esegue questa operazione. Inizia con la prima riga e assegna un valore 10\nalla variabile num_orders. Quindi colpisce questa istruzione IF, quindi prima valuta\nl'espressione booleana. 10 è uguale a 10, quindi\nrisulta vero. Poiché è vero, il computer\neseguirà le righe di codice rientrate all'interno dell'istruzione IF. Per prima cosa verrà stampato \"Il tuo ordine è gratuito!\" E poi assegnerà il valore zero alla variabile num_orders. Quindi continua a spostarsi attraverso il resto del programma in ordine, quindi stamperà il valore di\nnum_orders, che ora è zero. Ora diciamo invece che num_orders era originariamente impostato su tre. Quando il computer esegue questo programma, assegnerà il valore\ntre a num_orders, valuterà l'espressione booleana. Tre non è uguale a\n10, quindi è falso e, poiché è falso, salteremo le righe di codice rientrate all'interno dell'istruzione IF. Passerà alla\nriga di codice successiva all'esterno, che è print num_orders,\nquindi ne stamperà tre. Tieni presente che se non\nindentassimo la riga di codice num_orders uguale a zero,\nverrebbe considerata all'esterno dell'istruzione IF,\nquindi nel caso false, num_orders verrebbe impostato su zero e quindi stamperebbe zero. Nel caso vero,\nstamperemmo \"Il tuo ordine è gratuito\". Quindi imposteremo num_orders su zero e stamperemo zero. Puoi scrivere istruzioni IF\ncon qualsiasi espressione booleana come condizione e puoi inserire tutte le istruzioni\nche desideri al loro interno. Con questo condizionale, potrei assicurarmi di porre la domanda successiva, pollo o tofu, solo se l'\nutente ha ordinato il pad Thai, perché se ordina l'insalata di papaya, quella domanda non ha senso. Tieni presente che nella maggior parte degli IDE\nrientriamo utilizzando il tasto tab. Le nostre righe di codice standard dovrebbero essere allineate direttamente\ncon il margine sinistro. Cioè, non dovrebbero esserci\nspazi o rientri prima di loro. Le righe di codice rientrate\nall'interno di un'istruzione IF dovrebbero essere sovrapposte al tasto tab. Ottenere il rientro corretto è fondamentale perché questo è l'unico\nmodo in cui possiamo dire al computer quali righe di codice si trovano\nall'interno dell'istruzione IF e quali sono all'esterno. Dobbiamo stare attenti qui però perché ora il nostro flusso di controllo si ramifica. Se l'utente ordina Pad Thai,\nquesto programma funziona correttamente, ma se l'utente ordina\nqualcos'altro, viene visualizzato un errore nel nome. La variabile proteina è definita solo all'interno dell'istruzione IF. Se la condizione è falsa, questa istruzione di assegnazione non viene eseguita, quindi il computer non\nriconosce una proteina variabile. Per risolvere questo problema, dobbiamo assicurarci di accedere solo alla proteina variabile all'interno dell'istruzione IF dove è\ngarantito che esista, oppure dobbiamo inizializzare\nla proteina variabile prima dell'istruzione IF, il che garantisce che sia sempre definita. In situazioni come questa è comune inizializzare la variabile su un valore vuoto o segnaposto come la stringa vuota o nessuna proteina. Ora non ci sono errori su\nnessuno dei due possibili percorsi. Se l'ordine è uguale a\nPad Thai oppure no. Ora che il nostro flusso di controllo\nsi ramifica, quando eseguiamo un programma, stiamo solo testando una delle forse molte possibili\nesecuzioni passive attraverso il codice. Solo perché funziona per un caso non significa che funzioni anche per l'altro, e sta a noi verificarlo. Altrimenti saranno i nostri utenti a soffrirne quando saranno i primi\na scoprire il bug."
}