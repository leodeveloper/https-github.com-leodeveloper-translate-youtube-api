{
    "source": "p7pJMvD2sag",
    "youtubelink": "https://www.youtube.com/watch?v=p7pJMvD2sag",
    "t_english": "- [Presenter] How does the computer evaluate expressions with the logical operators and or and not? To find out, let's explore the order of operations for compound Boolean expressions. Imagine we're working on a program to check if a specific song matches the filters for a specific playlist. This expression asks, are the song's beats per minute both greater than or equal to 150, and less than or equal to 180? Logical operators like this and come last in the order of operations. So the computer evaluates the two sides separately first. Let's say the variable BPM contains the value 200. The comparison operators greater than or equal to and less than or equal to have the same level of precedence, so the computer evaluates left to right. So we substitute in that 200 on the left-hand side first and simplify. 200 is greater than or equal to 150, so this evaluates to true. Then we jump to the right-hand side. 200 is not less than or equal to 180, so this evaluates to false. Now that we've simplified both sides down to a Boolean value, we evaluate the and. An expression with the and operator only evaluates to true if both sides are true. So a true and a false evaluates to false. And boom, the computer has its answer. Let's try an expression where there are multiple logical operators. This asks the question, is the genre any of the spellings of lo-fi? Let's say the variable genre contains the string lo-fi. We evaluate the expressions around the logical operators first and then apply the ors. We start with the leftmost expression. These strings are not equal, so this evaluates to false. We jump to the second expression. These strings are equal, so this evaluates to true. And then the third part, these strings are not equal, so this evaluates to false. Now that we're all simplified, we take a look at the ors. An expression with the OR operator evaluates to true if at least one of the sides is true. False or true evaluates to true and then true or false evaluates to true. Now you may be thinking, \"Whoa, whoa, did I even need to evaluate that last part?\" Once I knew that second expression evaluated to true, I knew that my final answer was going to be true. As it's evaluating, the computer makes the same optimization. We called this short circuit evaluation or lazy evaluation. In its laziness, the computer stops evaluating as soon as it knows the final answer. With the or operator the computer stops evaluating as soon as it finds a side that evaluates to true because no matter what's on the other side, the expression will always evaluate to true. True or true evaluates to true and true or false also evaluates to true. With the and operator we have the opposite. The computer stops as soon as it finds a side that evaluates to false. No matter what's on the other side the whole expression will evaluate to false. Because false and true evaluates to false and false and false also evaluates to false. Okay, so the computer's saving itself some work. Why do I care? Consider this Boolean expression. It looks pretty sensible, but what if the variable group size contains the value zero? The computer can't divide by zero. So this gives a runtime error. Well, we could just not do that, but we might not control the value of group size. Maybe it's set by user input. To solve this, we can check that group size doesn't equal zero first. If group size is equal to zero, the left-hand side will evaluate to false and the computer will short circuit. It'll jump to the conclusion that the whole expression must evaluate to false and won't bother evaluating the right-hand side, thus avoiding the division by zero. We can use this pattern across our programs, taking advantage of short circuit evaluation to check for preconditions that allow us to avoid possible errors. Last bit. What about the not operator? The not operator takes precedence over the and and or operators. That means this expression really asks, is the genre not equal to rock and is the BPM greater than 130? Now, we wanna be careful about overusing the not operator when we don't need to because it tends to make things more confusing. For example, this expression is just equivalent to genre not equals rock and BPM greater than 130. If instead I put parentheses here, I would be negating the whole expression. This asks, is it not both a rock song and a fast song? That's equivalent to the expression is the genre not equal to rock or is the BPM less than or equal to 130? If either of these conditions is true, then this and expression would evaluate to false, which means not it would evaluate to true. Now you're probably starting to understand why I said to use the not operator sparingly. If you do need to negate a compound Boolean expression, it's often easier to understand if you break it down into multiple parts. Otherwise, the not operator tends to make your program a bit less readable. Just like if I said something like \"I prefer not blue colors or I'm going to not not in this video now.\"\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n",
    "t_urdu": "- [پیش کنندہ]\nکمپیوٹر منطقی آپریٹرز کے ساتھ اظہار کی جانچ کیسے کرتا ہے اور یا نہیں؟  یہ جاننے کے لیے، آئیے\n کمپاؤنڈ بولین ایکسپریشنز کے لیے کارروائیوں کی ترتیب کو تلاش کرتے ہیں۔ تصور کریں کہ ہم\nایک پروگرام پر کام کر رہے ہیں تاکہ یہ چیک کیا جا سکے کہ آیا کوئی مخصوص گانا کسی مخصوص پلے لسٹ کے فلٹرز سے میل کھاتا ہے۔ یہ اظہار پوچھتا ہے، کیا\nگانے کی دھڑکن فی منٹ 150 سے زیادہ یا اس کے برابر، اور 180 سے کم یا اس کے برابر ہے؟ منطقی آپریٹرز اس کو پسند کرتے ہیں اور آپریشن کی ترتیب میں سب سے آخر میں آتے ہیں۔ تو کمپیوٹر\nپہلے دونوں اطراف کا الگ الگ جائزہ لیتا ہے۔ ہم کہتے ہیں کہ متغیر BPM میں\n200 کی قدر ہوتی ہے۔ موازنہ آپریٹرز اس سے\nزیادہ یا اس کے برابر اور اس سے کم یا اس کے برابر\nترجیح کی سطح رکھتے ہیں، لہذا کمپیوٹر بائیں سے دائیں جانچتا ہے۔ تو ہم پہلے بائیں جانب اس 200 کو تبدیل کرتے ہیں اور آسان بناتے ہیں۔ 200 150 سے بڑا یا اس کے برابر ہے، لہذا اس کا اندازہ درست ہے۔ پھر ہم دائیں طرف چھلانگ لگاتے ہیں۔ 200 180 سے کم یا اس کے برابر نہیں ہے، لہذا اس کا اندازہ غلط ہوتا ہے۔ اب جب کہ ہم نے دونوں اطراف کو بولین ویلیو تک آسان کر دیا ہے، ہم اور کا اندازہ کرتے ہیں۔ اور آپریٹر کے ساتھ ایک اظہار\nصرف درست پر جانچتا ہے اگر دونوں اطراف سچے ہیں۔ تو ایک سچے اور جھوٹے کا غلط پر اندازہ ہوتا ہے۔ اور بوم، کمپیوٹر کے پاس اس کا جواب ہے۔ آئیے ایک اظہار کی کوشش کریں جہاں متعدد\nمنطقی آپریٹرز ہوں۔ یہ سوال پوچھتا ہے، کیا نوع\nlo-fi کے ہجے میں سے کوئی ہے؟ ہم کہتے ہیں کہ متغیر کی صنف\nسٹرنگ لو فائی پر مشتمل ہے۔ ہم پہلے منطقی آپریٹرز کے ارد گرد اظہار کا جائزہ لیتے ہیں \nاور پھر ors کا اطلاق کرتے ہیں۔ ہم سب سے بائیں اظہار کے ساتھ شروع کرتے ہیں. یہ تار برابر نہیں ہیں،\nاس لیے اس کا اندازہ غلط ہوتا ہے۔ ہم دوسرے اظہار کی طرف کودتے ہیں۔ یہ تار برابر ہیں،\nاس لیے اس کا درست اندازہ ہوتا ہے۔ اور پھر تیسرا حصہ،\nیہ تار برابر نہیں ہیں، تو اس کا اندازہ غلط ہوتا ہے۔ اب جب کہ ہم سب آسان ہو گئے ہیں،\nہم ors پر ایک نظر ڈالتے ہیں۔ OR آپریٹر کے ساتھ ایک اظہار\nدرست میں جانچتا ہے اگر کم از کم ایک طرف درست ہے۔ جھوٹے یا سچے کو سچ کا اندازہ ہوتا ہے اور پھر سچے یا غلط کو سچ کا اندازہ ہوتا ہے۔ اب آپ سوچ رہے ہوں گے، \"واہ، واہ، کیا مجھے\nاس آخری حصے کا جائزہ لینے کی بھی ضرورت تھی؟\" ایک بار جب مجھے معلوم ہوا کہ دوسرے\nاظہار کی درستی کی گئی تو میں جانتا تھا کہ میرا آخری جواب\nدرست ہونے والا ہے۔ جیسا کہ یہ اندازہ کر رہا ہے، کمپیوٹر وہی اصلاح کرتا ہے۔ ہم نے اسے شارٹ سرکٹ کی\nتشخیص یا سست تشخیص کہا۔ اپنی سستی میں،\nکمپیوٹر جیسے ہی اسے حتمی جواب معلوم ہوتا ہے تشخیص کرنا چھوڑ دیتا ہے۔ یا آپریٹر کے ساتھ\nکمپیوٹر جیسے ہی کوئی ایسا رخ پاتا ہے\nجو اسے درست سمجھتا ہے جانچنا بند کر دیتا ہے کیونکہ اس سے کوئی فرق نہیں پڑتا ہے کہ\nدوسری طرف کچھ بھی ہو، اظہار\nہمیشہ سچ میں ہی جانچے گا۔ سچ یا سچ کا اندازہ سچ پر ہوتا ہے اور سچ یا غلط کا بھی سچ کا اندازہ ہوتا ہے۔ اور آپریٹر کے ساتھ\nہمارے پاس اس کے برعکس ہے۔ کمپیوٹر جیسے ہی اسے کوئی ایسا سائیڈ مل جاتا ہے جو غلط کا اندازہ لگاتا ہے رک جاتا ہے۔  اس سے کوئی فرق نہیں پڑتا ہے کہ دوسری طرف کیا ہے پورے اظہار کو\nغلط سمجھا جائے گا۔ کیونکہ جھوٹے اور سچے کو جھوٹے اور جھوٹے کو اور جھوٹے کو\nبھی جھوٹے کی تشخیص ہوتی ہے۔ ٹھیک ہے، تو کمپیوٹر\nخود کو کچھ کام بچا رہا ہے۔ میں کیوں پرواہ کروں؟\nاس بولین اظہار پر غور کریں۔ یہ کافی سمجھدار لگتا ہے، لیکن اگر متغیر گروپ کے\nسائز میں قدر صفر ہو تو کیا ہوگا؟ کمپیوٹر صفر سے تقسیم نہیں ہو سکتا۔ تو یہ رن ٹائم غلطی دیتا ہے۔ ٹھیک ہے، ہم ایسا نہیں کر سکتے تھے، لیکن ہم\nگروپ سائز کی قدر کو کنٹرول نہیں کر سکتے ہیں۔ شاید یہ صارف کے ان پٹ کے ذریعہ ترتیب دیا گیا ہے۔ اس کو حل کرنے کے لیے، ہم چیک کر سکتے ہیں\nکہ گروپ کا سائز پہلے صفر کے برابر نہیں ہے۔ اگر گروپ کا سائز صفر کے برابر ہے، تو\nبائیں ہاتھ کی طرف غلط پر تشخیص کرے گا اور\nکمپیوٹر شارٹ سرکٹ کرے گا۔ یہ اس نتیجے پر پہنچ جائے گا کہ پورے اظہار کا\nغلط پر اندازہ ہونا چاہیے اور دائیں طرف کا جائزہ لینے کی زحمت نہیں کرے گا،\n اس طرح صفر سے تقسیم سے گریز کیا جائے گا۔ ہم اس طرز کو\nاپنے پروگراموں میں استعمال کر سکتے ہیں، شارٹ سرکٹ کی تشخیص سے فائدہ اٹھاتے ہوئے\n پیشگی شرائط کی جانچ کر سکتے ہیں جو\nہمیں ممکنہ غلطیوں سے بچنے کی اجازت دیتی ہیں۔ آخری سا۔  آپریٹر کے بارے میں کیا خیال ہے؟ ناٹ آپریٹر کو اور اور یا آپریٹرز پر فوقیت حاصل ہے۔ اس کا مطلب یہ ہے کہ یہ اظہار واقعی پوچھتا ہے، کیا صنف راک کے برابر نہیں ہے اور کیا BPM 130 سے ​​زیادہ ہے؟ اب، جب ہمیں ضرورت نہ ہو تو ہم ناٹ آپریٹر کو زیادہ استعمال کرنے کے بارے میں محتاط رہنا چاہتے ہیں\n کیونکہ یہ چیزوں کو مزید الجھا دیتا ہے۔ مثال کے طور پر، یہ اظہار\nصرف سٹائل کے مساوی ہے جو راک\nاور BPM 130 سے ​​زیادہ نہیں ہے۔ یہ پوچھتا ہے، کیا یہ ایک\nراک گانا اور تیز گانا نہیں ہے؟ یہ\nاظہار کے مساوی ہے کیا صنف راک کے برابر نہیں ہے یا\nBPM 130 سے ​​کم یا اس کے برابر ہے؟ اگر ان میں سے کوئی بھی شرط صحیح ہے، تو یہ اور اظہار\nغلط پر تشخیص کرے گا، جس کا مطلب یہ نہیں ہے کہ یہ سچ کی جانچ کرے گا۔ اب آپ شاید سمجھنا شروع کر رہے ہیں کہ میں نے آپریٹر کو تھوڑا سا استعمال کرنے کو کیوں کہا۔\n اگر آپ کو\nمرکب بولین اظہار کی نفی کرنے کی ضرورت ہے، تو یہ سمجھنا اکثر آسان ہوتا ہے کہ کیا آپ اسے متعدد حصوں میں توڑ دیتے ہیں۔ دوسری صورت میں، آپریٹر نہیں آپ کے پروگرام کو\nتھوڑا کم پڑھنے کے قابل بناتا ہے۔ بالکل اسی طرح اگر میں نے کچھ کہا\nجیسے \"میں نیلے رنگوں کو ترجیح نہیں دیتا ہوں یا میں\nاب اس ویڈیو میں نہیں کروں گا۔\"",
    "t_spanish": "- [Presentador] ¿Cómo\nevalúa la computadora las expresiones con los operadores lógicos and or and not? Para averiguarlo, exploremos\nel orden de las operaciones de las expresiones booleanas compuestas. Imaginemos que estamos trabajando\nen un programa para comprobar si una canción específica coincide con los filtros de una lista de reproducción específica. Esta expresión pregunta: ¿los\nlatidos por minuto de la canción son mayores o iguales a 150 y menores o iguales a 180?  A los operadores lógicos les gusta este y ocupan el último lugar en el orden de las operaciones. Entonces la computadora evalúa\nprimero los dos lados por separado. Digamos que la variable BPM\ncontiene el valor 200. Los operadores de comparación\nmayor o igual y menor o igual tienen\nel mismo nivel de precedencia, por lo que la computadora evalúa de izquierda a derecha. Así que primero sustituimos ese 200 en el lado izquierdo y simplificamos. 200 es mayor o igual que 150, por lo que esto se evalúa como verdadero. Luego saltamos al lado derecho. 200 no es menor o igual que 180, por lo que esto se evalúa como falso. Ahora que hemos simplificado ambos lados a un valor booleano, evaluamos y. Una expresión con el\noperador y solo se evalúa como verdadera si ambos lados son verdaderos. Entonces, un verdadero y un falso se evalúan como falso. Y boom, la computadora tiene su respuesta. Probemos con una expresión donde haya múltiples\noperadores lógicos. Esto plantea la pregunta: ¿ el género tiene alguna de\nlas grafías de lo-fi? Digamos que la variable género\ncontiene la cadena lo-fi.  Primero evaluamos las expresiones alrededor de los operadores lógicos\ny luego aplicamos los ors. Comenzamos con la expresión más a la izquierda. Estas cadenas no son iguales,\npor lo que esto se evalúa como falso. Saltamos a la segunda expresión. Estas cadenas son iguales,\npor lo que esto se evalúa como verdadero. Y luego, la tercera parte,\nestas cadenas no son iguales, por lo que esto se evalúa como falso. Ahora que estamos todos simplificados,\nechemos un vistazo a los ors. Una expresión con el\noperador OR se evalúa como verdadera si al menos uno de los lados es verdadero. Falso o verdadero se evalúa como verdadero y luego verdadero o falso se evalúa como verdadero. Ahora quizás estés pensando: \"Vaya, vaya, ¿tenía que\nevaluar esa última parte?\". Una vez que supe que la segunda\nexpresión era verdadera, supe que mi respuesta final\niba a ser verdadera. Mientras evalúa, la computadora hace la misma optimización.  A esto lo llamamos\nevaluación de cortocircuito o evaluación diferida. En su pereza, el\nordenador deja de evaluar en cuanto conoce la respuesta final. Con el operador o la\ncomputadora deja de evaluar tan pronto como encuentra un lado\nque se evalúa como verdadero porque no importa lo que haya\nen el otro lado, la expresión\nsiempre se evaluará como verdadero. Verdadero o verdadero se evalúa como verdadero y verdadero o falso también se evalúa como verdadero. Con el operador and\ntenemos lo contrario. La computadora se detiene tan pronto como encuentra un lado que se evalúa como falso. No importa lo que haya del otro lado, toda la expresión se\nevaluará como falsa. Porque falso y verdadero se evalúa como falso y falso y falso\ntambién se evalúa como falso. Bien, entonces la computadora\nse está ahorrando algo de trabajo.  ¿ Porqué me importa?  Considere\nesta expresión booleana. Parece bastante sensato, pero ¿qué pasa si el tamaño del grupo variable\ncontiene el valor cero? La computadora no puede dividir por cero. Entonces esto da un error de tiempo de ejecución. Bueno, simplemente no podríamos hacer eso, pero es posible que no controlemos\nel valor del tamaño del grupo. Tal vez esté configurado por la entrada del usuario. Para resolver esto, primero podemos\nverificar que el tamaño del grupo no sea igual a cero. Si el tamaño del grupo es igual a\ncero, el lado izquierdo se evaluará como falso y la\ncomputadora provocará un cortocircuito. Llegará a la conclusión de que toda la expresión\ndebe evaluarse como falsa y no se molestará en evaluar\nel lado derecho, evitando así la división por cero. Podemos utilizar este patrón\nen todos nuestros programas, aprovechando la\nevaluación de cortocircuito para verificar condiciones previas que\nnos permitan evitar posibles errores. Último bit.  ¿Qué pasa con el operador no? El operador not tiene prioridad sobre los operadores and y or. Eso significa que esta expresión realmente pregunta: ¿el género no es igual al rock y el BPM es superior a 130? Ahora, debemos tener cuidado con el\nuso excesivo del operador not cuando no lo necesitamos porque tiende a hacer las cosas más confusas. Por ejemplo, esta expresión\nequivale simplemente a género no es igual a rock\ny BPM mayores a 130. Si en lugar de eso pongo paréntesis aquí, estaría negando toda la expresión. Esto pregunta: ¿no es a la vez una\ncanción de rock y una canción rápida? Eso equivale a la\nexpresión ¿el género no es igual al rock o el\nBPM es menor o igual a 130? Si cualquiera de estas condiciones es verdadera, entonces esta expresión se\nevaluaría como falsa, lo que significa que no se evaluaría como verdadera. Ahora probablemente estés empezando a entender por qué dije que usaras el\noperador not con moderación. Si necesita negar una\nexpresión booleana compuesta, suele ser más fácil de entender si la divide en varias partes. De lo contrario, el operador not tiende a hacer que su programa sea\nun poco menos legible. Es como si dijera algo\ncomo \"Prefiero no los colores azules o no lo haré\nen este video ahora\".",
    "t_arabic": "- [المقدم] كيف يقوم\nالكمبيوتر بتقييم التعبيرات باستخدام العوامل المنطقية و or و not؟ لمعرفة ذلك، دعونا نستكشف\nترتيب العمليات للتعبيرات المنطقية المركبة. تخيل أننا نعمل\nعلى برنامج للتحقق مما إذا كانت أغنية معينة تتطابق مع المرشحات الخاصة بقائمة تشغيل معينة. يسأل هذا التعبير، هل\nنبضات الأغنية في الدقيقة أكبر من أو تساوي 150، وأقل من أو تساوي 180؟ العوامل المنطقية مثل هذه وتأتي في المرتبة الأخيرة في ترتيب العمليات. لذا يقوم الكمبيوتر بتقييم\nالجانبين بشكل منفصل أولاً. لنفترض أن المتغير BPM\nيحتوي على القيمة 200. إن عوامل المقارنة\nالأكبر من أو يساوي أو الأقل من أو يساوي لها\nنفس مستوى الأسبقية، لذلك يقوم الكمبيوتر بالتقييم من اليسار إلى اليمين. لذا نعوض بـ 200 في الطرف الأيسر أولًا ونبسطها. 200 أكبر من أو يساوي 150، لذلك تكون قيمته صحيحة. ثم نقفز إلى الجانب الأيمن. 200 لا يقل عن أو يساوي 180، لذلك يكون تقييمه خطأ. الآن بعد أن قمنا بتبسيط كلا الطرفين إلى قيمة منطقية، نقوم بتقييم و. \nيتم تقييم التعبير الذي يحتوي على العامل and على أنه صحيح فقط إذا كان كلا الجانبين صحيحًا. لذلك يتم تقييم الصواب والخطأ إلى خطأ. والكمبيوتر لديه إجابته. دعونا نجرب تعبيرًا حيث يوجد\nعوامل منطقية متعددة. هذا يطرح السؤال، هل النوع يحتوي على أي من\nتهجئات lo-fi؟ لنفترض أن النوع المتغير\nيحتوي على السلسلة lo-fi. نقوم بتقييم التعبيرات حول العوامل المنطقية أولًا\nثم نطبق معاملات الـ ors. نبدأ بالتعبير الموجود في أقصى اليسار. هذه السلاسل ليست متساوية،\nلذلك يتم تقييمها على أنها خطأ. ننتقل إلى التعبير الثاني. هذه السلاسل متساوية،\nلذلك يتم تقييمها على أنها صحيحة. ثم الجزء الثالث،\nهذه السلاسل ليست متساوية، لذلك يتم تقييمها على أنها خطأ. الآن بعد أن تم تبسيطنا جميعًا،\nنلقي نظرة على القيم. \nيتم تقييم التعبير الذي يحتوي على عامل التشغيل OR على أنه صحيح إذا كان أحد الجوانب على الأقل صحيحًا.  يتم تقييم False أو true إلى true ثم يتم تقييم true أو false إلى true. ربما تفكر الآن، \"مهلًا، هل كنت بحاجة\nإلى تقييم هذا الجزء الأخير؟\" بمجرد أن عرفت أن\nالتعبير الثاني قيمته صحيح، عرفت أن إجابتي النهائية\nستكون صحيحة. أثناء قيامه بالتقييم، يقوم الكمبيوتر بإجراء نفس التحسين.  لقد أطلقنا على هذا التقييم اسم الدائرة القصيرة\nأو التقييم البطيء. وفي كسله،\nيتوقف الكمبيوتر عن التقييم بمجرد معرفة الإجابة النهائية. باستخدام عامل التشغيل أو،\nيتوقف الكمبيوتر عن التقييم بمجرد العثور على جانب يتم\nتقييمه على أنه صحيح لأنه بغض النظر عما هو موجود\nعلى الجانب الآخر، فسيتم\nتقييم التعبير دائمًا على أنه صحيح. يتم تقييم True أو true إلى true، ويتم تقييم true أو false أيضًا إلى true. مع والمشغل\nلدينا العكس. يتوقف الكمبيوتر بمجرد العثور على الجانب الذي يتم تقييمه على أنه خطأ. بغض النظر عما يوجد على الجانب الآخر، \nسيتم تقييم التعبير بالكامل على أنه خطأ. لأن تقييم الخطأ والصواب إلى خطأ وكاذب،\nوتقييم الخطأ أيضًا إلى خطأ. حسنًا، الكمبيوتر\nيوفر على نفسه بعض العمل. لماذا أهتم؟  النظر في\nهذا التعبير المنطقي. يبدو الأمر معقولًا جدًا، ولكن ماذا لو كان حجم المجموعة المتغير\nيحتوي على القيمة صفر؟ الكمبيوتر لا يستطيع القسمة على صفر لذلك هذا يعطي خطأ في وقت التشغيل. حسنًا، لا يمكننا فعل ذلك، لكننا قد لا نتحكم في\nقيمة حجم المجموعة. ربما تم تعيينه عن طريق إدخال المستخدم. لحل هذه المشكلة، يمكننا\nالتحقق من أن حجم المجموعة لا يساوي الصفر أولاً. إذا كان حجم المجموعة يساوي\nصفر، فسيتم تقييم الجانب الأيسر على أنه خطأ\nوسيحدث ماس كهربائي في الكمبيوتر. سوف نصل إلى نتيجة مفادها أن التعبير بأكمله\nيجب أن يكون تقييمه خاطئًا ولن يكلف نفسه عناء تقييم\nالجانب الأيمن، وبالتالي تجنب القسمة على صفر. يمكننا استخدام هذا النمط\nعبر برامجنا، مع الاستفادة من\nتقييم الدائرة القصيرة للتحقق من الشروط المسبقة التي تسمح\nلنا بتجنب الأخطاء المحتملة. آخر قطعة.  ماذا عن عدم المشغل؟ عامل التشغيل not له الأسبقية على عوامل التشغيل و و/أو. هذا يعني أن هذا التعبير يتساءل حقًا، هل هذا النوع لا يساوي موسيقى الروك وهل BPM أكبر من 130؟ الآن، نريد أن نكون حذرين بشأن\nالإفراط في استخدام عامل التشغيل not عندما لا نحتاج إلى ذلك لأنه يميل إلى جعل الأمور أكثر إرباكًا. على سبيل المثال، هذا التعبير\nيعادل فقط النوع الذي لا يساوي موسيقى الروك\nوBPM أكبر من 130. إذا وضعت قوسين هنا بدلاً من ذلك، فسوف أقوم بإلغاء التعبير بالكامل. هذا يسأل، أليست\nأغنية روك وأغنية سريعة؟ وهذا يعادل\nعبارة هل النوع لا يساوي موسيقى الروك أم أن\nBPM أقل من أو يساوي 130؟ إذا كان أي من هذين الشرطين صحيحًا، \nفسيتم تقييم هذا والتعبير على أنه خطأ، مما يعني أنه لن يتم تقييمه على أنه صحيح. الآن ربما بدأت تفهم لماذا قلت استخدام\nعامل التشغيل not بشكل مقتصد. إذا كنت بحاجة إلى إلغاء\nتعبير منطقي مركب، فغالبًا ما يكون من الأسهل فهمه إذا قمت بتقسيمه إلى أجزاء متعددة. بخلاف ذلك، فإن عامل التشغيل not يميل إلى جعل برنامجك\nأقل قابلية للقراءة. تمامًا كما لو قلت شيئًا\nمثل \"لا أفضّل الألوان الزرقاء أو لن أتواجد\nفي هذا الفيديو الآن.\"",
    "t_italian": "- [Presentatore] Come fa il\ncomputer a valutare le espressioni con gli operatori logici e oppure e no? Per scoprirlo, esploriamo\nl'ordine delle operazioni per le espressioni booleane composte. Immagina di lavorare\nsu un programma per verificare se un brano specifico corrisponde ai filtri di una playlist specifica. Questa espressione chiede: i\nbattiti al minuto della canzone sono maggiori o uguali a 150 e minori o uguali a 180? Gli operatori logici come questo vengono per ultimi nell'ordine delle operazioni. Quindi il computer valuta\nprima le due parti separatamente. Diciamo che la variabile BPM\ncontiene il valore 200. Gli operatori di confronto\nmaggiore o uguale a e minore o uguale hanno\nlo stesso livello di precedenza, quindi il computer valuta da sinistra a destra. Quindi sostituiamo prima il 200 sul lato sinistro e semplifichiamo. 200 è maggiore o uguale a 150, quindi risulta vero. Quindi saltiamo sul lato destro. 200 non è inferiore o uguale a 180, quindi risulta falso. Ora che abbiamo semplificato entrambi i lati fino a ottenere un valore booleano, valutiamo e. Un'espressione con l'\noperatore e restituisce vero solo se entrambi i lati sono veri. Quindi un vero e un falso valgono falso. E boom, il computer ha la sua risposta. Proviamo un'espressione in cui sono presenti più\noperatori logici. Ciò pone la domanda: il genere è una delle\ngrafie di lo-fi? Diciamo che la variabile genere\ncontiene la stringa lo-fi. Valutiamo prima le espressioni attorno agli operatori logici\ne poi applichiamo gli ors. Iniziamo con l'espressione più a sinistra. Queste stringhe non sono uguali,\nquindi il risultato è falso. Passiamo alla seconda espressione. Queste stringhe sono uguali,\nquindi questo risulta vero. E poi la terza parte,\nqueste stringhe non sono uguali, quindi il risultato è falso. Ora che siamo tutti semplificati,\ndiamo un'occhiata agli ors. Un'espressione con l'\noperatore OR restituisce vero se almeno uno dei lati è vero. Falso o vero restituisce vero e poi vero o falso restituisce vero. Ora potresti pensare: \"Whoa, whoa, avevo bisogno\ndi valutare anche quest'ultima parte?\" Una volta che ho saputo che la seconda\nespressione era valutata come vera, sapevo che la mia risposta finale\nsarebbe stata vera. Mentre valuta, il computer effettua la stessa ottimizzazione. Abbiamo chiamato questa\nvalutazione di cortocircuito o valutazione pigra. Nella sua pigrizia, il\ncomputer smette di valutare non appena conosce la risposta finale. Con l'operatore o il\ncomputer smette di valutare non appena trova un lato\nche restituisce vero perché non importa cosa c'è\ndall'altra parte, l'espressione\nvaluterà sempre vero. Vero o vero restituisce vero e anche vero o falso restituisce vero. Con l'operatore e\nabbiamo l'opposto. Il computer si ferma non appena trova un lato che risulta falso. Non importa cosa c'è dall'altra parte, l'intera espressione\nverrà valutata falsa. Perché falso e vero valgono falso e anche falso e falso\nvalgono falso. Ok, quindi il computer si sta\nrisparmiando un po' di lavoro. Perché mi interessa?  Considera\nquesta espressione booleana. Sembra abbastanza sensato, ma cosa succede se la dimensione variabile del gruppo\ncontiene il valore zero? Il computer non può dividere per zero. Quindi questo dà un errore di runtime. Bene, semplicemente non potremmo farlo, ma potremmo non controllare\nil valore della dimensione del gruppo. Forse è impostato dall'input dell'utente. Per risolvere questo problema, possiamo prima\nverificare che la dimensione del gruppo non sia uguale a zero. Se la dimensione del gruppo è uguale a\nzero, il lato sinistro valuterà falso e il\ncomputer andrà in cortocircuito. Salterà alla conclusione che l'intera espressione\ndeve essere valutata come false e non si preoccuperà di valutare\nil lato destro, evitando così la divisione per zero. Possiamo utilizzare questo modello\nnei nostri programmi, sfruttando la\nvalutazione del cortocircuito per verificare le precondizioni che\nci consentono di evitare possibili errori.  L' ultima parte.  E l'operatore not? L'operatore not ha la precedenza sugli operatori and e or. Ciò significa che questa espressione chiede davvero: il genere non è uguale al rock e il BPM è maggiore di 130? Ora, dobbiamo fare attenzione a non\nabusare dell'operatore not quando non ne abbiamo bisogno perché tende a rendere le cose più confuse. Ad esempio, questa espressione\nè semplicemente equivalente a genere non uguale a rock\ne BPM maggiore di 130. Se invece mettessi qui le parentesi, negherei l'intera espressione. Questo chiede: non è sia una\ncanzone rock che una canzone veloce? Ciò equivale\nall'espressione il genere non è uguale al rock o il\nBPM è inferiore o uguale a 130? Se una di queste condizioni è vera, allora questa espressione\nverrà valutata falsa, il che significa che non verrà valutata vera. Ora probabilmente stai iniziando a capire perché ho detto di usare l'\noperatore not con parsimonia. Se è necessario negare\nun'espressione booleana composta, spesso è più semplice capirla suddividendola in più parti. Altrimenti, l'operatore not tende a rendere il programma\nun po' meno leggibile. Proprio come se dicessi qualcosa\ndel tipo \"Non preferisco i colori blu o non lo farò\nin questo video adesso\"."
}