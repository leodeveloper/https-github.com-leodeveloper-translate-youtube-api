{
    "source": "q0bQrGhdPm4",
    "youtubelink": "https://www.youtube.com/watch?v=q0bQrGhdPm4",
    "t_english": "- [Instructor] We can use an IF statement to control that a particular block of code only executes when the condition evaluates to true. But what if we wanna do something else only when the condition evaluates to false? Well, we can add another IF statement and try and construct a condition that's the exact opposite of the original condition. That's a bit annoying and sometimes the opposite condition isn't obvious or it's super long. To save us the trouble, Python instead lets us use an else branch. We can stick an else branch onto the end of any IF statement and any instructions indented inside the else branch only execute if the corresponding IF statements condition evaluates to false. That makes the IF branch and the else branch mutually exclusive based on the answer to the condition, the computer decides which of the two paths to take. The Python syntax for an else branch is just the keyword else followed by a colon. Again, we use indentation to tell the computer which lines of code are inside the else branch. An else branch must always follow an IF branch. Otherwise, what are we taking the opposite of? Let's trace that execution path. If the condition evaluates to true as normal, the computer goes on to execute any instructions indented inside that IF branch. When it's done, execution jumps to the next line of code that's indented outside of the conditional. If the condition evaluates to false, the computer skips the rest of the IF branch and jumps to the else branch. Then it executes any lines of code that are indented inside the else branch. When it's done, it just continues execution with the next line of code indented outside of the conditional. Note that this execution path with an else branch is different from this, where we just have that instruction indented outside of the IF statement. Here if the condition evaluates to true, we print mobile layout, then we jump outside of the conditional and print desktop layout. If the condition evaluates to false, we skip the IF branch, jump outside of the conditional and print desktop layout. Because the instruction is not indented it's independent of the conditional`, it always executes. However, if we indent this instruction inside an else branch instead, we only print desktop layout if the condition evaluates to false. If the condition evaluates to true, we print mobile layout and skip the else branch. What if we have more than two cases like a mobile tablet and a desktop layout? We could try to construct three mutually exclusive conditions or we can take advantage of a shortcut and use the elif branch. The elif or else IF branch allows us to chain multiple conditions together. Starting with the IF branch, the computer evaluates each condition in order until it finds one that evaluates to true, then it chooses that branch to execute. Note that order matters here because the computer will stop checking other branches as soon as it finds one that evaluates to true. If instead I put this condition first, the IF branch would capture any screen widths that are smaller than 760. That means that if I have a mobile screen that's say 300 pixels, it will get captured by this first case and print tablet layout. The computer only ever chooses one branch. It doesn't print mobile layout. Even though that condition would have evaluated to true. We can attach as many elif branches as we want to any if branch and then we can optionally add an else branch at the end. So we can see what the computer's doing let's trace each possible execution path. If the first condition evaluates to true, then the computer chooses that branch and it executes any instructions indented inside of it. Then it jumps to the next line of code outside of the conditional. If the first condition evaluates to false, then the computer goes on to check the next condition. If the second condition evaluates to true, then the computer chooses this branch and executes any instructions indented inside of it. Then it jumps to the next line of code outside of the conditional. If the computer checks the first condition, finds that it evaluates to false, then checks the second condition, also finds that it evaluates to false, then it moves on to the else branch else. Else branches don't have a condition, so if the computer reaches it, it just runs. So we execute the instructions indented inside the else branch and then we jump to the next line of code outside of the conditional. So if you have multiple related conditions in your program, it's generally better to use a chain conditional with elif and else branches instead of several independent single branch conditionals. Chain conditionals make programs easier to read because it makes the relationship between conditions obvious. It reduces bugs because we as the programmer don't have to worry about making sure all our conditions are mutually exclusive and cover all possible cases and it saves the computer some work. With independent conditions that computer doesn't know they're related, so it'll evaluate every single one, even if it's impossible for multiple of them to be true. With chain conditionals, we give the computer the hint that these are all mutually exclusive, so it knows it can stop evaluating as soon as it finds a branch that evaluates to true.\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n",
    "t_urdu": "- [انسٹرکٹر] ہم\nایک IF اسٹیٹمنٹ کو کنٹرول کرنے کے لیے استعمال کر سکتے ہیں کہ کوڈ کا ایک خاص بلاک\nصرف اس وقت عمل میں آتا ہے جب حالت درست ہونے کا اندازہ ہوتا ہے۔ لیکن کیا ہوگا اگر ہم صرف اس صورت میں کچھ اور کرنا چاہتے ہیں جب حالت کا\nاندازہ غلط ہو جائے؟ ٹھیک ہے، ہم ایک اور IF سٹیٹمنٹ شامل کر سکتے ہیں\nاور کوشش کر سکتے ہیں اور ایسی شرط بنا سکتے ہیں\nجو اصل حالت کے بالکل برعکس ہو۔ یہ قدرے پریشان کن ہے اور بعض اوقات مخالف\nحالت واضح نہیں ہوتی یا یہ بہت لمبی ہوتی ہے۔ ہمیں پریشانی سے بچانے کے لیے، ازگر اس کے بجائے ہمیں دوسری برانچ استعمال کرنے دیتا ہے۔ ہم کسی بھی دوسری شاخ کو\nکسی بھی IF سٹیٹمنٹ کے آخر میں چسپاں کر سکتے ہیں اور else برانچ کے اندر اندر کی گئی کوئی بھی ہدایات\n صرف اس صورت میں عمل میں آتی ہیں جب متعلقہ\nIF سٹیٹمنٹس کی حالت غلط ہونے کی تشخیص کرتی ہے۔ یہ شرط کے جواب کی بنیاد پر IF برانچ اور دوسری برانچ کو باہمی طور پر\nالگ کرتا ہے، کمپیوٹر فیصلہ کرتا ہے کہ\nدونوں میں سے کون سا راستہ اختیار کرنا ہے۔ ایک اور برانچ کے لیے Python نحو صرف ایک کلیدی لفظ ہے جس کے بعد بڑی آنت آتی ہے۔  ایک بار پھر، ہم\nکمپیوٹر کو یہ بتانے کے لیے انڈینٹیشن کا استعمال کرتے ہیں کہ کوڈ کی کون سی لائنز\nelse برانچ کے اندر ہیں۔ دوسری برانچ کو ہمیشہ\nIF برانچ کی پیروی کرنی چاہیے۔ ورنہ ہم اس\nکے برعکس کیا لے رہے ہیں؟ آئیے اس پھانسی کے راستے کا سراغ لگائیں۔ اگر حالت\nمعمول کے مطابق درست ہوتی ہے، تو کمپیوٹر اس IF برانچ کے اندر اندر کی گئی\nکسی بھی ہدایات پر عمل درآمد کرتا ہے۔ جب یہ ہو جاتا ہے تو، عملدرآمد\nکوڈ کی اگلی لائن پر چھلانگ لگاتا ہے جو مشروط سے باہر انڈینٹ کیا جاتا ہے۔\n اگر حالت غلط پر تشخیص کرتی ہے، تو کمپیوٹر\nباقی IF برانچ کو چھوڑ دیتا ہے اور دوسری شاخ میں چھلانگ لگا دیتا ہے۔ پھر یہ کوڈ کی کسی بھی لائن پر عمل درآمد کرتا ہے\nجو دوسری شاخ کے اندر اندر کی جاتی ہے۔ جب یہ ہو جاتا ہے، تو یہ صرف مشروط سے باہر\n کوڈ کی اگلی لائن کے ساتھ عمل درآمد جاری رکھتا ہے۔ نوٹ کریں کہ کسی اور برانچ کے ساتھ عمل درآمد کا یہ راستہ \nاس سے مختلف ہے، جہاں ہمارے پاس صرف IF سٹیٹمنٹ کے\nباہر اس ہدایت کو شامل کیا گیا ہے۔ یہاں اگر شرط درست ہونے کا اندازہ لگایا جاتا ہے، تو ہم موبائل لے آؤٹ پرنٹ کرتے ہیں، پھر ہم مشروط سے باہر چھلانگ لگاتے ہیں اور ڈیسک ٹاپ لے آؤٹ پرنٹ کرتے ہیں۔ اگر شرط کا اندازہ غلط ہوتا ہے، تو ہم IF برانچ کو چھوڑ دیتے ہیں،\nمشروط سے باہر چھلانگ لگاتے ہیں اور ڈیسک ٹاپ لے آؤٹ پرنٹ کرتے ہیں۔ کیونکہ ہدایات حاشیہ دار نہیں ہے یہ مشروط سے آزاد ہے\n، یہ ہمیشہ عمل کرتی ہے۔ تاہم، اگر ہم اس ہدایت کو اس کے بجائے کسی اور برانچ کے اندر داخل کرتے ہیں، تو ہم صرف ڈیسک ٹاپ\nلے آؤٹ کو پرنٹ کرتے ہیں اگر شرط کا اندازہ غلط ہوتا ہے۔ اگر شرط درست ثابت ہوتی ہے تو ہم موبائل لے آؤٹ پرنٹ کرتے ہیں\nاور دوسری برانچ کو چھوڑ دیتے ہیں۔ اگر ہمارے پاس موبائل ٹیبلیٹ اور ڈیسک ٹاپ لے آؤٹ جیسے دو سے زیادہ کیسز ہوں تو کیا ہوگا؟ ہم تین باہمی طور پر خصوصی حالات بنانے کی کوشش کر سکتے ہیں\nیا ہم شارٹ کٹ کا فائدہ اٹھا سکتے ہیں اور ایلیف برانچ استعمال کر سکتے ہیں۔ elif ورنہ IF برانچ ہمیں متعدد شرائط کو ایک ساتھ جوڑنے کی اجازت دیتی ہے۔\n IF برانچ کے ساتھ شروع کرتے ہوئے، کمپیوٹر\nہر حالت کا اندازہ اس وقت تک کرتا ہے جب تک کہ اسے کوئی ایسی چیز نہ مل جائے جس کا درست اندازہ ہو، پھر وہ اس برانچ کو عمل میں لانے کے لیے منتخب کرتا ہے۔ نوٹ کریں کہ آرڈر یہاں اہمیت رکھتا ہے کیونکہ جیسے ہی کمپیوٹر اسے درست ہونے والی کسی کو تلاش کرتا ہے تو وہ\nدوسری شاخوں کی جانچ کرنا بند کر دے گا۔ \n اگر اس کے بجائے میں اس شرط کو پہلے رکھوں تو، IF برانچ\nکسی بھی اسکرین کی چوڑائی کو پکڑے گی جو 760 سے چھوٹی ہے۔ اس کا مطلب یہ ہے کہ اگر میرے پاس موبائل اسکرین ہے جو کہ 300 پکسلز ہے، تو\nیہ اس پہلے کیس اور\nپرنٹ ٹیبلٹ لے آؤٹ سے کیپچر ہوجائے گی۔ کمپیوٹر صرف ایک شاخ کا انتخاب کرتا ہے۔ یہ موبائل لے آؤٹ پرنٹ نہیں کرتا ہے۔ اگرچہ اس شرط کو\nدرست سمجھا جاتا۔ ہم جتنی بھی\nایلیف برانچز کو کسی بھی اگر برانچ کے ساتھ جوڑ سکتے ہیں اور\nپھر ہم اختیاری طور پر آخر میں دوسری برانچ شامل کر سکتے ہیں۔ لہذا ہم دیکھ سکتے ہیں کہ کمپیوٹر کیا کر رہا ہے آئیے ہر ممکنہ عمل کے راستے کا پتہ لگائیں۔ اگر پہلی شرط درست ہوتی ہے، تو کمپیوٹر اس شاخ کا انتخاب کرتا ہے اور وہ اس کے اندر کی گئی کسی بھی ہدایات پر عمل کرتا ہے۔\n پھر یہ مشروط سے باہر کوڈ کی اگلی لائن پر چھلانگ لگا دیتا ہے۔ اگر پہلی شرط غلط ہونے کا اندازہ لگاتی ہے، تو کمپیوٹر\nاگلی حالت کو چیک کرتا ہے۔ اگر دوسری شرط درست ہونے کا اندازہ لگاتی ہے، تو کمپیوٹر اس شاخ کا انتخاب کرتا ہے اور\nاس کے اندر اندر کی گئی ہدایات پر عمل کرتا ہے۔ پھر یہ مشروط سے باہر کوڈ کی اگلی لائن پر چھلانگ لگا دیتا ہے۔ اگر کمپیوٹر\nپہلی شرط کو چیک کرتا ہے، یہ پاتا ہے کہ اس کی تشخیص غلط ہوتی ہے، پھر دوسری شرط کی جانچ پڑتال کرتا ہے، یہ بھی پتہ چلتا ہے کہ یہ غلط کی تشخیص کرتا ہے، پھر وہ دوسری شاخ میں چلا جاتا ہے۔  بصورت دیگر شاخوں کی کوئی شرط نہیں ہے، لہذا اگر کمپیوٹر اس تک\nپہنچ جائے تو یہ صرف چلتا ہے۔ لہذا ہم else برانچ کے اندر انڈینٹ کردہ ہدایات پر عمل کرتے ہیں اور پھر ہم مشروط سے باہر کوڈ کی اگلی لائن پر جاتے ہیں۔ لہذا اگر آپ\nکے پروگرام میں متعدد متعلقہ شرائط ہیں، تو یہ عام طور پر بہتر ہے کہ\n \nکئی آزاد واحد برانچ کنڈیشنلز کے بجائے elif اور else برانچوں کے ساتھ چین مشروط استعمال کریں۔ سلسلہ کنڈیشنلز\nپروگراموں کو پڑھنے میں آسان بناتے ہیں کیونکہ یہ حالات کے درمیان تعلق کو واضح کرتا ہے۔ یہ کیڑے کو کم کرتا ہے کیونکہ\nپروگرامر کے طور پر ہمیں اس بات کو یقینی بنانے کے بارے میں فکر کرنے کی ضرورت نہیں ہے کہ\nہماری تمام شرائط باہمی طور پر خصوصی ہیں اور\nتمام ممکنہ معاملات کا احاطہ کرتی ہیں اور اس سے کمپیوٹر کا کچھ کام بچ جاتا ہے۔ آزاد حالات کے ساتھ جو کمپیوٹر کو نہیں\nمعلوم کہ وہ آپس میں جڑے ہوئے ہیں، اس لیے یہ ہر\nایک کا جائزہ لے گا، چاہے ان میں سے متعدد کا درست ہونا ناممکن ہو۔ زنجیر کنڈیشنلز کے ساتھ، ہم کمپیوٹر کو یہ اشارہ دیتے ہیں کہ یہ سب ایک دوسرے سے مخصوص ہیں، اس لیے وہ جانتا ہے کہ جیسے ہی اسے کوئی برانچ مل جائے گی\nجو درست پر تشخیص کرتی ہے تو وہ تشخیص کرنا بند کر سکتا ہے۔",
    "t_spanish": "- [Instructor] Podemos usar\nuna declaración IF para controlar que un bloque\nde código en particular solo se ejecute cuando la condición se evalúe como verdadera. Pero ¿qué pasa si queremos hacer algo más sólo cuando la condición\nse evalúa como falsa? Bueno, podemos agregar otra\ndeclaración IF e intentar construir una condición\nque sea exactamente opuesta a la condición original. Eso es un poco molesto y, a veces, la\ncondición opuesta no es obvia o es muy larga. Para ahorrarnos el problema, Python nos permite usar una rama else. Podemos colocar una rama else\nal final de cualquier declaración IF y cualquier instrucción indentada\ndentro de la rama else solo se ejecuta si la\ncondición de la declaración IF correspondiente se evalúa como falsa. Eso hace que la rama IF y la rama else sean mutuamente\nexcluyentes según la respuesta a la condición, la computadora decide cuál\nde los dos caminos tomar. La sintaxis de Python para una rama else es solo la palabra clave else seguida de dos puntos. Nuevamente, usamos sangría\npara decirle a la computadora qué líneas de código están\ndentro de la rama else. Una rama else siempre debe\nseguir a una rama IF. De lo contrario, ¿qué estamos\ntomando en contra? Rastreemos ese camino de ejecución. Si la condición se evalúa\ncomo verdadera de forma normal, la computadora continúa\nejecutando cualquier instrucción indentada dentro de esa rama IF. Cuando finaliza, la ejecución\nsalta a la siguiente línea de código que tiene sangría fuera\ndel condicional. Si la condición se evalúa como falsa, la computadora omite el\nresto de la rama IF y salta a la rama else. Luego ejecuta cualquier línea\nde código que esté sangrada dentro de la rama else. Cuando termina, simplemente\ncontinúa la ejecución con la siguiente línea de código con sangría fuera del condicional. Tenga en cuenta que esta ruta de ejecución con una rama else es\ndiferente de esta, donde simplemente tenemos esa\ninstrucción sangrada fuera de la declaración IF. Aquí, si la condición se evalúa como verdadera, imprimimos el diseño móvil, luego saltamos fuera del diseño condicional e imprimimos el escritorio. Si la condición se evalúa como falsa, omitimos la rama IF, saltamos\nfuera del diseño condicional e imprimimos el escritorio. Debido a que la instrucción no tiene sangría, es independiente del\ncondicional, siempre se ejecuta. Sin embargo, si sangramos esta instrucción dentro de una rama else, solo imprimiremos el\ndiseño del escritorio si la condición se evalúa como falsa. Si la condición se evalúa como verdadera, imprimimos el diseño móvil\ny omitimos la rama else.  ¿ Qué pasa si tenemos más de dos carcasas como una tableta móvil y una de escritorio? Podríamos intentar construir tres condiciones mutuamente excluyentes\no podemos aprovechar un atajo y usar la rama elif. La rama elif o IF nos permite encadenar múltiples\ncondiciones. Comenzando con la rama IF, la computadora evalúa\ncada condición en orden hasta que encuentra una que se evalúa como verdadera, luego elige esa rama para ejecutar. Tenga en cuenta que el orden es importante aquí porque la computadora\ndejará de verificar otras ramas tan pronto como encuentre una\nque se evalúe como verdadera. Si, en cambio, pongo esta condición primero, la rama IF\ncapturaría cualquier ancho de pantalla menor que 760. Eso significa que si tengo una pantalla móvil de, digamos, 300 píxeles,\nserá capturada por este primer caso e\nimprimirá el diseño de la tableta. La computadora solo elige una rama. No imprime diseño móvil. Aunque esa condición se\nhabría evaluado como verdadera. Podemos adjuntar tantas\nramas elif como queramos a cualquier rama if y\nluego, opcionalmente, podemos agregar una rama else al final. Para que podamos ver qué está haciendo la computadora, rastreemos cada posible ruta de ejecución. Si la primera condición se evalúa como verdadera, entonces la computadora elige esa rama y ejecuta las instrucciones\nsangradas dentro de ella. Luego salta a la siguiente línea de código fuera del condicional. Si la primera condición se evalúa como falsa, entonces la computadora pasa\na verificar la siguiente condición. Si la segunda condición se evalúa como verdadera, entonces la computadora elige esta rama y ejecuta las instrucciones\nsangradas dentro de ella. Luego salta a la siguiente línea de código fuera del condicional. Si la computadora verifica\nla primera condición, descubre que su evaluación es falsa, luego verifica la segunda condición, también descubre que su evaluación es falsa y luego pasa a la rama else. De lo contrario, las ramas no tienen una condición, por lo que si la computadora la\nalcanza, simplemente se ejecuta. Entonces ejecutamos las instrucciones sangradas dentro de la rama else y luego saltamos a la siguiente línea de código fuera del condicional. Entonces, si tiene múltiples\ncondiciones relacionadas en su programa, generalmente es mejor usar\nun condicional de cadena con ramas elif y else en lugar\nde varios condicionales de rama única independientes.  Los condicionales en cadena hacen que los\nprogramas sean más fáciles de leer porque hacen obvia la relación entre las condiciones. Reduce los errores porque\nnosotros, como programadores, no tenemos que preocuparnos de\nasegurarnos de que todas nuestras condiciones sean mutuamente excluyentes y\ncubran todos los casos posibles, y le ahorra algo de trabajo a la computadora. Con condiciones independientes, esa computadora no\nsabe que están relacionadas, por lo que evaluará cada\nuna de ellas, incluso si es imposible que varias de ellas sean verdaderas. Con los condicionales en cadena, le damos a la computadora la pista de que todos son mutuamente excluyentes, para que sepa que puede dejar de evaluar tan pronto como encuentre una rama\nque se evalúe como verdadera.",
    "t_arabic": "- [المدرس] يمكننا استخدام\nعبارة IF للتحكم في تنفيذ كتلة معينة\nمن التعليمات البرمجية فقط عندما يتم تقييم الشرط على أنه صحيح. ولكن ماذا لو أردنا أن نفعل شيئًا آخر فقط عندما يتم\nتقييم الحالة على أنها خاطئة؟ حسنًا، يمكننا إضافة\nعبارة IF أخرى ومحاولة إنشاء شرط\nمعاكس تمامًا للشرط الأصلي. هذا أمر مزعج بعض الشيء وأحيانًا\nلا تكون الحالة المعاكسة واضحة أو تكون طويلة جدًا. ولإنقاذنا من هذه المشكلة، تتيح لنا لغة بايثون بدلاً من ذلك استخدام فرع آخر. يمكننا لصق فرع آخر\nفي نهاية أي عبارة IF وأي تعليمات تم وضع مسافة بادئة لها\nداخل الفرع else يتم تنفيذها فقط إذا تم تقييم\nحالة عبارات IF المقابلة إلى خطأ. وهذا يجعل فرع IF والفرع else\nمتنافيين بناءً على إجابة الشرط، ويقرر الكمبيوتر أي\nالمسارين سيتبع. بناء جملة Python لفرع آخر هو مجرد الكلمة الأساسية else متبوعة بنقطتين. مرة أخرى، نستخدم المسافة البادئة\nلإخبار الكمبيوتر عن أسطر التعليمات البرمجية الموجودة\nداخل الفرع else. يجب أن يتبع الفرع الآخر دائمًا\nفرع IF. وإلا فماذا\nنأخذ بالعكس؟ دعونا نتتبع مسار التنفيذ هذا. إذا تم تقييم الحالة\nعلى أنها صحيحة كالمعتاد، فسيواصل الكمبيوتر\nتنفيذ أي تعليمات تم وضع مسافة بادئة لها داخل فرع IF هذا. عند الانتهاء،\nينتقل التنفيذ إلى السطر التالي من التعليمات البرمجية الذي تم وضع مسافة بادئة له\nخارج الشرط. إذا تم تقييم الشرط إلى خطأ، فسيتخطى الكمبيوتر\nبقية فرع IF وينتقل إلى الفرع الآخر. ثم يقوم بتنفيذ أي أسطر\nمن التعليمات البرمجية التي تم وضع مسافة بادئة لها داخل الفرع else. عند الانتهاء، فإنه\nيستمر في التنفيذ مع وضع مسافة بادئة للسطر التالي من التعليمات البرمجية خارج الشرط. لاحظ أن مسار التنفيذ هذا مع فرع آخر\nيختلف عن هذا، حيث لدينا فقط مسافة\nبادئة لتلك التعليمات خارج عبارة IF. هنا، إذا تم تقييم الشرط على أنه صحيح، فإننا نطبع تخطيط الهاتف المحمول، ثم نقفز خارج التخطيط الشرطي ونطبع تخطيط سطح المكتب. إذا تم تقييم الشرط إلى خطأ، فإننا نتخطى فرع IF، ونقفز\nخارج التخطيط الشرطي ونطبع سطح المكتب. نظرًا لعدم وضع مسافة بادئة للتعليمة، فهي مستقلة عن\nالشرطية، ويتم تنفيذها دائمًا. ومع ذلك، إذا وضعنا مسافة بادئة لهذه التعليمات داخل فرع آخر بدلاً من ذلك، فإننا نطبع تخطيط سطح المكتب فقط\nإذا تم تقييم الحالة إلى خطأ. إذا تم تقييم الشرط على أنه صحيح، فإننا نطبع تخطيط الهاتف المحمول\nونتخطى الفرع else. ماذا لو كان لدينا أكثر من حالتين مثل الكمبيوتر اللوحي المحمول وتخطيط سطح المكتب؟ يمكننا أن نحاول بناء ثلاثة شروط متنافية\nأو يمكننا الاستفادة من الاختصار واستخدام فرع إليف.  يتيح لنا فرع elif أو else IF ربط عدة\nشروط معًا. بدءًا من فرع IF، يقوم الكمبيوتر بتقييم\nكل شرط بالترتيب حتى يجد شرطًا يتم تقييمه على أنه صحيح، ثم يختار ذلك الفرع لتنفيذه. لاحظ أن الترتيب مهم هنا لأن الكمبيوتر سيتوقف عن\nفحص الفروع الأخرى بمجرد العثور على فرع يتم\nتقييمه على أنه صحيح. إذا وضعت هذا الشرط أولاً بدلاً من ذلك، فسيقوم فرع IF\nبالتقاط أي عرض شاشة أصغر من 760. وهذا يعني أنه إذا كانت لدي شاشة هاتف محمول بحجم 300 بكسل،\nفسيتم التقاطها بواسطة هذه الحالة الأولى\nوطباعة تخطيط الجهاز اللوحي. يختار الكمبيوتر فرعًا واحدًا فقط. لا يطبع تخطيط المحمول. على الرغم من أن هذا الشرط\nسيتم تقييمه على أنه صحيح. يمكننا إرفاق أي عدد\nنريده من فروع elif بأي فرع if ومن\nثم يمكننا اختياريًا إضافة فرع آخر في النهاية. حتى نتمكن من رؤية ما يفعله الكمبيوتر، دعونا نتتبع كل مسار تنفيذ محتمل. إذا تم تقييم الشرط الأول على أنه صحيح، فسيختار الكمبيوتر ذلك الفرع ويقوم بتنفيذ أي تعليمات\nتم وضع مسافة بادئة بداخله. ثم ينتقل إلى السطر التالي من التعليمات البرمجية خارج الشرط. إذا تم تقييم الشرط الأول على أنه خطأ، فسيقوم الكمبيوتر\nبالتحقق من الشرط التالي. إذا تم تقييم الشرط الثاني على أنه صحيح، فسيختار الكمبيوتر هذا الفرع وينفذ أي تعليمات تم وضع\nمسافة بادئة بداخله. ثم ينتقل إلى السطر التالي من التعليمات البرمجية خارج الشرط. إذا قام الكمبيوتر بالتحقق من\nالشرط الأول، ووجد أنه تم تقييمه على خطأ، ثم تحقق من الشرط الثاني، ووجد أيضًا أنه تم تقييمه على خطأ، ثم انتقل إلى الفرع آخر.  أما الفروع الأخرى فليس لها شرط، فإذا\nوصل إليها الكمبيوتر يعمل فقط. لذلك نقوم بتنفيذ التعليمات التي تم وضع مسافة بادئة لها داخل الفرع else ثم ننتقل إلى السطر التالي من التعليمات البرمجية خارج الشرط. لذا، إذا كان لديك عدة\nشروط مرتبطة في برنامجك، فمن الأفضل عمومًا استخدام\nسلسلة شرطية مع فروع elif و else بدلاً\nمن عدة شروط شرطية مستقلة ذات فرع واحد. تجعل الشروط الشرطية المتسلسلة\nالبرامج أسهل في القراءة لأنها تجعل العلاقة بين الشروط واضحة. إنه يقلل من الأخطاء لأننا\nكمبرمجين لا داعي للقلق بشأن\nالتأكد من أن جميع شروطنا حصرية\nوتغطي جميع الحالات المحتملة وتوفر على الكمبيوتر بعض العمل. مع الشروط المستقلة التي لا\nيعرف الكمبيوتر أنها مرتبطة، لذلك سيقيم كل واحدة منها\n، حتى لو كان من المستحيل أن يكون العديد منها صحيحًا. باستخدام الشرطيات المتسلسلة، نعطي الكمبيوتر تلميحًا بأن هذه كلها متنافية، حتى يعرف أنه يمكنه التوقف عن التقييم بمجرد العثور على فرع يتم\nتقييمه على أنه صحيح.",
    "t_italian": "- [Istruttore] Possiamo utilizzare\nun'istruzione IF per controllare che un particolare blocco\ndi codice venga eseguito solo quando la condizione risulta vera. Ma cosa succede se vogliamo fare qualcos'altro solo quando la condizione\nrisulta falsa? Bene, possiamo aggiungere un'altra\nistruzione IF e provare a costruire una condizione\nche sia l'esatto opposto della condizione originale. È un po' fastidioso e talvolta la\ncondizione opposta non è ovvia o è molto lunga. Per risparmiarci la fatica, Python ci permette invece di usare un ramo else. Possiamo inserire un ramo else\nalla fine di qualsiasi istruzione IF e qualsiasi istruzione rientrata\nall'interno del ramo else verrà eseguita solo se la\ncondizione dell'istruzione IF corrispondente risulta falsa. Ciò rende il ramo IF e il ramo else mutuamente\nesclusivi in ​​base alla risposta alla condizione, il computer decide quale\ndei due percorsi intraprendere. La sintassi Python per un ramo else è semplicemente la parola chiave else seguita da due punti. Ancora una volta usiamo l'indentazione\nper dire al computer quali righe di codice si trovano\nall'interno del ramo else. Un ramo else deve sempre\nseguire un ramo IF. Altrimenti, cosa stiamo\nprendendo il contrario? Tracciamo il percorso di esecuzione. Se la condizione risulta\nvera come di consueto, il computer procede con l'\nesecuzione di tutte le istruzioni rientrate all'interno di quel ramo IF. Al termine, l'esecuzione\npassa alla riga di codice successiva con rientro esterno\nal condizionale. Se la condizione risulta falsa, il computer salta il\nresto del ramo IF e passa al ramo else. Quindi esegue tutte le righe\ndi codice rientrate all'interno del ramo else. Al termine,\ncontinua semplicemente l'esecuzione con la riga di codice successiva rientrata al di fuori del condizionale. Nota che questo percorso di esecuzione con un ramo else è\ndiverso da questo, dove abbiamo solo l'\nistruzione rientrata all'esterno dell'istruzione IF. Qui se la condizione risulta vera, stampiamo il layout mobile, quindi usciamo dal condizionale e stampiamo il layout desktop. Se la condizione risulta falsa, saltiamo il ramo IF, usciamo\ndal condizionale e stampiamo il layout del desktop. Poiché l'istruzione non è rientrata, è indipendente dal\ncondizionale` e viene sempre eseguita. Tuttavia, se invece rientriamo questa istruzione all'interno di un ramo else, stampiamo il layout del desktop solo\nse la condizione risulta falsa. Se la condizione risulta vera, stampiamo il layout mobile\ne saltiamo il ramo else. Cosa succede se abbiamo più di due casi come un tablet mobile e un layout desktop? Potremmo provare a costruire tre condizioni mutuamente esclusive\noppure possiamo sfruttare una scorciatoia e utilizzare il ramo elif. Il ramo elif o else IF ci consente di concatenare più\ncondizioni insieme. A partire dal ramo IF, il computer valuta\nciascuna condizione in ordine finché non ne trova una che risulta vera, quindi sceglie quel ramo da eseguire. Tieni presente che l'ordine è importante qui perché il computer\nsmetterà di controllare gli altri rami non appena ne troverà uno\nche risulti vero. Se invece metto prima questa condizione, il ramo IF\ncatturerebbe qualsiasi larghezza dello schermo inferiore a 760. Ciò significa che se ho uno schermo mobile che dice 300 pixel,\nverrà catturato da questo primo caso e\nstamperà il layout del tablet. Il computer sceglie sempre e solo un ramo. Non stampa il layout mobile. Anche se tale condizione\nsarebbe stata valutata come vera. Possiamo allegare tutti i\nrami elif che vogliamo a qualsiasi ramo if e\npoi possiamo opzionalmente aggiungere un ramo else alla fine. Per poter vedere cosa sta facendo il computer, tracciamo ogni possibile percorso di esecuzione. Se la prima condizione risulta vera, il computer sceglie quel ramo ed esegue tutte le istruzioni\nrientrate al suo interno. Quindi passa alla riga di codice successiva al di fuori del condizionale. Se la prima condizione risulta falsa, il computer passa\na verificare la condizione successiva. Se la seconda condizione risulta vera, il computer sceglie questo ramo ed esegue tutte le istruzioni\nrientrate al suo interno. Quindi passa alla riga di codice successiva al di fuori del condizionale. Se il computer controlla\nla prima condizione, scopre che il valore è falso, poi controlla la seconda condizione, scopre anche che il valore è falso, quindi passa al ramo else else.  Gli altri rami non hanno una condizione, quindi se il computer\nlo raggiunge, viene semplicemente eseguito. Quindi eseguiamo le istruzioni rientrate all'interno del ramo else e poi passiamo alla riga di codice successiva al di fuori del condizionale. Quindi, se\nnel tuo programma sono presenti più condizioni correlate, in genere è meglio utilizzare\nun condizionale a catena con elif e else branch invece\ndi diversi condizionali a ramo singolo indipendenti.  I condizionali a catena rendono i\nprogrammi più facili da leggere perché rendono ovvia la relazione tra le condizioni. Riduce i bug perché\nnoi, come programmatori, non dobbiamo preoccuparci di\nassicurarci che tutte le nostre condizioni si escludano a vicenda e\ncoprano tutti i casi possibili e fa risparmiare un po' di lavoro al computer. Con condizioni indipendenti che il computer non\nsa che sono correlate, quindi le valuterà\ntutte, anche se è impossibile che più di esse siano vere. Con i condizionali a catena, diamo al computer il suggerimento che questi si escludono a vicenda, in modo che sappia che può interrompere la valutazione non appena trova un ramo\nche restituisce vero."
}