{
    "source": "276Djs2h18Y",
    "youtubelink": "https://www.youtube.com/watch?v=276Djs2h18Y",
    "t_english": "- [Narrator] What happens if you indent a conditional inside another conditional? To trace how the computer executes a program with nested conditionals, we need to look at the indentation. We know that an if starts a new conditional, so that means we have two conditionals here, but which if does this else branch belong to? The computer matches elif and else branches to if branches based on the indentation. These three lines are not indented. They're right up against the left margin. Then these lines of code are indented one level in, that's one tab over. Then this line of code is indented two levels in, that's two tabs over. So this else branch must belong to this if branch because they're at the same level of indentation. If instead I indented it one level over, it would now belong to this if branch because these would now be at the same level of indentation. We can visualize this another way using a control flow diagram. We ask the user to enter a password and then we check the condition. Does it have enough characters? If the answer to that is no, that's the else branch, then we display an error message. But if the answer to that is yes, that's the if branch, then we change the password. Only then do we ask the question, is it an easily guessable password? We only wanna ask this question if the answer to this other question was yes. That's a nested conditional. So in the code, this conditional would be indented inside this conditional and then we only display a warning if the answer to this second question was yes. What about nesting a conditional inside the else branch? Here, I've reversed our condition. So now I'm asking is the password too short? If yes, I print an informative error message and if no, then I change the password. But what if I wanna do that thing where I ask the user to enter the password a second time to confirm and only change the password if they match? I'm gonna want another input function call where I asked the user to reenter the password and I only want that to happen if the first password they entered was valid. So I'm gonna put it inside the else branch. Then I wanna check if the two passwords match. I only need to check this if they reentered a password in the first place. If they didn't, I don't care. So I'm going to nest this condition inside the else branch. If they don't match, I'll print an error message and if they do match, then I'll change the password. Now let's test this with a few different inputs to see the execution path. If I enter a short password where this condition evaluates to true, then I print this error message and I skip everything inside the else branch. I'm now asked to reenter a password and neither of these print, so that means this conditional isn't executing. If I enter a password that's long enough, then I'm asked to confirm and if I typo something, we're seeing that this conditional is executing because I'm getting passwords don't match. And in the last possible case, if it is long enough, I reenter and they do match, then I see this else branch is executing and I'm getting password changed. Note that this execution with this conditional nested inside the else branch is different from if I didn't indent this conditional at all. Without the nesting, the computer always executes this conditional so it always checks if the passwords match. If my password was too short, it doesn't really make sense to check this condition. I don't have a confirmed password. In fact, this gives a name error. I can get around that name error by initializing confirm password to the empty string. But now if the password's too short, this condition will always evaluate to true and we'll print passwords don't match, which I don't want 'cause it's confusing to the user because they weren't asked to confirm so they're like, \"What do you mean doesn't match? Doesn't match what?\" So if you only wanna check a condition based on the result of another condition, you can nest it inside the if, elif, or else branch of the first conditional. Technically, you can go as many levels deep here as you want. You can be nesting an if inside another if, inside an elif inside an else, inside an if. But now we're four levels of indentation deep and it's really hard to read how the control flow works. So try to go no more than two layers deep, three, if you have to. With compound conditions, chain conditionals and nested conditionals in our toolkit, we can often rewrite our code in different ways to reduce the level of nesting. So always make sure you're evaluating that trade off between readability and efficiency.\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n",
    "t_urdu": "- [راوی]\nاگر آپ کسی دوسرے مشروط کے اندر ایک مشروط حاشیہ ڈالیں تو کیا ہوگا؟  یہ معلوم کرنے کے لیے کہ کمپیوٹر\n نیسٹڈ کنڈیشنلز کے ساتھ کسی پروگرام کو کیسے چلاتا ہے، ہمیں انڈینٹیشن کو دیکھنے کی ضرورت ہے۔ ہم جانتے ہیں کہ اگر ایک\nنیا مشروط شروع کرتا ہے، تو اس کا مطلب ہے کہ ہمارے\nیہاں دو مشروط ہیں، لیکن اگر یہ\nدوسری شاخ سے تعلق رکھتی ہے تو کون سا ہے؟ کمپیوٹر\nایلیف اور دیگر شاخوں سے میل کرتا ہے اگر انڈینٹیشن کی بنیاد پر شاخیں بنتی ہیں۔ یہ تینوں لائنیں حاشیہ میں نہیں ہیں۔ وہ دائیں بائیں مارجن کے خلاف ہیں۔ پھر کوڈ کی ان لائنوں کو\nایک لیول میں انڈینٹ کیا جاتا ہے، یہ ایک ٹیب اوور ہے۔ پھر کوڈ کی اس لائن کو\nدو درجوں میں انڈینٹ کیا جاتا ہے، یعنی دو ٹیبز ختم ہوتے ہیں۔ لہذا یہ دوسری شاخ\nاس سے تعلق رکھتی ہے اگر برانچ ہے کیونکہ وہ\nانڈینٹیشن کی ایک ہی سطح پر ہیں۔ اگر اس کے بجائے میں نے اسے ایک لیول پر انڈینٹ کیا تو اب اس کا تعلق اس if برانچ سے ہوگا کیونکہ یہ اب\nانڈینٹیشن کی اسی سطح پر ہوں گے۔ ہم کنٹرول فلو ڈایاگرام کا استعمال کرتے ہوئے اسے دوسرے طریقے سے تصور کر سکتے ہیں۔ ہم صارف سے پاس ورڈ درج کرنے کو کہتے ہیں اور پھر ہم شرط چیک کرتے ہیں۔  کیا اس میں کافی کردار ہیں؟ اگر اس کا جواب نہیں ہے، یہ دوسری شاخ ہے، تو ہم ایک ایرر میسج ڈسپلے کرتے ہیں۔ لیکن اگر اس کا جواب ہاں میں ہے، یہ if برانچ ہے، تو ہم پاس ورڈ تبدیل کر دیتے ہیں۔ تبھی ہم سوال پوچھتے ہیں، کیا یہ آسانی سے اندازہ لگانے والا پاس ورڈ ہے؟ ہم صرف یہ سوال پوچھنا چاہتے ہیں اگر اس\nدوسرے سوال کا جواب ہاں میں ہو۔ یہ ایک نیسٹڈ مشروط ہے۔ لہذا کوڈ میں، اس مشروط کو\nاس مشروط کے اندر انڈینٹ کیا جائے گا اور پھر ہم صرف ایک انتباہ ظاہر کرتے ہیں اگر اس\nدوسرے سوال کا جواب ہاں میں ہو۔  دوسری شاخ کے اندر مشروط گھوںسلا کرنے کے بارے میں کیا خیال ہے\n؟ یہاں، میں نے اپنی حالت کو تبدیل کر دیا ہے۔ تو اب میں پوچھ رہا ہوں کیا\nپاس ورڈ بہت چھوٹا ہے؟ اگر ہاں، تو میں ایک\nمعلوماتی غلطی کا پیغام پرنٹ کرتا ہوں اور اگر نہیں، تو میں پاس ورڈ تبدیل کرتا ہوں۔ لیکن کیا ہوگا اگر میں وہ کام کرنا چاہتا ہوں جہاں میں صارف سے تصدیق کرنے کے لیے دوسری بار پاس ورڈ درج کرنے کو کہوں اور صرف\nپاس ورڈ تبدیل کرنے کے لیے کہتا ہوں اگر وہ مماثل ہوں؟ میں ایک اور ان پٹ فنکشن کال چاہتا ہوں جہاں میں نے صارف سے\nپاس ورڈ دوبارہ درج کرنے کو کہا اور میں صرف یہ چاہتا ہوں کہ اس کا داخل کردہ پہلا پاس ورڈ\nدرست ہو۔ تو میں اسے\nدوسری شاخ کے اندر ڈال دوں گا۔ پھر میں یہ دیکھنا چاہتا ہوں کہ آیا\nدونوں پاس ورڈ مماثل ہیں۔ مجھے صرف یہ چیک کرنے کی ضرورت ہے اگر انہوں نے\nپہلی جگہ پاس ورڈ دوبارہ درج کیا ہو۔ اگر انہوں نے ایسا نہیں کیا تو مجھے کوئی پرواہ نہیں۔ تو میں اس\nحالت کو دوسری شاخ کے اندر گھوںسلا کرنے جا رہا ہوں۔ اگر وہ مماثل نہیں ہیں، میں\nایک غلطی کا پیغام پرنٹ کروں گا اور اگر وہ مماثل ہیں، تو\nمیں پاس ورڈ تبدیل کردوں گا۔ اب\n عمل درآمد کا راستہ دیکھنے کے لیے کچھ مختلف ان پٹ کے ساتھ اس کی جانچ کرتے ہیں۔ اگر میں ایک مختصر پاس ورڈ درج کرتا ہوں جہاں اس شرط کا درست اندازہ ہوتا ہے، تو میں اس ایرر میسج کو پرنٹ کرتا ہوں اور دوسری برانچ کے اندر موجود ہر چیز کو چھوڑ دیتا ہوں۔\n اب مجھ سے پاس ورڈ دوبارہ درج کرنے کو کہا گیا ہے اور ان میں سے کوئی بھی پرنٹ نہیں، اس کا مطلب ہے کہ یہ\nمشروط عمل نہیں کر رہا ہے۔ اگر میں کافی لمبا پاس ورڈ درج کرتا ہوں، تو مجھ سے تصدیق کرنے کو کہا جاتا ہے اور اگر میں کچھ ٹائپ کرتا ہوں، تو ہم دیکھ رہے ہیں کہ یہ\nمشروط کام کر رہا ہے کیونکہ مجھے پاس ورڈ ملتے نہیں ہیں۔ اور آخری ممکنہ صورت میں، اگر یہ کافی لمبا ہے، میں دوبارہ داخل کرتا ہوں اور وہ میچ کرتے ہیں، پھر میں دیکھتا ہوں کہ یہ دوسری برانچ کام کر رہی ہے اور میں پاس ورڈ تبدیل کر رہا ہوں۔ نوٹ کریں کہ else برانچ کے اندر اس مشروط نیسٹڈ کے ساتھ یہ عمل اس\n سے مختلف ہے اگر میں نے اس مشروط کو بالکل بھی انڈینٹ نہیں کیا تھا۔ گھونسلے کے بغیر، کمپیوٹر ہمیشہ\nاس مشروط کو انجام دیتا ہے لہذا یہ ہمیشہ چیک کرتا ہے کہ آیا\nپاس ورڈز مماثل ہیں۔ اگر میرا پاس ورڈ بہت چھوٹا تھا، تو اس شرط کو چیک کرنا واقعی کوئی معنی نہیں رکھتا۔\n میرے پاس تصدیق شدہ پاس ورڈ نہیں ہے۔ اصل میں، یہ ایک نام کی غلطی دیتا ہے. میں \nخالی اسٹرنگ میں تصدیق پاس ورڈ شروع کرکے اس نام کی غلطی کو دور کرسکتا ہوں۔ لیکن اب اگر پاس ورڈ بہت چھوٹا ہے، تو یہ شرط\nہمیشہ درست پر جانچے گی اور ہم ایسے پاس ورڈز پرنٹ کریں گے جو مماثل نہیں ہیں، جو میں نہیں چاہتا 'کیونکہ\nیہ صارف کے لیے الجھا ہوا ہے کیونکہ ان سے تصدیق کرنے کے لیے نہیں کہا گیا تھا '۔  دوبارہ کی طرح، \"\nآپ کا کیا مطلب ہے کہ مماثل نہیں ہے؟ کیا مماثل نہیں ہے؟\" لہذا اگر آپ صرف کسی دوسری حالت کے نتیجے کی بنیاد پر کسی شرط کو چیک کرنا چاہتے ہیں، تو آپ اسے\nif، elif، یا else برانچ کے اندر پہلے کنڈیشنل کے اندر گھونسلا کر سکتے ہیں۔ تکنیکی طور پر، آپ\nیہاں جتنی گہرائیاں چاہیں جا سکتے ہیں۔ آپ\nایک دوسرے کے اندر اگر ایک دوسرے کے اندر گھونسلا بنا سکتے ہیں، ایک ایلیف کے اندر ایک\nدوسرے کے اندر، ایک اگر کے اندر۔ لیکن اب ہم انڈینٹیشن کے چار درجے\nگہرے ہیں اور یہ پڑھنا واقعی مشکل ہے کہ\nکنٹرول فلو کیسے کام کرتا ہے۔ اس لیے کوشش کریں کہ دو تہوں سے زیادہ گہرائی میں نہ جائیں، تین، اگر آپ کو کرنا ہے۔ \n ہماری ٹول کٹ میں کمپاؤنڈ کنڈیشنز، چین کنڈیشنلز اور نیسٹڈ کنڈیشنلز کے ساتھ، ہم اکثر اپنے\nکوڈ کو مختلف طریقوں سے دوبارہ لکھ سکتے ہیں تاکہ نیسٹنگ کی سطح کو کم کیا جا سکے۔ لہذا ہمیشہ اس بات کو یقینی بنائیں کہ آپ\n پڑھنے کی اہلیت اور کارکردگی کے درمیان تجارت کا جائزہ لے رہے ہیں۔",
    "t_spanish": "- [Narrador] ¿Qué pasa\nsi sangras un condicional dentro de otro condicional? Para rastrear cómo la computadora\nejecuta un programa con condicionales anidados, debemos observar la sangría. Sabemos que un if\ninicia un nuevo condicional, lo que significa que tenemos\ndos condicionales aquí, pero ¿a cuál if\npertenece esta rama else? La computadora compara\nlas ramas elif y else con las ramas if según la sangría. Estas tres líneas no tienen sangría. Están justo contra el margen izquierdo. Luego, estas líneas de código\ntienen sangría de un nivel, es decir, una pestaña por encima. Luego, esta línea de código tiene una\nsangría de dos niveles, es decir, dos pestañas por encima. Entonces esta rama else debe\npertenecer a esta rama if porque están en el\nmismo nivel de sangría. Si, en cambio, le aplicara una sangría un nivel superior, ahora pertenecería a esta rama if porque ahora estarían en\nel mismo nivel de sangría. Podemos visualizar esto de otra manera usando un diagrama de flujo de control.  Le pedimos al usuario que ingrese una contraseña y luego verificamos la condición.  ¿ Tiene suficientes personajes? Si la respuesta es no, esa es la rama else, entonces mostramos un mensaje de error. Pero si la respuesta es sí, esa es la rama if, entonces cambiamos la contraseña. Sólo entonces nos hacemos la pregunta: ¿ es una contraseña fácil de adivinar? Sólo queremos hacer esta pregunta si la respuesta a esta\notra pregunta fue sí. Ese es un condicional anidado. Entonces, en el código, este condicional tendría\nsangría dentro de este condicional y luego solo mostraríamos una advertencia si la respuesta a esta\nsegunda pregunta fuera sí.  ¿ Qué tal anidar un condicional\ndentro de la rama else? Aquí he revertido nuestra condición. Entonces ahora pregunto: ¿\nla contraseña es demasiado corta? Si es así, imprimo un\nmensaje de error informativo y si no, entonces cambio la contraseña. Pero, ¿qué pasa si quiero hacer eso en el que le pido al usuario que ingrese la contraseña por segunda vez para confirmar y solo cambiar la\ncontraseña si coinciden? Voy a querer otra llamada a la función de entrada en la que le pedí al usuario que\nvolviera a ingresar la contraseña y solo quiero que eso suceda si la primera contraseña que\ningresó era válida. Entonces lo pondré\ndentro de la rama else. Entonces quiero comprobar si\nlas dos contraseñas coinciden. Sólo necesito verificar esto si volvieron a ingresar una\ncontraseña en primer lugar. Si no lo hicieron, no me importa. Entonces voy a anidar esta\ncondición dentro de la rama else. Si no coinciden,\nimprimiré un mensaje de error y si coinciden,\ncambiaré la contraseña. Ahora probemos esto con\nalgunas entradas diferentes para ver la ruta de ejecución. Si ingreso una contraseña corta donde esta condición se evalúa como verdadera, imprimo este mensaje de error y me salto todo lo que hay\ndentro de la rama else. Ahora se me pide que vuelva a ingresar una contraseña y ninguna de estas se imprime, lo que significa que este\ncondicional no se está ejecutando. Si ingreso una contraseña que es lo suficientemente larga, se me pide que confirme y si escribo algo, vemos que este\ncondicional se ejecuta porque obtengo que las contraseñas no coinciden. Y en el último caso posible, si es lo suficientemente largo, vuelvo a ingresar y coinciden, luego veo que esta rama else se está ejecutando y me cambian la contraseña. Tenga en cuenta que esta ejecución con este condicional anidado\ndentro de la rama else es diferente a si no aplicara ninguna sangría a este condicional. Sin el anidamiento, la computadora siempre\nejecuta este condicional, por lo que siempre verifica si\nlas contraseñas coinciden. Si mi contraseña era demasiado corta, realmente no tiene sentido\nverificar esta condición. No tengo una contraseña confirmada. De hecho, esto da un error de nombre. Puedo solucionar ese error de nombre inicializando la\ncontraseña de confirmación en la cadena vacía. Pero ahora, si la contraseña es demasiado corta, esta condición\nsiempre se evaluará como verdadera e imprimiremos las contraseñas que no coinciden, lo cual no quiero porque\nes confuso para el usuario porque no se les pidió que confirmaran, por lo que  Dices: \"¿Qué\nquieres decir con que no coincide? ¿ No coincide con qué?\" Entonces, si solo desea verificar una condición basándose en el resultado de otra condición, puede anidarla dentro de la\nrama if, elif o else del primer condicional. Técnicamente, puedes\nprofundizar tantos niveles como quieras. Puedes anidar un\nif dentro de otro if, dentro de un elif dentro de\nun else, dentro de un if. Pero ahora tenemos cuatro niveles\nde sangría profunda y es realmente difícil leer\ncómo funciona el flujo de control. Así que trate de no tener más de dos capas de profundidad, tres, si es necesario. Con condiciones compuestas,\ncondicionales en cadena y condicionales anidados en nuestro conjunto de herramientas, a menudo podemos reescribir nuestro\ncódigo de diferentes maneras para reducir el nivel de anidamiento. Por lo tanto, asegúrese siempre de\nevaluar el equilibrio entre legibilidad y eficiencia.",
    "t_arabic": "- [الراوي] ماذا يحدث\nإذا وضعت مسافة بادئة شرطية داخل شرطية أخرى؟ لتتبع كيفية قيام الكمبيوتر\nبتنفيذ برنامج باستخدام الشروط الشرطية المتداخلة، نحتاج إلى إلقاء نظرة على المسافة البادئة. نحن نعلم أن if\nيبدأ شرطًا جديدًا، وهذا يعني أن لدينا\nشرطين هنا، ولكن إلى أي\nفرع ينتمي هذا الشرط؟  يقوم الكمبيوتر بمطابقة\nفروع elif و else مع فروع if بناءً على المسافة البادئة. لم يتم وضع مسافة بادئة لهذه الأسطر الثلاثة. إنهم على الجانب الأيمن من الهامش الأيسر. ثم يتم وضع مسافة بادئة لهذه الأسطر من التعليمات البرمجية\nبمستوى واحد، أي علامة تبويب واحدة. ثم يتم وضع مسافة بادئة لهذا السطر من التعليمات البرمجية على\nمستويين، أي بعد علامتي تبويب. لذلك يجب أن ينتمي هذا الفرع الآخر\nإلى هذا الفرع لأنهما على\nنفس مستوى المسافة البادئة. إذا قمت بدلاً من ذلك بوضع مسافة بادئة له على مستوى واحد، فسوف ينتمي الآن إلى هذا الفرع لأنه سيكون الآن على\nنفس مستوى المسافة البادئة. يمكننا تصور ذلك بطريقة أخرى باستخدام مخطط تدفق التحكم. نطلب من المستخدم إدخال كلمة المرور ثم نتحقق من الحالة.  هل لديها ما يكفي من الشخصيات؟ إذا كانت الإجابة على ذلك هي لا، فهذا هو الفرع الآخر، ثم نعرض رسالة خطأ. ولكن إذا كانت الإجابة بنعم، فهذا هو الفرع if، ثم نقوم بتغيير كلمة المرور. عندها فقط نطرح السؤال، هل هي كلمة مرور يمكن تخمينها بسهولة؟ نريد فقط أن نطرح هذا السؤال إذا كانت الإجابة على هذا\nالسؤال الآخر هي نعم. هذا شرط متداخل. لذلك في الكود، سيتم وضع\nمسافة بادئة لهذا الشرط داخل هذا الشرط ثم نعرض تحذيرًا فقط إذا كانت الإجابة على هذا\nالسؤال الثاني هي نعم. ماذا عن تداخل الشرط\nداخل الفرع else؟ هنا، لقد عكست حالتنا. والآن أنا أسأل هل\nكلمة المرور قصيرة جدًا؟ إذا كانت الإجابة بنعم، أقوم بطباعة\nرسالة خطأ إعلامية، وإذا كانت الإجابة لا، أقوم بتغيير كلمة المرور. ولكن ماذا لو أردت أن أفعل هذا الشيء حيث أطلب من المستخدم إدخال كلمة المرور مرة ثانية للتأكيد وتغيير\nكلمة المرور فقط إذا كانت متطابقة؟ أريد استدعاء وظيفة إدخال أخرى حيث أطلب من المستخدم\nإعادة إدخال كلمة المرور وأريد أن يحدث ذلك فقط إذا كانت كلمة المرور الأولى التي\nأدخلها صالحة. لذلك سأضعه\nداخل الفرع الآخر. ثم أريد التحقق من\nتطابق كلمتي المرور. أحتاج فقط إلى التحقق من ذلك إذا قاموا بإعادة إدخال\nكلمة المرور في المقام الأول. إذا لم يفعلوا ذلك، فلا يهمني. لذلك سأقوم بدمج هذا\nالشرط داخل الفرع الآخر. إذا لم تكن متطابقة،\nسأطبع رسالة خطأ وإذا كانت متطابقة، فسوف\nأقوم بتغيير كلمة المرور. الآن دعونا نختبر ذلك باستخدام\nبعض المدخلات المختلفة لرؤية مسار التنفيذ. إذا قمت بإدخال كلمة مرور قصيرة حيث يتم تقييم هذا الشرط على أنه صحيح، فأنا أطبع رسالة الخطأ هذه وأتخطى كل شيء\nداخل الفرع else. يُطلب مني الآن إعادة إدخال كلمة المرور ولم تتم طباعة أي منهما، وهذا يعني\nعدم تنفيذ هذا الشرط. إذا قمت بإدخال كلمة مرور طويلة بما فيه الكفاية، فسيُطلب مني التأكيد وإذا أخطأت في كتابة شيء ما، فسنرى أن هذا\nالشرط يتم تنفيذه لأنني أحصل على كلمات مرور غير متطابقة. وفي الحالة الأخيرة الممكنة، إذا كانت طويلة بما يكفي، أعيد الدخول وكانا متطابقين، ثم أرى أن هذا الفرع الآخر قيد التنفيذ ويتم تغيير كلمة المرور. لاحظ أن هذا التنفيذ مع هذا الشرطي المتداخل\nداخل الفرع else يختلف عما إذا لم أقم بوضع مسافة بادئة لهذا الشرط على الإطلاق. بدون التداخل، يقوم الكمبيوتر دائمًا\nبتنفيذ هذا الشرط، لذلك يتحقق دائمًا من\nتطابق كلمات المرور. إذا كانت كلمة المرور الخاصة بي قصيرة جدًا، فليس من المنطقي حقًا\nالتحقق من هذا الشرط. ليس لدي كلمة مرور مؤكدة. في الواقع، هذا يعطي خطأ في الاسم. يمكنني التغلب على خطأ الاسم هذا عن طريق تهيئة تأكيد\nكلمة المرور للسلسلة الفارغة. ولكن الآن إذا كانت كلمة المرور قصيرة جدًا، فسيتم تقييم هذا الشرط\nدائمًا على أنه صحيح وسنقوم بطباعة كلمات المرور غير متطابقة، وهو ما لا أريده لأنه\nمربك للمستخدم لأنه لم يُطلب منه التأكيد لذلك \"  إعادة مثل، \"ماذا\nتقصد لا يتطابق؟ لا يتطابق مع ماذا؟\" لذلك، إذا كنت تريد فقط التحقق من شرط ما بناءً على نتيجة شرط آخر، فيمكنك تضمينه داخل\nفرع if أو elif أو else من الشرط الأول. من الناحية الفنية، يمكنك الذهاب إلى\nأي عدد تريده من المستويات هنا . يمكنك تداخل\nif داخل if آخر، داخل elif داخل\nآخر، داخل if. ولكننا الآن وصلنا إلى أربعة مستويات\nمن المسافة البادئة ومن الصعب حقًا قراءة\nكيفية عمل تدفق التحكم. لذا حاول ألا تتجاوز عمق طبقتين، أو ثلاث، إذا كان عليك ذلك. باستخدام الشروط المركبة\nوالشروط المتسلسلة والشروط المتداخلة في مجموعة أدواتنا، يمكننا غالبًا إعادة كتابة الكود الخاص بنا\nبطرق مختلفة لتقليل مستوى التداخل. لذا تأكد دائمًا من\nتقييم تلك المفاضلة بين سهولة القراءة والكفاءة.",
    "t_italian": "- [Narratore] Cosa succede\nse rientri un condizionale all'interno di un altro condizionale? Per tracciare come il computer\nesegue un programma con condizionali annidati, dobbiamo osservare il rientro. Sappiamo che un if\ninizia un nuovo condizionale, quindi significa che abbiamo\ndue condizionali qui, ma a quale if\nappartiene questo ramo else? Il computer abbina i\nrami elif e else ai rami if in base al rientro. Queste tre righe non sono rientrate. Sono proprio contro il margine sinistro. Quindi queste righe di codice\nvengono rientrate di un livello, ovvero una scheda sopra. Quindi questa riga di codice viene\nrientrata di due livelli, ovvero due schede sopra. Quindi questo ramo else deve\nappartenere a questo ramo if perché sono allo\nstesso livello di rientro. Se invece lo rientrassi di un livello superiore, ora apparterrebbe a questo ramo if perché ora si troverebbero allo\nstesso livello di rientro. Possiamo visualizzarlo in un altro modo utilizzando un diagramma di flusso di controllo. Chiediamo all'utente di inserire una password e poi controlliamo la condizione. Ha abbastanza personaggi? Se la risposta è no, quello è il ramo else, quindi visualizzeremo un messaggio di errore. Ma se la risposta è sì, quello è il ramo if, allora cambiamo la password. Solo allora ci poniamo la domanda: è una password facilmente indovinabile? Vogliamo porre questa domanda solo se la risposta a\nquest'altra domanda è sì. Questo è un condizionale nidificato. Quindi nel codice, questo condizionale verrebbe\nrientrato all'interno di questo condizionale e quindi visualizzeremo un avviso solo se la risposta a questa\nseconda domanda fosse sì. Che ne dici di annidare un condizionale\nall'interno del ramo else? Ecco, ho invertito la nostra condizione. Quindi ora mi chiedo:\nla password è troppo corta? Se sì, stampo un\nmessaggio di errore informativo e, in caso negativo, cambio la password. Ma cosa succede se voglio fare quella cosa in cui chiedo all'utente di inserire la password una seconda volta per confermare e cambiare la\npassword solo se corrisponde? Avrò bisogno di un'altra chiamata alla funzione di input in cui chiedo all'utente\ndi reinserire la password e voglio che ciò accada solo se la prima password\ninserita era valida. Quindi lo inserirò\nnel ramo else. Quindi voglio verificare se\nle due password corrispondono. Devo verificarlo solo se hanno reinserito la\npassword in primo luogo. Se non lo facessero, non mi interessa. Quindi anniderò questa\ncondizione all'interno del ramo else. Se non corrispondono,\nstamperò un messaggio di errore e se corrispondono,\ncambierò la password. Ora testiamolo con\nalcuni input diversi per vedere il percorso di esecuzione. Se inserisco una password breve in cui questa condizione risulta vera, stampo questo messaggio di errore e salto tutto\nall'interno del ramo else. Ora mi viene chiesto di inserire nuovamente una password e nessuno dei due viene stampato, quindi ciò significa che questo\ncondizionale non viene eseguito. Se inserisco una password sufficientemente lunga, mi viene chiesto di confermare e se sbaglio qualcosa, vediamo che questo\ncondizionale viene eseguito perché ricevo che le password non corrispondono. E nell'ultimo caso possibile, se è abbastanza lungo, rientro e corrispondono, quindi vedo che questo ramo else è in esecuzione e ricevo la modifica della password. Nota che questa esecuzione con questo condizionale annidato\nall'interno del ramo else è diversa da se non avessi rientrato affatto questo condizionale. Senza l'annidamento, il computer\nesegue sempre questo condizionale quindi controlla sempre se\nle password corrispondono. Se la mia password era troppo corta, non ha senso\nverificare questa condizione. Non ho una password confermata. In effetti, questo dà un errore nel nome. Posso aggirare l'errore del nome inizializzando la conferma della\npassword sulla stringa vuota. Ma ora se la password è troppo corta, questa condizione verrà\nsempre valutata vera e stamperemo le password non corrispondono, cosa che non voglio perché crea\nconfusione per l'utente perché non gli è stato chiesto di confermare, quindi \"  rispondi: \"Cosa\nintendi con non corrisponde? Non corrisponde a cosa?\" Quindi, se vuoi solo controllare una condizione in base al risultato di un'altra condizione, puoi annidarla all'interno del\nramo if, elif o else del primo condizionale. Tecnicamente, qui puoi raggiungere tutti i\nlivelli di profondità che desideri. Puoi annidare un\nse all'interno di un altro se, all'interno di un elif all'interno di un\naltro, all'interno di un if. Ma ora siamo a quattro livelli\ndi rientro profondo ed è davvero difficile leggere\ncome funziona il flusso di controllo. Quindi cerca di non andare più in profondità di due strati, tre, se necessario. Con le condizioni composte, i\ncondizionali a catena e i condizionali nidificati nel nostro toolkit, possiamo spesso riscrivere il nostro\ncodice in modi diversi per ridurre il livello di nidificazione. Quindi assicurati sempre di\nvalutare il compromesso tra leggibilità ed efficienza."
}